/* automatically generated by rust-bindgen 0.59.2 */

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const YES: u32 = 1;
pub const NO: u32 = 0;
pub const DEBUG: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const USE_BN_ECC_DATA: u32 = 1;
pub const SIMULATION: u32 = 1;
pub const LIBRARY_COMPATIBILITY_CHECK: u32 = 1;
pub const FIPS_COMPLIANT: u32 = 1;
pub const USE_DA_USED: u32 = 1;
pub const TABLE_DRIVEN_DISPATCH: u32 = 1;
pub const SELF_TEST: u32 = 1;
pub const RSA_KEY_SIEVE: u32 = 1;
pub const RSA_INSTRUMENT: u32 = 0;
pub const _DRBG_STATE_SAVE: u32 = 1;
pub const COMPRESSED_LISTS: u32 = 1;
pub const CLOCK_STOPS: u32 = 0;
pub const USE_MARSHALING_DEFINES: u32 = 1;
pub const USE_RSA_KEY_CACHE: u32 = 1;
pub const USE_KEY_CACHE_FILE: u32 = 1;
pub const USE_DEBUG_RNG: u32 = 0;
pub const COMPILER_CHECKS: u32 = 0;
pub const RUNTIME_SIZE_CHECKS: u32 = 1;
pub const DRBG_DEBUG_PRINT: u32 = 0;
pub const FAIL_TRACE: u32 = 1;
pub const ACCUMULATE_SELF_HEAL_TIMER: u32 = 1;
pub const USE_SPEC_COMPLIANT_PROOFS: u32 = 1;
pub const SKIP_PROOF_ERRORS: u32 = 0;
pub const USE_BIT_FIELD_STRUCTURES: u32 = 0;
pub const CERTIFYX509_DEBUG: u32 = 1;
pub const TABLE_DRIVEN_MARSHAL: u32 = 0;
pub const ALG_YES: u32 = 1;
pub const ALG_NO: u32 = 0;
pub const CC_YES: u32 = 1;
pub const CC_NO: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const SET: u32 = 1;
pub const CLEAR: u32 = 0;
pub const BIG_ENDIAN_TPM: u32 = 0;
pub const MOST_SIGNIFICANT_BIT_0: u32 = 0;
pub const AUTO_ALIGN: u32 = 0;
pub const ECC_NIST_P192: u32 = 0;
pub const ECC_NIST_P224: u32 = 0;
pub const ECC_NIST_P256: u32 = 1;
pub const ECC_NIST_P384: u32 = 1;
pub const ECC_NIST_P521: u32 = 0;
pub const ECC_BN_P256: u32 = 1;
pub const ECC_BN_P638: u32 = 0;
pub const ECC_SM2_P256: u32 = 1;
pub const RH_ACT_0: u32 = 1;
pub const RH_ACT_1: u32 = 0;
pub const RH_ACT_A: u32 = 1;
pub const FIELD_UPGRADE_IMPLEMENTED: u32 = 0;
pub const IMPLEMENTATION_PCR: u32 = 24;
pub const PLATFORM_PCR: u32 = 24;
pub const DRTM_PCR: u32 = 17;
pub const HCRTM_PCR: u32 = 0;
pub const NUM_LOCALITIES: u32 = 5;
pub const MAX_HANDLE_NUM: u32 = 3;
pub const MAX_ACTIVE_SESSIONS: u32 = 64;
pub const MAX_LOADED_SESSIONS: u32 = 3;
pub const MAX_SESSION_NUM: u32 = 3;
pub const MAX_LOADED_OBJECTS: u32 = 3;
pub const MIN_EVICT_OBJECTS: u32 = 2;
pub const NUM_POLICY_PCR_GROUP: u32 = 1;
pub const NUM_AUTHVALUE_PCR_GROUP: u32 = 1;
pub const MAX_CONTEXT_SIZE: u32 = 1344;
pub const MAX_DIGEST_BUFFER: u32 = 1024;
pub const MAX_NV_INDEX_SIZE: u32 = 2048;
pub const MAX_NV_BUFFER_SIZE: u32 = 1024;
pub const MAX_CAP_BUFFER: u32 = 1024;
pub const NV_MEMORY_SIZE: u32 = 16384;
pub const MIN_COUNTER_INDICES: u32 = 8;
pub const NUM_STATIC_PCR: u32 = 16;
pub const MAX_ALG_LIST_SIZE: u32 = 64;
pub const PRIMARY_SEED_SIZE: u32 = 32;
pub const NV_CLOCK_UPDATE_INTERVAL: u32 = 12;
pub const NUM_POLICY_PCR: u32 = 1;
pub const MAX_COMMAND_SIZE: u32 = 4096;
pub const MAX_RESPONSE_SIZE: u32 = 4096;
pub const ORDERLY_BITS: u32 = 8;
pub const MAX_SYM_DATA: u32 = 128;
pub const MAX_RNG_ENTROPY_SIZE: u32 = 64;
pub const RAM_INDEX_SPACE: u32 = 512;
pub const RSA_DEFAULT_PUBLIC_EXPONENT: u32 = 65537;
pub const ENABLE_PCR_NO_INCREMENT: u32 = 1;
pub const CRT_FORMAT_RSA: u32 = 1;
pub const VENDOR_COMMAND_COUNT: u32 = 0;
pub const MAX_VENDOR_BUFFER_SIZE: u32 = 1024;
pub const SIZE_OF_X509_SERIAL_NUMBER: u32 = 20;
pub const ALG_AES: u32 = 1;
pub const ALG_CAMELLIA: u32 = 1;
pub const ALG_CBC: u32 = 1;
pub const ALG_CFB: u32 = 1;
pub const ALG_CMAC: u32 = 1;
pub const ALG_CTR: u32 = 1;
pub const ALG_ECB: u32 = 1;
pub const ALG_ECC: u32 = 1;
pub const ALG_HMAC: u32 = 1;
pub const ALG_KDF1_SP800_108: u32 = 1;
pub const ALG_KDF2: u32 = 1;
pub const ALG_KEYEDHASH: u32 = 1;
pub const ALG_MGF1: u32 = 1;
pub const ALG_OFB: u32 = 1;
pub const ALG_RSA: u32 = 1;
pub const ALG_SHA: u32 = 0;
pub const ALG_SHA1: u32 = 1;
pub const ALG_SHA256: u32 = 1;
pub const ALG_SHA384: u32 = 1;
pub const ALG_SHA3_256: u32 = 0;
pub const ALG_SHA3_384: u32 = 0;
pub const ALG_SHA3_512: u32 = 0;
pub const ALG_SHA512: u32 = 0;
pub const ALG_SM3_256: u32 = 0;
pub const ALG_SM4: u32 = 0;
pub const ALG_SYMCIPHER: u32 = 1;
pub const ALG_TDES: u32 = 0;
pub const ALG_XOR: u32 = 1;
pub const CC_ACT_SetTimeout: u32 = 1;
pub const CC_AC_GetCapability: u32 = 1;
pub const CC_AC_Send: u32 = 1;
pub const CC_ActivateCredential: u32 = 1;
pub const CC_Certify: u32 = 1;
pub const CC_CertifyCreation: u32 = 1;
pub const CC_CertifyX509: u32 = 1;
pub const CC_ChangeEPS: u32 = 1;
pub const CC_ChangePPS: u32 = 1;
pub const CC_Clear: u32 = 1;
pub const CC_ClearControl: u32 = 1;
pub const CC_ClockRateAdjust: u32 = 1;
pub const CC_ClockSet: u32 = 1;
pub const CC_ContextLoad: u32 = 1;
pub const CC_ContextSave: u32 = 1;
pub const CC_Create: u32 = 1;
pub const CC_CreateLoaded: u32 = 1;
pub const CC_CreatePrimary: u32 = 1;
pub const CC_DictionaryAttackLockReset: u32 = 1;
pub const CC_DictionaryAttackParameters: u32 = 1;
pub const CC_Duplicate: u32 = 1;
pub const CC_EncryptDecrypt: u32 = 1;
pub const CC_EncryptDecrypt2: u32 = 1;
pub const CC_EventSequenceComplete: u32 = 1;
pub const CC_EvictControl: u32 = 1;
pub const CC_FieldUpgradeData: u32 = 0;
pub const CC_FieldUpgradeStart: u32 = 0;
pub const CC_FirmwareRead: u32 = 0;
pub const CC_FlushContext: u32 = 1;
pub const CC_GetCapability: u32 = 1;
pub const CC_GetCommandAuditDigest: u32 = 1;
pub const CC_GetRandom: u32 = 1;
pub const CC_GetSessionAuditDigest: u32 = 1;
pub const CC_GetTestResult: u32 = 1;
pub const CC_GetTime: u32 = 1;
pub const CC_Hash: u32 = 1;
pub const CC_HashSequenceStart: u32 = 1;
pub const CC_HierarchyChangeAuth: u32 = 1;
pub const CC_HierarchyControl: u32 = 1;
pub const CC_Import: u32 = 1;
pub const CC_IncrementalSelfTest: u32 = 1;
pub const CC_Load: u32 = 1;
pub const CC_LoadExternal: u32 = 1;
pub const CC_MakeCredential: u32 = 1;
pub const CC_NV_Certify: u32 = 1;
pub const CC_NV_ChangeAuth: u32 = 1;
pub const CC_NV_DefineSpace: u32 = 1;
pub const CC_NV_Extend: u32 = 1;
pub const CC_NV_GlobalWriteLock: u32 = 1;
pub const CC_NV_Increment: u32 = 1;
pub const CC_NV_Read: u32 = 1;
pub const CC_NV_ReadLock: u32 = 1;
pub const CC_NV_ReadPublic: u32 = 1;
pub const CC_NV_SetBits: u32 = 1;
pub const CC_NV_UndefineSpace: u32 = 1;
pub const CC_NV_UndefineSpaceSpecial: u32 = 1;
pub const CC_NV_Write: u32 = 1;
pub const CC_NV_WriteLock: u32 = 1;
pub const CC_ObjectChangeAuth: u32 = 1;
pub const CC_PCR_Allocate: u32 = 1;
pub const CC_PCR_Event: u32 = 1;
pub const CC_PCR_Extend: u32 = 1;
pub const CC_PCR_Read: u32 = 1;
pub const CC_PCR_Reset: u32 = 1;
pub const CC_PCR_SetAuthPolicy: u32 = 1;
pub const CC_PCR_SetAuthValue: u32 = 1;
pub const CC_PP_Commands: u32 = 1;
pub const CC_PolicyAuthValue: u32 = 1;
pub const CC_PolicyAuthorize: u32 = 1;
pub const CC_PolicyAuthorizeNV: u32 = 1;
pub const CC_PolicyCommandCode: u32 = 1;
pub const CC_PolicyCounterTimer: u32 = 1;
pub const CC_PolicyCpHash: u32 = 1;
pub const CC_PolicyDuplicationSelect: u32 = 1;
pub const CC_PolicyGetDigest: u32 = 1;
pub const CC_PolicyLocality: u32 = 1;
pub const CC_PolicyNV: u32 = 1;
pub const CC_PolicyNameHash: u32 = 1;
pub const CC_PolicyNvWritten: u32 = 1;
pub const CC_PolicyOR: u32 = 1;
pub const CC_PolicyPCR: u32 = 1;
pub const CC_PolicyPassword: u32 = 1;
pub const CC_PolicyPhysicalPresence: u32 = 1;
pub const CC_PolicyRestart: u32 = 1;
pub const CC_PolicySecret: u32 = 1;
pub const CC_PolicySigned: u32 = 1;
pub const CC_PolicyTemplate: u32 = 1;
pub const CC_PolicyTicket: u32 = 1;
pub const CC_Policy_AC_SendSelect: u32 = 1;
pub const CC_Quote: u32 = 1;
pub const CC_ReadClock: u32 = 1;
pub const CC_ReadPublic: u32 = 1;
pub const CC_Rewrap: u32 = 1;
pub const CC_SelfTest: u32 = 1;
pub const CC_SequenceComplete: u32 = 1;
pub const CC_SequenceUpdate: u32 = 1;
pub const CC_SetAlgorithmSet: u32 = 1;
pub const CC_SetCommandCodeAuditStatus: u32 = 1;
pub const CC_SetPrimaryPolicy: u32 = 1;
pub const CC_Shutdown: u32 = 1;
pub const CC_Sign: u32 = 1;
pub const CC_StartAuthSession: u32 = 1;
pub const CC_Startup: u32 = 1;
pub const CC_StirRandom: u32 = 1;
pub const CC_TestParms: u32 = 1;
pub const CC_Unseal: u32 = 1;
pub const CC_Vendor_TCG_Test: u32 = 1;
pub const CC_VerifySignature: u32 = 1;
pub const NULL: u32 = 0;
pub const ECC_CURVE_COUNT: u32 = 4;
pub const RSA_MAX_KEY_SIZE_BITS: u32 = 2048;
pub const MAX_RSA_KEY_BITS: u32 = 2048;
pub const MAX_RSA_KEY_BYTES: u32 = 256;
pub const SHA1_DIGEST_SIZE: u32 = 20;
pub const SHA1_BLOCK_SIZE: u32 = 64;
pub const SHA256_DIGEST_SIZE: u32 = 32;
pub const SHA256_BLOCK_SIZE: u32 = 64;
pub const SHA384_DIGEST_SIZE: u32 = 48;
pub const SHA384_BLOCK_SIZE: u32 = 128;
pub const SHA512_DIGEST_SIZE: u32 = 64;
pub const SHA512_BLOCK_SIZE: u32 = 128;
pub const SM3_256_DIGEST_SIZE: u32 = 32;
pub const SM3_256_BLOCK_SIZE: u32 = 64;
pub const SHA3_256_DIGEST_SIZE: u32 = 32;
pub const SHA3_256_BLOCK_SIZE: u32 = 136;
pub const SHA3_384_DIGEST_SIZE: u32 = 48;
pub const SHA3_384_BLOCK_SIZE: u32 = 104;
pub const SHA3_512_DIGEST_SIZE: u32 = 64;
pub const SHA3_512_BLOCK_SIZE: u32 = 72;
pub const AES_MAX_KEY_SIZE_BITS: u32 = 256;
pub const MAX_AES_KEY_BITS: u32 = 256;
pub const MAX_AES_KEY_BYTES: u32 = 32;
pub const AES_MAX_BLOCK_SIZE: u32 = 16;
pub const MAX_AES_BLOCK_SIZE_BYTES: u32 = 16;
pub const SM4_MAX_KEY_SIZE_BITS: u32 = 0;
pub const MAX_SM4_KEY_BITS: u32 = 0;
pub const MAX_SM4_KEY_BYTES: u32 = 0;
pub const SM4_MAX_BLOCK_SIZE: u32 = 0;
pub const MAX_SM4_BLOCK_SIZE_BYTES: u32 = 0;
pub const CAMELLIA_MAX_KEY_SIZE_BITS: u32 = 256;
pub const MAX_CAMELLIA_KEY_BITS: u32 = 256;
pub const MAX_CAMELLIA_KEY_BYTES: u32 = 32;
pub const CAMELLIA_MAX_BLOCK_SIZE: u32 = 16;
pub const MAX_CAMELLIA_BLOCK_SIZE_BYTES: u32 = 16;
pub const TDES_MAX_KEY_SIZE_BITS: u32 = 0;
pub const MAX_TDES_KEY_BITS: u32 = 0;
pub const MAX_TDES_KEY_BYTES: u32 = 0;
pub const TDES_MAX_BLOCK_SIZE: u32 = 0;
pub const MAX_TDES_BLOCK_SIZE_BYTES: u32 = 0;
pub const TPM_CC_FIRST: u32 = 287;
pub const TPM_CC_LAST: u32 = 410;
pub const ADD_FILL: u32 = 0;
pub const VENDOR_COMMAND_ARRAY_SIZE: u32 = 1;
pub const HASH_COUNT: u32 = 3;
pub const RADIX_BITS: u32 = 64;
pub const OPENSSL_VERSION_NUMBER: u32 = 269488143;
pub const OPENSSL_VERSION_TEXT: &[u8; 27usize] = b"OpenSSL 1.1.1  11 Sep 2018\0";
pub const SHLIB_VERSION_HISTORY: &[u8; 1usize] = b"\0";
pub const SHLIB_VERSION_NUMBER: &[u8; 4usize] = b"1.1\0";
pub const OPENSSL_MIN_API: u32 = 0;
pub const OPENSSL_API_COMPAT: u32 = 0;
pub const AES_ENCRYPT: u32 = 1;
pub const AES_DECRYPT: u32 = 0;
pub const AES_MAXNR: u32 = 14;
pub const AES_BLOCK_SIZE: u32 = 16;
pub const CAMELLIA_ENCRYPT: u32 = 1;
pub const CAMELLIA_DECRYPT: u32 = 0;
pub const CAMELLIA_BLOCK_SIZE: u32 = 16;
pub const CAMELLIA_TABLE_BYTE_LEN: u32 = 272;
pub const CAMELLIA_TABLE_WORD_LEN: u32 = 68;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const _STDIO_H: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const CRYPTO_F_CMAC_CTX_NEW: u32 = 120;
pub const CRYPTO_F_CRYPTO_DUP_EX_DATA: u32 = 110;
pub const CRYPTO_F_CRYPTO_FREE_EX_DATA: u32 = 111;
pub const CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX: u32 = 100;
pub const CRYPTO_F_CRYPTO_MEMDUP: u32 = 115;
pub const CRYPTO_F_CRYPTO_NEW_EX_DATA: u32 = 112;
pub const CRYPTO_F_CRYPTO_OCB128_COPY_CTX: u32 = 121;
pub const CRYPTO_F_CRYPTO_OCB128_INIT: u32 = 122;
pub const CRYPTO_F_CRYPTO_SET_EX_DATA: u32 = 102;
pub const CRYPTO_F_FIPS_MODE_SET: u32 = 109;
pub const CRYPTO_F_GET_AND_LOCK: u32 = 113;
pub const CRYPTO_F_OPENSSL_ATEXIT: u32 = 114;
pub const CRYPTO_F_OPENSSL_BUF2HEXSTR: u32 = 117;
pub const CRYPTO_F_OPENSSL_FOPEN: u32 = 119;
pub const CRYPTO_F_OPENSSL_HEXSTR2BUF: u32 = 118;
pub const CRYPTO_F_OPENSSL_INIT_CRYPTO: u32 = 116;
pub const CRYPTO_F_OPENSSL_LH_NEW: u32 = 126;
pub const CRYPTO_F_OPENSSL_SK_DEEP_COPY: u32 = 127;
pub const CRYPTO_F_OPENSSL_SK_DUP: u32 = 128;
pub const CRYPTO_F_PKEY_HMAC_INIT: u32 = 123;
pub const CRYPTO_F_PKEY_POLY1305_INIT: u32 = 124;
pub const CRYPTO_F_PKEY_SIPHASH_INIT: u32 = 125;
pub const CRYPTO_F_SK_RESERVE: u32 = 129;
pub const CRYPTO_R_FIPS_MODE_NOT_SUPPORTED: u32 = 101;
pub const CRYPTO_R_ILLEGAL_HEX_DIGIT: u32 = 102;
pub const CRYPTO_R_ODD_NUMBER_OF_DIGITS: u32 = 103;
pub const SSLEAY_VERSION_NUMBER: u32 = 269488143;
pub const CRYPTO_MEM_CHECK_OFF: u32 = 0;
pub const CRYPTO_MEM_CHECK_ON: u32 = 1;
pub const CRYPTO_MEM_CHECK_ENABLE: u32 = 2;
pub const CRYPTO_MEM_CHECK_DISABLE: u32 = 3;
pub const CRYPTO_EX_INDEX_SSL: u32 = 0;
pub const CRYPTO_EX_INDEX_SSL_CTX: u32 = 1;
pub const CRYPTO_EX_INDEX_SSL_SESSION: u32 = 2;
pub const CRYPTO_EX_INDEX_X509: u32 = 3;
pub const CRYPTO_EX_INDEX_X509_STORE: u32 = 4;
pub const CRYPTO_EX_INDEX_X509_STORE_CTX: u32 = 5;
pub const CRYPTO_EX_INDEX_DH: u32 = 6;
pub const CRYPTO_EX_INDEX_DSA: u32 = 7;
pub const CRYPTO_EX_INDEX_EC_KEY: u32 = 8;
pub const CRYPTO_EX_INDEX_RSA: u32 = 9;
pub const CRYPTO_EX_INDEX_ENGINE: u32 = 10;
pub const CRYPTO_EX_INDEX_UI: u32 = 11;
pub const CRYPTO_EX_INDEX_BIO: u32 = 12;
pub const CRYPTO_EX_INDEX_APP: u32 = 13;
pub const CRYPTO_EX_INDEX_UI_METHOD: u32 = 14;
pub const CRYPTO_EX_INDEX_DRBG: u32 = 15;
pub const CRYPTO_EX_INDEX__COUNT: u32 = 16;
pub const OPENSSL_VERSION: u32 = 0;
pub const OPENSSL_CFLAGS: u32 = 1;
pub const OPENSSL_BUILT_ON: u32 = 2;
pub const OPENSSL_PLATFORM: u32 = 3;
pub const OPENSSL_DIR: u32 = 4;
pub const OPENSSL_ENGINES_DIR: u32 = 5;
pub const CRYPTO_LOCK: u32 = 1;
pub const CRYPTO_UNLOCK: u32 = 2;
pub const CRYPTO_READ: u32 = 4;
pub const CRYPTO_WRITE: u32 = 8;
pub const OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS: u32 = 1;
pub const OPENSSL_INIT_LOAD_CRYPTO_STRINGS: u32 = 2;
pub const OPENSSL_INIT_ADD_ALL_CIPHERS: u32 = 4;
pub const OPENSSL_INIT_ADD_ALL_DIGESTS: u32 = 8;
pub const OPENSSL_INIT_NO_ADD_ALL_CIPHERS: u32 = 16;
pub const OPENSSL_INIT_NO_ADD_ALL_DIGESTS: u32 = 32;
pub const OPENSSL_INIT_LOAD_CONFIG: u32 = 64;
pub const OPENSSL_INIT_NO_LOAD_CONFIG: u32 = 128;
pub const OPENSSL_INIT_ASYNC: u32 = 256;
pub const OPENSSL_INIT_ENGINE_RDRAND: u32 = 512;
pub const OPENSSL_INIT_ENGINE_DYNAMIC: u32 = 1024;
pub const OPENSSL_INIT_ENGINE_OPENSSL: u32 = 2048;
pub const OPENSSL_INIT_ENGINE_CRYPTODEV: u32 = 4096;
pub const OPENSSL_INIT_ENGINE_CAPI: u32 = 8192;
pub const OPENSSL_INIT_ENGINE_PADLOCK: u32 = 16384;
pub const OPENSSL_INIT_ENGINE_AFALG: u32 = 32768;
pub const OPENSSL_INIT_ATFORK: u32 = 131072;
pub const OPENSSL_INIT_ENGINE_ALL_BUILTIN: u32 = 30208;
pub const _PTHREAD_H: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const CRYPTO_ONCE_STATIC_INIT: u32 = 0;
pub const BN_F_BNRAND: u32 = 127;
pub const BN_F_BNRAND_RANGE: u32 = 138;
pub const BN_F_BN_BLINDING_CONVERT_EX: u32 = 100;
pub const BN_F_BN_BLINDING_CREATE_PARAM: u32 = 128;
pub const BN_F_BN_BLINDING_INVERT_EX: u32 = 101;
pub const BN_F_BN_BLINDING_NEW: u32 = 102;
pub const BN_F_BN_BLINDING_UPDATE: u32 = 103;
pub const BN_F_BN_BN2DEC: u32 = 104;
pub const BN_F_BN_BN2HEX: u32 = 105;
pub const BN_F_BN_COMPUTE_WNAF: u32 = 142;
pub const BN_F_BN_CTX_GET: u32 = 116;
pub const BN_F_BN_CTX_NEW: u32 = 106;
pub const BN_F_BN_CTX_START: u32 = 129;
pub const BN_F_BN_DIV: u32 = 107;
pub const BN_F_BN_DIV_RECP: u32 = 130;
pub const BN_F_BN_EXP: u32 = 123;
pub const BN_F_BN_EXPAND_INTERNAL: u32 = 120;
pub const BN_F_BN_GENCB_NEW: u32 = 143;
pub const BN_F_BN_GENERATE_DSA_NONCE: u32 = 140;
pub const BN_F_BN_GENERATE_PRIME_EX: u32 = 141;
pub const BN_F_BN_GF2M_MOD: u32 = 131;
pub const BN_F_BN_GF2M_MOD_EXP: u32 = 132;
pub const BN_F_BN_GF2M_MOD_MUL: u32 = 133;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD: u32 = 134;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR: u32 = 135;
pub const BN_F_BN_GF2M_MOD_SQR: u32 = 136;
pub const BN_F_BN_GF2M_MOD_SQRT: u32 = 137;
pub const BN_F_BN_LSHIFT: u32 = 145;
pub const BN_F_BN_MOD_EXP2_MONT: u32 = 118;
pub const BN_F_BN_MOD_EXP_MONT: u32 = 109;
pub const BN_F_BN_MOD_EXP_MONT_CONSTTIME: u32 = 124;
pub const BN_F_BN_MOD_EXP_MONT_WORD: u32 = 117;
pub const BN_F_BN_MOD_EXP_RECP: u32 = 125;
pub const BN_F_BN_MOD_EXP_SIMPLE: u32 = 126;
pub const BN_F_BN_MOD_INVERSE: u32 = 110;
pub const BN_F_BN_MOD_INVERSE_NO_BRANCH: u32 = 139;
pub const BN_F_BN_MOD_LSHIFT_QUICK: u32 = 119;
pub const BN_F_BN_MOD_SQRT: u32 = 121;
pub const BN_F_BN_MONT_CTX_NEW: u32 = 149;
pub const BN_F_BN_MPI2BN: u32 = 112;
pub const BN_F_BN_NEW: u32 = 113;
pub const BN_F_BN_POOL_GET: u32 = 147;
pub const BN_F_BN_RAND: u32 = 114;
pub const BN_F_BN_RAND_RANGE: u32 = 122;
pub const BN_F_BN_RECP_CTX_NEW: u32 = 150;
pub const BN_F_BN_RSHIFT: u32 = 146;
pub const BN_F_BN_SET_WORDS: u32 = 144;
pub const BN_F_BN_STACK_PUSH: u32 = 148;
pub const BN_F_BN_USUB: u32 = 115;
pub const BN_R_ARG2_LT_ARG3: u32 = 100;
pub const BN_R_BAD_RECIPROCAL: u32 = 101;
pub const BN_R_BIGNUM_TOO_LONG: u32 = 114;
pub const BN_R_BITS_TOO_SMALL: u32 = 118;
pub const BN_R_CALLED_WITH_EVEN_MODULUS: u32 = 102;
pub const BN_R_DIV_BY_ZERO: u32 = 103;
pub const BN_R_ENCODING_ERROR: u32 = 104;
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA: u32 = 105;
pub const BN_R_INPUT_NOT_REDUCED: u32 = 110;
pub const BN_R_INVALID_LENGTH: u32 = 106;
pub const BN_R_INVALID_RANGE: u32 = 115;
pub const BN_R_INVALID_SHIFT: u32 = 119;
pub const BN_R_NOT_A_SQUARE: u32 = 111;
pub const BN_R_NOT_INITIALIZED: u32 = 107;
pub const BN_R_NO_INVERSE: u32 = 108;
pub const BN_R_NO_SOLUTION: u32 = 116;
pub const BN_R_PRIVATE_KEY_TOO_LARGE: u32 = 117;
pub const BN_R_P_IS_NOT_PRIME: u32 = 112;
pub const BN_R_TOO_MANY_ITERATIONS: u32 = 113;
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES: u32 = 109;
pub const BN_BYTES: u32 = 8;
pub const BN_BITS2: u32 = 64;
pub const BN_BITS: u32 = 128;
pub const BN_FLG_MALLOCED: u32 = 1;
pub const BN_FLG_STATIC_DATA: u32 = 2;
pub const BN_FLG_CONSTTIME: u32 = 4;
pub const BN_FLG_SECURE: u32 = 8;
pub const BN_FLG_EXP_CONSTTIME: u32 = 4;
pub const BN_FLG_FREE: u32 = 32768;
pub const BN_RAND_TOP_ANY: i32 = -1;
pub const BN_RAND_TOP_ONE: u32 = 0;
pub const BN_RAND_TOP_TWO: u32 = 1;
pub const BN_RAND_BOTTOM_ANY: u32 = 0;
pub const BN_RAND_BOTTOM_ODD: u32 = 1;
pub const BN_prime_checks: u32 = 0;
pub const BN_BLINDING_NO_UPDATE: u32 = 1;
pub const BN_BLINDING_NO_RECREATE: u32 = 2;
pub const BIO_F_ACPT_STATE: u32 = 100;
pub const BIO_F_ADDRINFO_WRAP: u32 = 148;
pub const BIO_F_ADDR_STRINGS: u32 = 134;
pub const BIO_F_BIO_ACCEPT: u32 = 101;
pub const BIO_F_BIO_ACCEPT_EX: u32 = 137;
pub const BIO_F_BIO_ACCEPT_NEW: u32 = 152;
pub const BIO_F_BIO_ADDR_NEW: u32 = 144;
pub const BIO_F_BIO_BIND: u32 = 147;
pub const BIO_F_BIO_CALLBACK_CTRL: u32 = 131;
pub const BIO_F_BIO_CONNECT: u32 = 138;
pub const BIO_F_BIO_CONNECT_NEW: u32 = 153;
pub const BIO_F_BIO_CTRL: u32 = 103;
pub const BIO_F_BIO_GETS: u32 = 104;
pub const BIO_F_BIO_GET_HOST_IP: u32 = 106;
pub const BIO_F_BIO_GET_NEW_INDEX: u32 = 102;
pub const BIO_F_BIO_GET_PORT: u32 = 107;
pub const BIO_F_BIO_LISTEN: u32 = 139;
pub const BIO_F_BIO_LOOKUP: u32 = 135;
pub const BIO_F_BIO_LOOKUP_EX: u32 = 143;
pub const BIO_F_BIO_MAKE_PAIR: u32 = 121;
pub const BIO_F_BIO_METH_NEW: u32 = 146;
pub const BIO_F_BIO_NEW: u32 = 108;
pub const BIO_F_BIO_NEW_DGRAM_SCTP: u32 = 145;
pub const BIO_F_BIO_NEW_FILE: u32 = 109;
pub const BIO_F_BIO_NEW_MEM_BUF: u32 = 126;
pub const BIO_F_BIO_NREAD: u32 = 123;
pub const BIO_F_BIO_NREAD0: u32 = 124;
pub const BIO_F_BIO_NWRITE: u32 = 125;
pub const BIO_F_BIO_NWRITE0: u32 = 122;
pub const BIO_F_BIO_PARSE_HOSTSERV: u32 = 136;
pub const BIO_F_BIO_PUTS: u32 = 110;
pub const BIO_F_BIO_READ: u32 = 111;
pub const BIO_F_BIO_READ_EX: u32 = 105;
pub const BIO_F_BIO_READ_INTERN: u32 = 120;
pub const BIO_F_BIO_SOCKET: u32 = 140;
pub const BIO_F_BIO_SOCKET_NBIO: u32 = 142;
pub const BIO_F_BIO_SOCK_INFO: u32 = 141;
pub const BIO_F_BIO_SOCK_INIT: u32 = 112;
pub const BIO_F_BIO_WRITE: u32 = 113;
pub const BIO_F_BIO_WRITE_EX: u32 = 119;
pub const BIO_F_BIO_WRITE_INTERN: u32 = 128;
pub const BIO_F_BUFFER_CTRL: u32 = 114;
pub const BIO_F_CONN_CTRL: u32 = 127;
pub const BIO_F_CONN_STATE: u32 = 115;
pub const BIO_F_DGRAM_SCTP_NEW: u32 = 149;
pub const BIO_F_DGRAM_SCTP_READ: u32 = 132;
pub const BIO_F_DGRAM_SCTP_WRITE: u32 = 133;
pub const BIO_F_DOAPR_OUTCH: u32 = 150;
pub const BIO_F_FILE_CTRL: u32 = 116;
pub const BIO_F_FILE_READ: u32 = 130;
pub const BIO_F_LINEBUFFER_CTRL: u32 = 129;
pub const BIO_F_LINEBUFFER_NEW: u32 = 151;
pub const BIO_F_MEM_WRITE: u32 = 117;
pub const BIO_F_NBIOF_NEW: u32 = 154;
pub const BIO_F_SLG_WRITE: u32 = 155;
pub const BIO_F_SSL_NEW: u32 = 118;
pub const BIO_R_ACCEPT_ERROR: u32 = 100;
pub const BIO_R_ADDRINFO_ADDR_IS_NOT_AF_INET: u32 = 141;
pub const BIO_R_AMBIGUOUS_HOST_OR_SERVICE: u32 = 129;
pub const BIO_R_BAD_FOPEN_MODE: u32 = 101;
pub const BIO_R_BROKEN_PIPE: u32 = 124;
pub const BIO_R_CONNECT_ERROR: u32 = 103;
pub const BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET: u32 = 107;
pub const BIO_R_GETSOCKNAME_ERROR: u32 = 132;
pub const BIO_R_GETSOCKNAME_TRUNCATED_ADDRESS: u32 = 133;
pub const BIO_R_GETTING_SOCKTYPE: u32 = 134;
pub const BIO_R_INVALID_ARGUMENT: u32 = 125;
pub const BIO_R_INVALID_SOCKET: u32 = 135;
pub const BIO_R_IN_USE: u32 = 123;
pub const BIO_R_LENGTH_TOO_LONG: u32 = 102;
pub const BIO_R_LISTEN_V6_ONLY: u32 = 136;
pub const BIO_R_LOOKUP_RETURNED_NOTHING: u32 = 142;
pub const BIO_R_MALFORMED_HOST_OR_SERVICE: u32 = 130;
pub const BIO_R_NBIO_CONNECT_ERROR: u32 = 110;
pub const BIO_R_NO_ACCEPT_ADDR_OR_SERVICE_SPECIFIED: u32 = 143;
pub const BIO_R_NO_HOSTNAME_OR_SERVICE_SPECIFIED: u32 = 144;
pub const BIO_R_NO_PORT_DEFINED: u32 = 113;
pub const BIO_R_NO_SUCH_FILE: u32 = 128;
pub const BIO_R_NULL_PARAMETER: u32 = 115;
pub const BIO_R_UNABLE_TO_BIND_SOCKET: u32 = 117;
pub const BIO_R_UNABLE_TO_CREATE_SOCKET: u32 = 118;
pub const BIO_R_UNABLE_TO_KEEPALIVE: u32 = 137;
pub const BIO_R_UNABLE_TO_LISTEN_SOCKET: u32 = 119;
pub const BIO_R_UNABLE_TO_NODELAY: u32 = 138;
pub const BIO_R_UNABLE_TO_REUSEADDR: u32 = 139;
pub const BIO_R_UNAVAILABLE_IP_FAMILY: u32 = 145;
pub const BIO_R_UNINITIALIZED: u32 = 120;
pub const BIO_R_UNKNOWN_INFO_TYPE: u32 = 140;
pub const BIO_R_UNSUPPORTED_IP_FAMILY: u32 = 146;
pub const BIO_R_UNSUPPORTED_METHOD: u32 = 121;
pub const BIO_R_UNSUPPORTED_PROTOCOL_FAMILY: u32 = 131;
pub const BIO_R_WRITE_TO_READ_ONLY_BIO: u32 = 126;
pub const BIO_R_WSASTARTUP: u32 = 122;
pub const BIO_TYPE_DESCRIPTOR: u32 = 256;
pub const BIO_TYPE_FILTER: u32 = 512;
pub const BIO_TYPE_SOURCE_SINK: u32 = 1024;
pub const BIO_TYPE_NONE: u32 = 0;
pub const BIO_TYPE_MEM: u32 = 1025;
pub const BIO_TYPE_FILE: u32 = 1026;
pub const BIO_TYPE_FD: u32 = 1284;
pub const BIO_TYPE_SOCKET: u32 = 1285;
pub const BIO_TYPE_NULL: u32 = 1030;
pub const BIO_TYPE_SSL: u32 = 519;
pub const BIO_TYPE_MD: u32 = 520;
pub const BIO_TYPE_BUFFER: u32 = 521;
pub const BIO_TYPE_CIPHER: u32 = 522;
pub const BIO_TYPE_BASE64: u32 = 523;
pub const BIO_TYPE_CONNECT: u32 = 1292;
pub const BIO_TYPE_ACCEPT: u32 = 1293;
pub const BIO_TYPE_NBIO_TEST: u32 = 528;
pub const BIO_TYPE_NULL_FILTER: u32 = 529;
pub const BIO_TYPE_BIO: u32 = 1043;
pub const BIO_TYPE_LINEBUFFER: u32 = 532;
pub const BIO_TYPE_DGRAM: u32 = 1301;
pub const BIO_TYPE_ASN1: u32 = 534;
pub const BIO_TYPE_COMP: u32 = 535;
pub const BIO_TYPE_START: u32 = 128;
pub const BIO_NOCLOSE: u32 = 0;
pub const BIO_CLOSE: u32 = 1;
pub const BIO_CTRL_RESET: u32 = 1;
pub const BIO_CTRL_EOF: u32 = 2;
pub const BIO_CTRL_INFO: u32 = 3;
pub const BIO_CTRL_SET: u32 = 4;
pub const BIO_CTRL_GET: u32 = 5;
pub const BIO_CTRL_PUSH: u32 = 6;
pub const BIO_CTRL_POP: u32 = 7;
pub const BIO_CTRL_GET_CLOSE: u32 = 8;
pub const BIO_CTRL_SET_CLOSE: u32 = 9;
pub const BIO_CTRL_PENDING: u32 = 10;
pub const BIO_CTRL_FLUSH: u32 = 11;
pub const BIO_CTRL_DUP: u32 = 12;
pub const BIO_CTRL_WPENDING: u32 = 13;
pub const BIO_CTRL_SET_CALLBACK: u32 = 14;
pub const BIO_CTRL_GET_CALLBACK: u32 = 15;
pub const BIO_CTRL_PEEK: u32 = 29;
pub const BIO_CTRL_SET_FILENAME: u32 = 30;
pub const BIO_CTRL_DGRAM_CONNECT: u32 = 31;
pub const BIO_CTRL_DGRAM_SET_CONNECTED: u32 = 32;
pub const BIO_CTRL_DGRAM_SET_RECV_TIMEOUT: u32 = 33;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMEOUT: u32 = 34;
pub const BIO_CTRL_DGRAM_SET_SEND_TIMEOUT: u32 = 35;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMEOUT: u32 = 36;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP: u32 = 37;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP: u32 = 38;
pub const BIO_CTRL_DGRAM_MTU_DISCOVER: u32 = 39;
pub const BIO_CTRL_DGRAM_QUERY_MTU: u32 = 40;
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU: u32 = 47;
pub const BIO_CTRL_DGRAM_GET_MTU: u32 = 41;
pub const BIO_CTRL_DGRAM_SET_MTU: u32 = 42;
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED: u32 = 43;
pub const BIO_CTRL_DGRAM_GET_PEER: u32 = 46;
pub const BIO_CTRL_DGRAM_SET_PEER: u32 = 44;
pub const BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT: u32 = 45;
pub const BIO_CTRL_DGRAM_SET_DONT_FRAG: u32 = 48;
pub const BIO_CTRL_DGRAM_GET_MTU_OVERHEAD: u32 = 49;
pub const BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE: u32 = 50;
pub const BIO_CTRL_DGRAM_SET_PEEK_MODE: u32 = 71;
pub const BIO_FP_READ: u32 = 2;
pub const BIO_FP_WRITE: u32 = 4;
pub const BIO_FP_APPEND: u32 = 8;
pub const BIO_FP_TEXT: u32 = 16;
pub const BIO_FLAGS_READ: u32 = 1;
pub const BIO_FLAGS_WRITE: u32 = 2;
pub const BIO_FLAGS_IO_SPECIAL: u32 = 4;
pub const BIO_FLAGS_RWS: u32 = 7;
pub const BIO_FLAGS_SHOULD_RETRY: u32 = 8;
pub const BIO_FLAGS_UPLINK: u32 = 0;
pub const BIO_FLAGS_BASE64_NO_NL: u32 = 256;
pub const BIO_FLAGS_MEM_RDONLY: u32 = 512;
pub const BIO_FLAGS_NONCLEAR_RST: u32 = 1024;
pub const BIO_RR_SSL_X509_LOOKUP: u32 = 1;
pub const BIO_RR_CONNECT: u32 = 2;
pub const BIO_RR_ACCEPT: u32 = 3;
pub const BIO_CB_FREE: u32 = 1;
pub const BIO_CB_READ: u32 = 2;
pub const BIO_CB_WRITE: u32 = 3;
pub const BIO_CB_PUTS: u32 = 4;
pub const BIO_CB_GETS: u32 = 5;
pub const BIO_CB_CTRL: u32 = 6;
pub const BIO_CB_RETURN: u32 = 128;
pub const BIO_C_SET_CONNECT: u32 = 100;
pub const BIO_C_DO_STATE_MACHINE: u32 = 101;
pub const BIO_C_SET_NBIO: u32 = 102;
pub const BIO_C_SET_FD: u32 = 104;
pub const BIO_C_GET_FD: u32 = 105;
pub const BIO_C_SET_FILE_PTR: u32 = 106;
pub const BIO_C_GET_FILE_PTR: u32 = 107;
pub const BIO_C_SET_FILENAME: u32 = 108;
pub const BIO_C_SET_SSL: u32 = 109;
pub const BIO_C_GET_SSL: u32 = 110;
pub const BIO_C_SET_MD: u32 = 111;
pub const BIO_C_GET_MD: u32 = 112;
pub const BIO_C_GET_CIPHER_STATUS: u32 = 113;
pub const BIO_C_SET_BUF_MEM: u32 = 114;
pub const BIO_C_GET_BUF_MEM_PTR: u32 = 115;
pub const BIO_C_GET_BUFF_NUM_LINES: u32 = 116;
pub const BIO_C_SET_BUFF_SIZE: u32 = 117;
pub const BIO_C_SET_ACCEPT: u32 = 118;
pub const BIO_C_SSL_MODE: u32 = 119;
pub const BIO_C_GET_MD_CTX: u32 = 120;
pub const BIO_C_SET_BUFF_READ_DATA: u32 = 122;
pub const BIO_C_GET_CONNECT: u32 = 123;
pub const BIO_C_GET_ACCEPT: u32 = 124;
pub const BIO_C_SET_SSL_RENEGOTIATE_BYTES: u32 = 125;
pub const BIO_C_GET_SSL_NUM_RENEGOTIATES: u32 = 126;
pub const BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT: u32 = 127;
pub const BIO_C_FILE_SEEK: u32 = 128;
pub const BIO_C_GET_CIPHER_CTX: u32 = 129;
pub const BIO_C_SET_BUF_MEM_EOF_RETURN: u32 = 130;
pub const BIO_C_SET_BIND_MODE: u32 = 131;
pub const BIO_C_GET_BIND_MODE: u32 = 132;
pub const BIO_C_FILE_TELL: u32 = 133;
pub const BIO_C_GET_SOCKS: u32 = 134;
pub const BIO_C_SET_SOCKS: u32 = 135;
pub const BIO_C_SET_WRITE_BUF_SIZE: u32 = 136;
pub const BIO_C_GET_WRITE_BUF_SIZE: u32 = 137;
pub const BIO_C_MAKE_BIO_PAIR: u32 = 138;
pub const BIO_C_DESTROY_BIO_PAIR: u32 = 139;
pub const BIO_C_GET_WRITE_GUARANTEE: u32 = 140;
pub const BIO_C_GET_READ_REQUEST: u32 = 141;
pub const BIO_C_SHUTDOWN_WR: u32 = 142;
pub const BIO_C_NREAD0: u32 = 143;
pub const BIO_C_NREAD: u32 = 144;
pub const BIO_C_NWRITE0: u32 = 145;
pub const BIO_C_NWRITE: u32 = 146;
pub const BIO_C_RESET_READ_REQUEST: u32 = 147;
pub const BIO_C_SET_MD_CTX: u32 = 148;
pub const BIO_C_SET_PREFIX: u32 = 149;
pub const BIO_C_GET_PREFIX: u32 = 150;
pub const BIO_C_SET_SUFFIX: u32 = 151;
pub const BIO_C_GET_SUFFIX: u32 = 152;
pub const BIO_C_SET_EX_ARG: u32 = 153;
pub const BIO_C_GET_EX_ARG: u32 = 154;
pub const BIO_C_SET_CONNECT_MODE: u32 = 155;
pub const BIO_FAMILY_IPV4: u32 = 4;
pub const BIO_FAMILY_IPV6: u32 = 6;
pub const BIO_FAMILY_IPANY: u32 = 256;
pub const BIO_BIND_NORMAL: u32 = 0;
pub const BIO_SOCK_REUSEADDR: u32 = 1;
pub const BIO_SOCK_V6_ONLY: u32 = 2;
pub const BIO_SOCK_KEEPALIVE: u32 = 4;
pub const BIO_SOCK_NONBLOCK: u32 = 8;
pub const BIO_SOCK_NODELAY: u32 = 16;
pub const EVP_F_AESNI_INIT_KEY: u32 = 165;
pub const EVP_F_AES_GCM_CTRL: u32 = 196;
pub const EVP_F_AES_INIT_KEY: u32 = 133;
pub const EVP_F_AES_OCB_CIPHER: u32 = 169;
pub const EVP_F_AES_T4_INIT_KEY: u32 = 178;
pub const EVP_F_AES_WRAP_CIPHER: u32 = 170;
pub const EVP_F_ALG_MODULE_INIT: u32 = 177;
pub const EVP_F_ARIA_CCM_INIT_KEY: u32 = 175;
pub const EVP_F_ARIA_GCM_CTRL: u32 = 197;
pub const EVP_F_ARIA_GCM_INIT_KEY: u32 = 176;
pub const EVP_F_ARIA_INIT_KEY: u32 = 185;
pub const EVP_F_B64_NEW: u32 = 198;
pub const EVP_F_CAMELLIA_INIT_KEY: u32 = 159;
pub const EVP_F_CHACHA20_POLY1305_CTRL: u32 = 182;
pub const EVP_F_CMLL_T4_INIT_KEY: u32 = 179;
pub const EVP_F_DES_EDE3_WRAP_CIPHER: u32 = 171;
pub const EVP_F_DO_SIGVER_INIT: u32 = 161;
pub const EVP_F_ENC_NEW: u32 = 199;
pub const EVP_F_EVP_CIPHERINIT_EX: u32 = 123;
pub const EVP_F_EVP_CIPHER_ASN1_TO_PARAM: u32 = 204;
pub const EVP_F_EVP_CIPHER_CTX_COPY: u32 = 163;
pub const EVP_F_EVP_CIPHER_CTX_CTRL: u32 = 124;
pub const EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH: u32 = 122;
pub const EVP_F_EVP_CIPHER_PARAM_TO_ASN1: u32 = 205;
pub const EVP_F_EVP_DECRYPTFINAL_EX: u32 = 101;
pub const EVP_F_EVP_DECRYPTUPDATE: u32 = 166;
pub const EVP_F_EVP_DIGESTFINALXOF: u32 = 174;
pub const EVP_F_EVP_DIGESTINIT_EX: u32 = 128;
pub const EVP_F_EVP_ENCRYPTDECRYPTUPDATE: u32 = 219;
pub const EVP_F_EVP_ENCRYPTFINAL_EX: u32 = 127;
pub const EVP_F_EVP_ENCRYPTUPDATE: u32 = 167;
pub const EVP_F_EVP_MD_CTX_COPY_EX: u32 = 110;
pub const EVP_F_EVP_MD_SIZE: u32 = 162;
pub const EVP_F_EVP_OPENINIT: u32 = 102;
pub const EVP_F_EVP_PBE_ALG_ADD: u32 = 115;
pub const EVP_F_EVP_PBE_ALG_ADD_TYPE: u32 = 160;
pub const EVP_F_EVP_PBE_CIPHERINIT: u32 = 116;
pub const EVP_F_EVP_PBE_SCRYPT: u32 = 181;
pub const EVP_F_EVP_PKCS82PKEY: u32 = 111;
pub const EVP_F_EVP_PKEY2PKCS8: u32 = 113;
pub const EVP_F_EVP_PKEY_ASN1_ADD0: u32 = 188;
pub const EVP_F_EVP_PKEY_CHECK: u32 = 186;
pub const EVP_F_EVP_PKEY_COPY_PARAMETERS: u32 = 103;
pub const EVP_F_EVP_PKEY_CTX_CTRL: u32 = 137;
pub const EVP_F_EVP_PKEY_CTX_CTRL_STR: u32 = 150;
pub const EVP_F_EVP_PKEY_CTX_DUP: u32 = 156;
pub const EVP_F_EVP_PKEY_CTX_MD: u32 = 168;
pub const EVP_F_EVP_PKEY_DECRYPT: u32 = 104;
pub const EVP_F_EVP_PKEY_DECRYPT_INIT: u32 = 138;
pub const EVP_F_EVP_PKEY_DECRYPT_OLD: u32 = 151;
pub const EVP_F_EVP_PKEY_DERIVE: u32 = 153;
pub const EVP_F_EVP_PKEY_DERIVE_INIT: u32 = 154;
pub const EVP_F_EVP_PKEY_DERIVE_SET_PEER: u32 = 155;
pub const EVP_F_EVP_PKEY_ENCRYPT: u32 = 105;
pub const EVP_F_EVP_PKEY_ENCRYPT_INIT: u32 = 139;
pub const EVP_F_EVP_PKEY_ENCRYPT_OLD: u32 = 152;
pub const EVP_F_EVP_PKEY_GET0_DH: u32 = 119;
pub const EVP_F_EVP_PKEY_GET0_DSA: u32 = 120;
pub const EVP_F_EVP_PKEY_GET0_EC_KEY: u32 = 131;
pub const EVP_F_EVP_PKEY_GET0_HMAC: u32 = 183;
pub const EVP_F_EVP_PKEY_GET0_POLY1305: u32 = 184;
pub const EVP_F_EVP_PKEY_GET0_RSA: u32 = 121;
pub const EVP_F_EVP_PKEY_GET0_SIPHASH: u32 = 172;
pub const EVP_F_EVP_PKEY_GET_RAW_PRIVATE_KEY: u32 = 202;
pub const EVP_F_EVP_PKEY_GET_RAW_PUBLIC_KEY: u32 = 203;
pub const EVP_F_EVP_PKEY_KEYGEN: u32 = 146;
pub const EVP_F_EVP_PKEY_KEYGEN_INIT: u32 = 147;
pub const EVP_F_EVP_PKEY_METH_ADD0: u32 = 194;
pub const EVP_F_EVP_PKEY_METH_NEW: u32 = 195;
pub const EVP_F_EVP_PKEY_NEW: u32 = 106;
pub const EVP_F_EVP_PKEY_NEW_CMAC_KEY: u32 = 193;
pub const EVP_F_EVP_PKEY_NEW_RAW_PRIVATE_KEY: u32 = 191;
pub const EVP_F_EVP_PKEY_NEW_RAW_PUBLIC_KEY: u32 = 192;
pub const EVP_F_EVP_PKEY_PARAMGEN: u32 = 148;
pub const EVP_F_EVP_PKEY_PARAMGEN_INIT: u32 = 149;
pub const EVP_F_EVP_PKEY_PARAM_CHECK: u32 = 189;
pub const EVP_F_EVP_PKEY_PUBLIC_CHECK: u32 = 190;
pub const EVP_F_EVP_PKEY_SET1_ENGINE: u32 = 187;
pub const EVP_F_EVP_PKEY_SET_ALIAS_TYPE: u32 = 206;
pub const EVP_F_EVP_PKEY_SIGN: u32 = 140;
pub const EVP_F_EVP_PKEY_SIGN_INIT: u32 = 141;
pub const EVP_F_EVP_PKEY_VERIFY: u32 = 142;
pub const EVP_F_EVP_PKEY_VERIFY_INIT: u32 = 143;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER: u32 = 144;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT: u32 = 145;
pub const EVP_F_EVP_SIGNFINAL: u32 = 107;
pub const EVP_F_EVP_VERIFYFINAL: u32 = 108;
pub const EVP_F_INT_CTX_NEW: u32 = 157;
pub const EVP_F_OK_NEW: u32 = 200;
pub const EVP_F_PKCS5_PBE_KEYIVGEN: u32 = 117;
pub const EVP_F_PKCS5_V2_PBE_KEYIVGEN: u32 = 118;
pub const EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN: u32 = 164;
pub const EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN: u32 = 180;
pub const EVP_F_PKEY_SET_TYPE: u32 = 158;
pub const EVP_F_RC2_MAGIC_TO_METH: u32 = 109;
pub const EVP_F_RC5_CTRL: u32 = 125;
pub const EVP_F_S390X_AES_GCM_CTRL: u32 = 201;
pub const EVP_F_UPDATE: u32 = 173;
pub const EVP_R_AES_KEY_SETUP_FAILED: u32 = 143;
pub const EVP_R_ARIA_KEY_SETUP_FAILED: u32 = 176;
pub const EVP_R_BAD_DECRYPT: u32 = 100;
pub const EVP_R_BUFFER_TOO_SMALL: u32 = 155;
pub const EVP_R_CAMELLIA_KEY_SETUP_FAILED: u32 = 157;
pub const EVP_R_CIPHER_PARAMETER_ERROR: u32 = 122;
pub const EVP_R_COMMAND_NOT_SUPPORTED: u32 = 147;
pub const EVP_R_COPY_ERROR: u32 = 173;
pub const EVP_R_CTRL_NOT_IMPLEMENTED: u32 = 132;
pub const EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED: u32 = 133;
pub const EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH: u32 = 138;
pub const EVP_R_DECODE_ERROR: u32 = 114;
pub const EVP_R_DIFFERENT_KEY_TYPES: u32 = 101;
pub const EVP_R_DIFFERENT_PARAMETERS: u32 = 153;
pub const EVP_R_ERROR_LOADING_SECTION: u32 = 165;
pub const EVP_R_ERROR_SETTING_FIPS_MODE: u32 = 166;
pub const EVP_R_EXPECTING_AN_HMAC_KEY: u32 = 174;
pub const EVP_R_EXPECTING_AN_RSA_KEY: u32 = 127;
pub const EVP_R_EXPECTING_A_DH_KEY: u32 = 128;
pub const EVP_R_EXPECTING_A_DSA_KEY: u32 = 129;
pub const EVP_R_EXPECTING_A_EC_KEY: u32 = 142;
pub const EVP_R_EXPECTING_A_POLY1305_KEY: u32 = 164;
pub const EVP_R_EXPECTING_A_SIPHASH_KEY: u32 = 175;
pub const EVP_R_FIPS_MODE_NOT_SUPPORTED: u32 = 167;
pub const EVP_R_GET_RAW_KEY_FAILED: u32 = 182;
pub const EVP_R_ILLEGAL_SCRYPT_PARAMETERS: u32 = 171;
pub const EVP_R_INITIALIZATION_ERROR: u32 = 134;
pub const EVP_R_INPUT_NOT_INITIALIZED: u32 = 111;
pub const EVP_R_INVALID_DIGEST: u32 = 152;
pub const EVP_R_INVALID_FIPS_MODE: u32 = 168;
pub const EVP_R_INVALID_KEY: u32 = 163;
pub const EVP_R_INVALID_KEY_LENGTH: u32 = 130;
pub const EVP_R_INVALID_OPERATION: u32 = 148;
pub const EVP_R_KEYGEN_FAILURE: u32 = 120;
pub const EVP_R_KEY_SETUP_FAILED: u32 = 180;
pub const EVP_R_MEMORY_LIMIT_EXCEEDED: u32 = 172;
pub const EVP_R_MESSAGE_DIGEST_IS_NULL: u32 = 159;
pub const EVP_R_METHOD_NOT_SUPPORTED: u32 = 144;
pub const EVP_R_MISSING_PARAMETERS: u32 = 103;
pub const EVP_R_NOT_XOF_OR_INVALID_LENGTH: u32 = 178;
pub const EVP_R_NO_CIPHER_SET: u32 = 131;
pub const EVP_R_NO_DEFAULT_DIGEST: u32 = 158;
pub const EVP_R_NO_DIGEST_SET: u32 = 139;
pub const EVP_R_NO_KEY_SET: u32 = 154;
pub const EVP_R_NO_OPERATION_SET: u32 = 149;
pub const EVP_R_ONLY_ONESHOT_SUPPORTED: u32 = 177;
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 150;
pub const EVP_R_OPERATON_NOT_INITIALIZED: u32 = 151;
pub const EVP_R_OUTPUT_WOULD_OVERFLOW: u32 = 184;
pub const EVP_R_PARTIALLY_OVERLAPPING: u32 = 162;
pub const EVP_R_PBKDF2_ERROR: u32 = 181;
pub const EVP_R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED: u32 = 179;
pub const EVP_R_PRIVATE_KEY_DECODE_ERROR: u32 = 145;
pub const EVP_R_PRIVATE_KEY_ENCODE_ERROR: u32 = 146;
pub const EVP_R_PUBLIC_KEY_NOT_RSA: u32 = 106;
pub const EVP_R_UNKNOWN_CIPHER: u32 = 160;
pub const EVP_R_UNKNOWN_DIGEST: u32 = 161;
pub const EVP_R_UNKNOWN_OPTION: u32 = 169;
pub const EVP_R_UNKNOWN_PBE_ALGORITHM: u32 = 121;
pub const EVP_R_UNSUPPORTED_ALGORITHM: u32 = 156;
pub const EVP_R_UNSUPPORTED_CIPHER: u32 = 107;
pub const EVP_R_UNSUPPORTED_KEYLENGTH: u32 = 123;
pub const EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION: u32 = 124;
pub const EVP_R_UNSUPPORTED_KEY_SIZE: u32 = 108;
pub const EVP_R_UNSUPPORTED_NUMBER_OF_ROUNDS: u32 = 135;
pub const EVP_R_UNSUPPORTED_PRF: u32 = 125;
pub const EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM: u32 = 118;
pub const EVP_R_UNSUPPORTED_SALT_TYPE: u32 = 126;
pub const EVP_R_WRAP_MODE_NOT_ALLOWED: u32 = 170;
pub const EVP_R_WRONG_FINAL_BLOCK_LENGTH: u32 = 109;
pub const EVP_MAX_MD_SIZE: u32 = 64;
pub const EVP_MAX_KEY_LENGTH: u32 = 64;
pub const EVP_MAX_IV_LENGTH: u32 = 16;
pub const EVP_MAX_BLOCK_LENGTH: u32 = 32;
pub const PKCS5_SALT_LEN: u32 = 8;
pub const PKCS5_DEFAULT_ITER: u32 = 2048;
pub const SN_undef: &[u8; 6usize] = b"UNDEF\0";
pub const LN_undef: &[u8; 10usize] = b"undefined\0";
pub const NID_undef: u32 = 0;
pub const OBJ_undef: u32 = 0;
pub const SN_itu_t: &[u8; 6usize] = b"ITU-T\0";
pub const LN_itu_t: &[u8; 6usize] = b"itu-t\0";
pub const NID_itu_t: u32 = 645;
pub const OBJ_itu_t: u32 = 0;
pub const NID_ccitt: u32 = 404;
pub const OBJ_ccitt: u32 = 0;
pub const SN_iso: &[u8; 4usize] = b"ISO\0";
pub const LN_iso: &[u8; 4usize] = b"iso\0";
pub const NID_iso: u32 = 181;
pub const OBJ_iso: u32 = 1;
pub const SN_joint_iso_itu_t: &[u8; 16usize] = b"JOINT-ISO-ITU-T\0";
pub const LN_joint_iso_itu_t: &[u8; 16usize] = b"joint-iso-itu-t\0";
pub const NID_joint_iso_itu_t: u32 = 646;
pub const OBJ_joint_iso_itu_t: u32 = 2;
pub const NID_joint_iso_ccitt: u32 = 393;
pub const OBJ_joint_iso_ccitt: u32 = 2;
pub const SN_member_body: &[u8; 12usize] = b"member-body\0";
pub const LN_member_body: &[u8; 16usize] = b"ISO Member Body\0";
pub const NID_member_body: u32 = 182;
pub const SN_identified_organization: &[u8; 24usize] = b"identified-organization\0";
pub const NID_identified_organization: u32 = 676;
pub const SN_hmac_md5: &[u8; 9usize] = b"HMAC-MD5\0";
pub const LN_hmac_md5: &[u8; 9usize] = b"hmac-md5\0";
pub const NID_hmac_md5: u32 = 780;
pub const SN_hmac_sha1: &[u8; 10usize] = b"HMAC-SHA1\0";
pub const LN_hmac_sha1: &[u8; 10usize] = b"hmac-sha1\0";
pub const NID_hmac_sha1: u32 = 781;
pub const SN_x509ExtAdmission: &[u8; 17usize] = b"x509ExtAdmission\0";
pub const LN_x509ExtAdmission: &[u8; 48usize] =
    b"Professional Information or basis for Admission\0";
pub const NID_x509ExtAdmission: u32 = 1093;
pub const SN_certicom_arc: &[u8; 13usize] = b"certicom-arc\0";
pub const NID_certicom_arc: u32 = 677;
pub const SN_ieee: &[u8; 5usize] = b"ieee\0";
pub const NID_ieee: u32 = 1170;
pub const SN_ieee_siswg: &[u8; 11usize] = b"ieee-siswg\0";
pub const LN_ieee_siswg: &[u8; 39usize] = b"IEEE Security in Storage Working Group\0";
pub const NID_ieee_siswg: u32 = 1171;
pub const SN_international_organizations: &[u8; 28usize] = b"international-organizations\0";
pub const LN_international_organizations: &[u8; 28usize] = b"International Organizations\0";
pub const NID_international_organizations: u32 = 647;
pub const SN_wap: &[u8; 4usize] = b"wap\0";
pub const NID_wap: u32 = 678;
pub const SN_wap_wsg: &[u8; 8usize] = b"wap-wsg\0";
pub const NID_wap_wsg: u32 = 679;
pub const SN_selected_attribute_types: &[u8; 25usize] = b"selected-attribute-types\0";
pub const LN_selected_attribute_types: &[u8; 25usize] = b"Selected Attribute Types\0";
pub const NID_selected_attribute_types: u32 = 394;
pub const SN_clearance: &[u8; 10usize] = b"clearance\0";
pub const NID_clearance: u32 = 395;
pub const SN_ISO_US: &[u8; 7usize] = b"ISO-US\0";
pub const LN_ISO_US: &[u8; 19usize] = b"ISO US Member Body\0";
pub const NID_ISO_US: u32 = 183;
pub const SN_X9_57: &[u8; 6usize] = b"X9-57\0";
pub const LN_X9_57: &[u8; 6usize] = b"X9.57\0";
pub const NID_X9_57: u32 = 184;
pub const SN_X9cm: &[u8; 5usize] = b"X9cm\0";
pub const LN_X9cm: &[u8; 11usize] = b"X9.57 CM ?\0";
pub const NID_X9cm: u32 = 185;
pub const SN_ISO_CN: &[u8; 7usize] = b"ISO-CN\0";
pub const LN_ISO_CN: &[u8; 19usize] = b"ISO CN Member Body\0";
pub const NID_ISO_CN: u32 = 1140;
pub const SN_oscca: &[u8; 6usize] = b"oscca\0";
pub const NID_oscca: u32 = 1141;
pub const SN_sm_scheme: &[u8; 10usize] = b"sm-scheme\0";
pub const NID_sm_scheme: u32 = 1142;
pub const SN_dsa: &[u8; 4usize] = b"DSA\0";
pub const LN_dsa: &[u8; 14usize] = b"dsaEncryption\0";
pub const NID_dsa: u32 = 116;
pub const SN_dsaWithSHA1: &[u8; 9usize] = b"DSA-SHA1\0";
pub const LN_dsaWithSHA1: &[u8; 12usize] = b"dsaWithSHA1\0";
pub const NID_dsaWithSHA1: u32 = 113;
pub const SN_ansi_X9_62: &[u8; 11usize] = b"ansi-X9-62\0";
pub const LN_ansi_X9_62: &[u8; 11usize] = b"ANSI X9.62\0";
pub const NID_ansi_X9_62: u32 = 405;
pub const SN_X9_62_prime_field: &[u8; 12usize] = b"prime-field\0";
pub const NID_X9_62_prime_field: u32 = 406;
pub const SN_X9_62_characteristic_two_field: &[u8; 25usize] = b"characteristic-two-field\0";
pub const NID_X9_62_characteristic_two_field: u32 = 407;
pub const SN_X9_62_id_characteristic_two_basis: &[u8; 28usize] = b"id-characteristic-two-basis\0";
pub const NID_X9_62_id_characteristic_two_basis: u32 = 680;
pub const SN_X9_62_onBasis: &[u8; 8usize] = b"onBasis\0";
pub const NID_X9_62_onBasis: u32 = 681;
pub const SN_X9_62_tpBasis: &[u8; 8usize] = b"tpBasis\0";
pub const NID_X9_62_tpBasis: u32 = 682;
pub const SN_X9_62_ppBasis: &[u8; 8usize] = b"ppBasis\0";
pub const NID_X9_62_ppBasis: u32 = 683;
pub const SN_X9_62_id_ecPublicKey: &[u8; 15usize] = b"id-ecPublicKey\0";
pub const NID_X9_62_id_ecPublicKey: u32 = 408;
pub const SN_X9_62_c2pnb163v1: &[u8; 11usize] = b"c2pnb163v1\0";
pub const NID_X9_62_c2pnb163v1: u32 = 684;
pub const SN_X9_62_c2pnb163v2: &[u8; 11usize] = b"c2pnb163v2\0";
pub const NID_X9_62_c2pnb163v2: u32 = 685;
pub const SN_X9_62_c2pnb163v3: &[u8; 11usize] = b"c2pnb163v3\0";
pub const NID_X9_62_c2pnb163v3: u32 = 686;
pub const SN_X9_62_c2pnb176v1: &[u8; 11usize] = b"c2pnb176v1\0";
pub const NID_X9_62_c2pnb176v1: u32 = 687;
pub const SN_X9_62_c2tnb191v1: &[u8; 11usize] = b"c2tnb191v1\0";
pub const NID_X9_62_c2tnb191v1: u32 = 688;
pub const SN_X9_62_c2tnb191v2: &[u8; 11usize] = b"c2tnb191v2\0";
pub const NID_X9_62_c2tnb191v2: u32 = 689;
pub const SN_X9_62_c2tnb191v3: &[u8; 11usize] = b"c2tnb191v3\0";
pub const NID_X9_62_c2tnb191v3: u32 = 690;
pub const SN_X9_62_c2onb191v4: &[u8; 11usize] = b"c2onb191v4\0";
pub const NID_X9_62_c2onb191v4: u32 = 691;
pub const SN_X9_62_c2onb191v5: &[u8; 11usize] = b"c2onb191v5\0";
pub const NID_X9_62_c2onb191v5: u32 = 692;
pub const SN_X9_62_c2pnb208w1: &[u8; 11usize] = b"c2pnb208w1\0";
pub const NID_X9_62_c2pnb208w1: u32 = 693;
pub const SN_X9_62_c2tnb239v1: &[u8; 11usize] = b"c2tnb239v1\0";
pub const NID_X9_62_c2tnb239v1: u32 = 694;
pub const SN_X9_62_c2tnb239v2: &[u8; 11usize] = b"c2tnb239v2\0";
pub const NID_X9_62_c2tnb239v2: u32 = 695;
pub const SN_X9_62_c2tnb239v3: &[u8; 11usize] = b"c2tnb239v3\0";
pub const NID_X9_62_c2tnb239v3: u32 = 696;
pub const SN_X9_62_c2onb239v4: &[u8; 11usize] = b"c2onb239v4\0";
pub const NID_X9_62_c2onb239v4: u32 = 697;
pub const SN_X9_62_c2onb239v5: &[u8; 11usize] = b"c2onb239v5\0";
pub const NID_X9_62_c2onb239v5: u32 = 698;
pub const SN_X9_62_c2pnb272w1: &[u8; 11usize] = b"c2pnb272w1\0";
pub const NID_X9_62_c2pnb272w1: u32 = 699;
pub const SN_X9_62_c2pnb304w1: &[u8; 11usize] = b"c2pnb304w1\0";
pub const NID_X9_62_c2pnb304w1: u32 = 700;
pub const SN_X9_62_c2tnb359v1: &[u8; 11usize] = b"c2tnb359v1\0";
pub const NID_X9_62_c2tnb359v1: u32 = 701;
pub const SN_X9_62_c2pnb368w1: &[u8; 11usize] = b"c2pnb368w1\0";
pub const NID_X9_62_c2pnb368w1: u32 = 702;
pub const SN_X9_62_c2tnb431r1: &[u8; 11usize] = b"c2tnb431r1\0";
pub const NID_X9_62_c2tnb431r1: u32 = 703;
pub const SN_X9_62_prime192v1: &[u8; 11usize] = b"prime192v1\0";
pub const NID_X9_62_prime192v1: u32 = 409;
pub const SN_X9_62_prime192v2: &[u8; 11usize] = b"prime192v2\0";
pub const NID_X9_62_prime192v2: u32 = 410;
pub const SN_X9_62_prime192v3: &[u8; 11usize] = b"prime192v3\0";
pub const NID_X9_62_prime192v3: u32 = 411;
pub const SN_X9_62_prime239v1: &[u8; 11usize] = b"prime239v1\0";
pub const NID_X9_62_prime239v1: u32 = 412;
pub const SN_X9_62_prime239v2: &[u8; 11usize] = b"prime239v2\0";
pub const NID_X9_62_prime239v2: u32 = 413;
pub const SN_X9_62_prime239v3: &[u8; 11usize] = b"prime239v3\0";
pub const NID_X9_62_prime239v3: u32 = 414;
pub const SN_X9_62_prime256v1: &[u8; 11usize] = b"prime256v1\0";
pub const NID_X9_62_prime256v1: u32 = 415;
pub const SN_ecdsa_with_SHA1: &[u8; 16usize] = b"ecdsa-with-SHA1\0";
pub const NID_ecdsa_with_SHA1: u32 = 416;
pub const SN_ecdsa_with_Recommended: &[u8; 23usize] = b"ecdsa-with-Recommended\0";
pub const NID_ecdsa_with_Recommended: u32 = 791;
pub const SN_ecdsa_with_Specified: &[u8; 21usize] = b"ecdsa-with-Specified\0";
pub const NID_ecdsa_with_Specified: u32 = 792;
pub const SN_ecdsa_with_SHA224: &[u8; 18usize] = b"ecdsa-with-SHA224\0";
pub const NID_ecdsa_with_SHA224: u32 = 793;
pub const SN_ecdsa_with_SHA256: &[u8; 18usize] = b"ecdsa-with-SHA256\0";
pub const NID_ecdsa_with_SHA256: u32 = 794;
pub const SN_ecdsa_with_SHA384: &[u8; 18usize] = b"ecdsa-with-SHA384\0";
pub const NID_ecdsa_with_SHA384: u32 = 795;
pub const SN_ecdsa_with_SHA512: &[u8; 18usize] = b"ecdsa-with-SHA512\0";
pub const NID_ecdsa_with_SHA512: u32 = 796;
pub const SN_secp112r1: &[u8; 10usize] = b"secp112r1\0";
pub const NID_secp112r1: u32 = 704;
pub const SN_secp112r2: &[u8; 10usize] = b"secp112r2\0";
pub const NID_secp112r2: u32 = 705;
pub const SN_secp128r1: &[u8; 10usize] = b"secp128r1\0";
pub const NID_secp128r1: u32 = 706;
pub const SN_secp128r2: &[u8; 10usize] = b"secp128r2\0";
pub const NID_secp128r2: u32 = 707;
pub const SN_secp160k1: &[u8; 10usize] = b"secp160k1\0";
pub const NID_secp160k1: u32 = 708;
pub const SN_secp160r1: &[u8; 10usize] = b"secp160r1\0";
pub const NID_secp160r1: u32 = 709;
pub const SN_secp160r2: &[u8; 10usize] = b"secp160r2\0";
pub const NID_secp160r2: u32 = 710;
pub const SN_secp192k1: &[u8; 10usize] = b"secp192k1\0";
pub const NID_secp192k1: u32 = 711;
pub const SN_secp224k1: &[u8; 10usize] = b"secp224k1\0";
pub const NID_secp224k1: u32 = 712;
pub const SN_secp224r1: &[u8; 10usize] = b"secp224r1\0";
pub const NID_secp224r1: u32 = 713;
pub const SN_secp256k1: &[u8; 10usize] = b"secp256k1\0";
pub const NID_secp256k1: u32 = 714;
pub const SN_secp384r1: &[u8; 10usize] = b"secp384r1\0";
pub const NID_secp384r1: u32 = 715;
pub const SN_secp521r1: &[u8; 10usize] = b"secp521r1\0";
pub const NID_secp521r1: u32 = 716;
pub const SN_sect113r1: &[u8; 10usize] = b"sect113r1\0";
pub const NID_sect113r1: u32 = 717;
pub const SN_sect113r2: &[u8; 10usize] = b"sect113r2\0";
pub const NID_sect113r2: u32 = 718;
pub const SN_sect131r1: &[u8; 10usize] = b"sect131r1\0";
pub const NID_sect131r1: u32 = 719;
pub const SN_sect131r2: &[u8; 10usize] = b"sect131r2\0";
pub const NID_sect131r2: u32 = 720;
pub const SN_sect163k1: &[u8; 10usize] = b"sect163k1\0";
pub const NID_sect163k1: u32 = 721;
pub const SN_sect163r1: &[u8; 10usize] = b"sect163r1\0";
pub const NID_sect163r1: u32 = 722;
pub const SN_sect163r2: &[u8; 10usize] = b"sect163r2\0";
pub const NID_sect163r2: u32 = 723;
pub const SN_sect193r1: &[u8; 10usize] = b"sect193r1\0";
pub const NID_sect193r1: u32 = 724;
pub const SN_sect193r2: &[u8; 10usize] = b"sect193r2\0";
pub const NID_sect193r2: u32 = 725;
pub const SN_sect233k1: &[u8; 10usize] = b"sect233k1\0";
pub const NID_sect233k1: u32 = 726;
pub const SN_sect233r1: &[u8; 10usize] = b"sect233r1\0";
pub const NID_sect233r1: u32 = 727;
pub const SN_sect239k1: &[u8; 10usize] = b"sect239k1\0";
pub const NID_sect239k1: u32 = 728;
pub const SN_sect283k1: &[u8; 10usize] = b"sect283k1\0";
pub const NID_sect283k1: u32 = 729;
pub const SN_sect283r1: &[u8; 10usize] = b"sect283r1\0";
pub const NID_sect283r1: u32 = 730;
pub const SN_sect409k1: &[u8; 10usize] = b"sect409k1\0";
pub const NID_sect409k1: u32 = 731;
pub const SN_sect409r1: &[u8; 10usize] = b"sect409r1\0";
pub const NID_sect409r1: u32 = 732;
pub const SN_sect571k1: &[u8; 10usize] = b"sect571k1\0";
pub const NID_sect571k1: u32 = 733;
pub const SN_sect571r1: &[u8; 10usize] = b"sect571r1\0";
pub const NID_sect571r1: u32 = 734;
pub const SN_wap_wsg_idm_ecid_wtls1: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls1\0";
pub const NID_wap_wsg_idm_ecid_wtls1: u32 = 735;
pub const SN_wap_wsg_idm_ecid_wtls3: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls3\0";
pub const NID_wap_wsg_idm_ecid_wtls3: u32 = 736;
pub const SN_wap_wsg_idm_ecid_wtls4: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls4\0";
pub const NID_wap_wsg_idm_ecid_wtls4: u32 = 737;
pub const SN_wap_wsg_idm_ecid_wtls5: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls5\0";
pub const NID_wap_wsg_idm_ecid_wtls5: u32 = 738;
pub const SN_wap_wsg_idm_ecid_wtls6: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls6\0";
pub const NID_wap_wsg_idm_ecid_wtls6: u32 = 739;
pub const SN_wap_wsg_idm_ecid_wtls7: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls7\0";
pub const NID_wap_wsg_idm_ecid_wtls7: u32 = 740;
pub const SN_wap_wsg_idm_ecid_wtls8: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls8\0";
pub const NID_wap_wsg_idm_ecid_wtls8: u32 = 741;
pub const SN_wap_wsg_idm_ecid_wtls9: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls9\0";
pub const NID_wap_wsg_idm_ecid_wtls9: u32 = 742;
pub const SN_wap_wsg_idm_ecid_wtls10: &[u8; 24usize] = b"wap-wsg-idm-ecid-wtls10\0";
pub const NID_wap_wsg_idm_ecid_wtls10: u32 = 743;
pub const SN_wap_wsg_idm_ecid_wtls11: &[u8; 24usize] = b"wap-wsg-idm-ecid-wtls11\0";
pub const NID_wap_wsg_idm_ecid_wtls11: u32 = 744;
pub const SN_wap_wsg_idm_ecid_wtls12: &[u8; 24usize] = b"wap-wsg-idm-ecid-wtls12\0";
pub const NID_wap_wsg_idm_ecid_wtls12: u32 = 745;
pub const SN_cast5_cbc: &[u8; 10usize] = b"CAST5-CBC\0";
pub const LN_cast5_cbc: &[u8; 10usize] = b"cast5-cbc\0";
pub const NID_cast5_cbc: u32 = 108;
pub const SN_cast5_ecb: &[u8; 10usize] = b"CAST5-ECB\0";
pub const LN_cast5_ecb: &[u8; 10usize] = b"cast5-ecb\0";
pub const NID_cast5_ecb: u32 = 109;
pub const SN_cast5_cfb64: &[u8; 10usize] = b"CAST5-CFB\0";
pub const LN_cast5_cfb64: &[u8; 10usize] = b"cast5-cfb\0";
pub const NID_cast5_cfb64: u32 = 110;
pub const SN_cast5_ofb64: &[u8; 10usize] = b"CAST5-OFB\0";
pub const LN_cast5_ofb64: &[u8; 10usize] = b"cast5-ofb\0";
pub const NID_cast5_ofb64: u32 = 111;
pub const LN_pbeWithMD5AndCast5_CBC: &[u8; 22usize] = b"pbeWithMD5AndCast5CBC\0";
pub const NID_pbeWithMD5AndCast5_CBC: u32 = 112;
pub const SN_id_PasswordBasedMAC: &[u8; 20usize] = b"id-PasswordBasedMAC\0";
pub const LN_id_PasswordBasedMAC: &[u8; 19usize] = b"password based MAC\0";
pub const NID_id_PasswordBasedMAC: u32 = 782;
pub const SN_id_DHBasedMac: &[u8; 14usize] = b"id-DHBasedMac\0";
pub const LN_id_DHBasedMac: &[u8; 25usize] = b"Diffie-Hellman based MAC\0";
pub const NID_id_DHBasedMac: u32 = 783;
pub const SN_rsadsi: &[u8; 7usize] = b"rsadsi\0";
pub const LN_rsadsi: &[u8; 24usize] = b"RSA Data Security, Inc.\0";
pub const NID_rsadsi: u32 = 1;
pub const SN_pkcs: &[u8; 5usize] = b"pkcs\0";
pub const LN_pkcs: &[u8; 29usize] = b"RSA Data Security, Inc. PKCS\0";
pub const NID_pkcs: u32 = 2;
pub const SN_pkcs1: &[u8; 6usize] = b"pkcs1\0";
pub const NID_pkcs1: u32 = 186;
pub const LN_rsaEncryption: &[u8; 14usize] = b"rsaEncryption\0";
pub const NID_rsaEncryption: u32 = 6;
pub const SN_md2WithRSAEncryption: &[u8; 8usize] = b"RSA-MD2\0";
pub const LN_md2WithRSAEncryption: &[u8; 21usize] = b"md2WithRSAEncryption\0";
pub const NID_md2WithRSAEncryption: u32 = 7;
pub const SN_md4WithRSAEncryption: &[u8; 8usize] = b"RSA-MD4\0";
pub const LN_md4WithRSAEncryption: &[u8; 21usize] = b"md4WithRSAEncryption\0";
pub const NID_md4WithRSAEncryption: u32 = 396;
pub const SN_md5WithRSAEncryption: &[u8; 8usize] = b"RSA-MD5\0";
pub const LN_md5WithRSAEncryption: &[u8; 21usize] = b"md5WithRSAEncryption\0";
pub const NID_md5WithRSAEncryption: u32 = 8;
pub const SN_sha1WithRSAEncryption: &[u8; 9usize] = b"RSA-SHA1\0";
pub const LN_sha1WithRSAEncryption: &[u8; 22usize] = b"sha1WithRSAEncryption\0";
pub const NID_sha1WithRSAEncryption: u32 = 65;
pub const SN_rsaesOaep: &[u8; 11usize] = b"RSAES-OAEP\0";
pub const LN_rsaesOaep: &[u8; 10usize] = b"rsaesOaep\0";
pub const NID_rsaesOaep: u32 = 919;
pub const SN_mgf1: &[u8; 5usize] = b"MGF1\0";
pub const LN_mgf1: &[u8; 5usize] = b"mgf1\0";
pub const NID_mgf1: u32 = 911;
pub const SN_pSpecified: &[u8; 11usize] = b"PSPECIFIED\0";
pub const LN_pSpecified: &[u8; 11usize] = b"pSpecified\0";
pub const NID_pSpecified: u32 = 935;
pub const SN_rsassaPss: &[u8; 11usize] = b"RSASSA-PSS\0";
pub const LN_rsassaPss: &[u8; 10usize] = b"rsassaPss\0";
pub const NID_rsassaPss: u32 = 912;
pub const SN_sha256WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA256\0";
pub const LN_sha256WithRSAEncryption: &[u8; 24usize] = b"sha256WithRSAEncryption\0";
pub const NID_sha256WithRSAEncryption: u32 = 668;
pub const SN_sha384WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA384\0";
pub const LN_sha384WithRSAEncryption: &[u8; 24usize] = b"sha384WithRSAEncryption\0";
pub const NID_sha384WithRSAEncryption: u32 = 669;
pub const SN_sha512WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA512\0";
pub const LN_sha512WithRSAEncryption: &[u8; 24usize] = b"sha512WithRSAEncryption\0";
pub const NID_sha512WithRSAEncryption: u32 = 670;
pub const SN_sha224WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA224\0";
pub const LN_sha224WithRSAEncryption: &[u8; 24usize] = b"sha224WithRSAEncryption\0";
pub const NID_sha224WithRSAEncryption: u32 = 671;
pub const SN_sha512_224WithRSAEncryption: &[u8; 15usize] = b"RSA-SHA512/224\0";
pub const LN_sha512_224WithRSAEncryption: &[u8; 28usize] = b"sha512-224WithRSAEncryption\0";
pub const NID_sha512_224WithRSAEncryption: u32 = 1145;
pub const SN_sha512_256WithRSAEncryption: &[u8; 15usize] = b"RSA-SHA512/256\0";
pub const LN_sha512_256WithRSAEncryption: &[u8; 28usize] = b"sha512-256WithRSAEncryption\0";
pub const NID_sha512_256WithRSAEncryption: u32 = 1146;
pub const SN_pkcs3: &[u8; 6usize] = b"pkcs3\0";
pub const NID_pkcs3: u32 = 27;
pub const LN_dhKeyAgreement: &[u8; 15usize] = b"dhKeyAgreement\0";
pub const NID_dhKeyAgreement: u32 = 28;
pub const SN_pkcs5: &[u8; 6usize] = b"pkcs5\0";
pub const NID_pkcs5: u32 = 187;
pub const SN_pbeWithMD2AndDES_CBC: &[u8; 12usize] = b"PBE-MD2-DES\0";
pub const LN_pbeWithMD2AndDES_CBC: &[u8; 21usize] = b"pbeWithMD2AndDES-CBC\0";
pub const NID_pbeWithMD2AndDES_CBC: u32 = 9;
pub const SN_pbeWithMD5AndDES_CBC: &[u8; 12usize] = b"PBE-MD5-DES\0";
pub const LN_pbeWithMD5AndDES_CBC: &[u8; 21usize] = b"pbeWithMD5AndDES-CBC\0";
pub const NID_pbeWithMD5AndDES_CBC: u32 = 10;
pub const SN_pbeWithMD2AndRC2_CBC: &[u8; 15usize] = b"PBE-MD2-RC2-64\0";
pub const LN_pbeWithMD2AndRC2_CBC: &[u8; 21usize] = b"pbeWithMD2AndRC2-CBC\0";
pub const NID_pbeWithMD2AndRC2_CBC: u32 = 168;
pub const SN_pbeWithMD5AndRC2_CBC: &[u8; 15usize] = b"PBE-MD5-RC2-64\0";
pub const LN_pbeWithMD5AndRC2_CBC: &[u8; 21usize] = b"pbeWithMD5AndRC2-CBC\0";
pub const NID_pbeWithMD5AndRC2_CBC: u32 = 169;
pub const SN_pbeWithSHA1AndDES_CBC: &[u8; 13usize] = b"PBE-SHA1-DES\0";
pub const LN_pbeWithSHA1AndDES_CBC: &[u8; 22usize] = b"pbeWithSHA1AndDES-CBC\0";
pub const NID_pbeWithSHA1AndDES_CBC: u32 = 170;
pub const SN_pbeWithSHA1AndRC2_CBC: &[u8; 16usize] = b"PBE-SHA1-RC2-64\0";
pub const LN_pbeWithSHA1AndRC2_CBC: &[u8; 22usize] = b"pbeWithSHA1AndRC2-CBC\0";
pub const NID_pbeWithSHA1AndRC2_CBC: u32 = 68;
pub const LN_id_pbkdf2: &[u8; 7usize] = b"PBKDF2\0";
pub const NID_id_pbkdf2: u32 = 69;
pub const LN_pbes2: &[u8; 6usize] = b"PBES2\0";
pub const NID_pbes2: u32 = 161;
pub const LN_pbmac1: &[u8; 7usize] = b"PBMAC1\0";
pub const NID_pbmac1: u32 = 162;
pub const SN_pkcs7: &[u8; 6usize] = b"pkcs7\0";
pub const NID_pkcs7: u32 = 20;
pub const LN_pkcs7_data: &[u8; 11usize] = b"pkcs7-data\0";
pub const NID_pkcs7_data: u32 = 21;
pub const LN_pkcs7_signed: &[u8; 17usize] = b"pkcs7-signedData\0";
pub const NID_pkcs7_signed: u32 = 22;
pub const LN_pkcs7_enveloped: &[u8; 20usize] = b"pkcs7-envelopedData\0";
pub const NID_pkcs7_enveloped: u32 = 23;
pub const LN_pkcs7_signedAndEnveloped: &[u8; 29usize] = b"pkcs7-signedAndEnvelopedData\0";
pub const NID_pkcs7_signedAndEnveloped: u32 = 24;
pub const LN_pkcs7_digest: &[u8; 17usize] = b"pkcs7-digestData\0";
pub const NID_pkcs7_digest: u32 = 25;
pub const LN_pkcs7_encrypted: &[u8; 20usize] = b"pkcs7-encryptedData\0";
pub const NID_pkcs7_encrypted: u32 = 26;
pub const SN_pkcs9: &[u8; 6usize] = b"pkcs9\0";
pub const NID_pkcs9: u32 = 47;
pub const LN_pkcs9_emailAddress: &[u8; 13usize] = b"emailAddress\0";
pub const NID_pkcs9_emailAddress: u32 = 48;
pub const LN_pkcs9_unstructuredName: &[u8; 17usize] = b"unstructuredName\0";
pub const NID_pkcs9_unstructuredName: u32 = 49;
pub const LN_pkcs9_contentType: &[u8; 12usize] = b"contentType\0";
pub const NID_pkcs9_contentType: u32 = 50;
pub const LN_pkcs9_messageDigest: &[u8; 14usize] = b"messageDigest\0";
pub const NID_pkcs9_messageDigest: u32 = 51;
pub const LN_pkcs9_signingTime: &[u8; 12usize] = b"signingTime\0";
pub const NID_pkcs9_signingTime: u32 = 52;
pub const LN_pkcs9_countersignature: &[u8; 17usize] = b"countersignature\0";
pub const NID_pkcs9_countersignature: u32 = 53;
pub const LN_pkcs9_challengePassword: &[u8; 18usize] = b"challengePassword\0";
pub const NID_pkcs9_challengePassword: u32 = 54;
pub const LN_pkcs9_unstructuredAddress: &[u8; 20usize] = b"unstructuredAddress\0";
pub const NID_pkcs9_unstructuredAddress: u32 = 55;
pub const LN_pkcs9_extCertAttributes: &[u8; 30usize] = b"extendedCertificateAttributes\0";
pub const NID_pkcs9_extCertAttributes: u32 = 56;
pub const SN_ext_req: &[u8; 7usize] = b"extReq\0";
pub const LN_ext_req: &[u8; 18usize] = b"Extension Request\0";
pub const NID_ext_req: u32 = 172;
pub const SN_SMIMECapabilities: &[u8; 11usize] = b"SMIME-CAPS\0";
pub const LN_SMIMECapabilities: &[u8; 20usize] = b"S/MIME Capabilities\0";
pub const NID_SMIMECapabilities: u32 = 167;
pub const SN_SMIME: &[u8; 6usize] = b"SMIME\0";
pub const LN_SMIME: &[u8; 7usize] = b"S/MIME\0";
pub const NID_SMIME: u32 = 188;
pub const SN_id_smime_mod: &[u8; 13usize] = b"id-smime-mod\0";
pub const NID_id_smime_mod: u32 = 189;
pub const SN_id_smime_ct: &[u8; 12usize] = b"id-smime-ct\0";
pub const NID_id_smime_ct: u32 = 190;
pub const SN_id_smime_aa: &[u8; 12usize] = b"id-smime-aa\0";
pub const NID_id_smime_aa: u32 = 191;
pub const SN_id_smime_alg: &[u8; 13usize] = b"id-smime-alg\0";
pub const NID_id_smime_alg: u32 = 192;
pub const SN_id_smime_cd: &[u8; 12usize] = b"id-smime-cd\0";
pub const NID_id_smime_cd: u32 = 193;
pub const SN_id_smime_spq: &[u8; 13usize] = b"id-smime-spq\0";
pub const NID_id_smime_spq: u32 = 194;
pub const SN_id_smime_cti: &[u8; 13usize] = b"id-smime-cti\0";
pub const NID_id_smime_cti: u32 = 195;
pub const SN_id_smime_mod_cms: &[u8; 17usize] = b"id-smime-mod-cms\0";
pub const NID_id_smime_mod_cms: u32 = 196;
pub const SN_id_smime_mod_ess: &[u8; 17usize] = b"id-smime-mod-ess\0";
pub const NID_id_smime_mod_ess: u32 = 197;
pub const SN_id_smime_mod_oid: &[u8; 17usize] = b"id-smime-mod-oid\0";
pub const NID_id_smime_mod_oid: u32 = 198;
pub const SN_id_smime_mod_msg_v3: &[u8; 20usize] = b"id-smime-mod-msg-v3\0";
pub const NID_id_smime_mod_msg_v3: u32 = 199;
pub const SN_id_smime_mod_ets_eSignature_88: &[u8; 31usize] = b"id-smime-mod-ets-eSignature-88\0";
pub const NID_id_smime_mod_ets_eSignature_88: u32 = 200;
pub const SN_id_smime_mod_ets_eSignature_97: &[u8; 31usize] = b"id-smime-mod-ets-eSignature-97\0";
pub const NID_id_smime_mod_ets_eSignature_97: u32 = 201;
pub const SN_id_smime_mod_ets_eSigPolicy_88: &[u8; 31usize] = b"id-smime-mod-ets-eSigPolicy-88\0";
pub const NID_id_smime_mod_ets_eSigPolicy_88: u32 = 202;
pub const SN_id_smime_mod_ets_eSigPolicy_97: &[u8; 31usize] = b"id-smime-mod-ets-eSigPolicy-97\0";
pub const NID_id_smime_mod_ets_eSigPolicy_97: u32 = 203;
pub const SN_id_smime_ct_receipt: &[u8; 20usize] = b"id-smime-ct-receipt\0";
pub const NID_id_smime_ct_receipt: u32 = 204;
pub const SN_id_smime_ct_authData: &[u8; 21usize] = b"id-smime-ct-authData\0";
pub const NID_id_smime_ct_authData: u32 = 205;
pub const SN_id_smime_ct_publishCert: &[u8; 24usize] = b"id-smime-ct-publishCert\0";
pub const NID_id_smime_ct_publishCert: u32 = 206;
pub const SN_id_smime_ct_TSTInfo: &[u8; 20usize] = b"id-smime-ct-TSTInfo\0";
pub const NID_id_smime_ct_TSTInfo: u32 = 207;
pub const SN_id_smime_ct_TDTInfo: &[u8; 20usize] = b"id-smime-ct-TDTInfo\0";
pub const NID_id_smime_ct_TDTInfo: u32 = 208;
pub const SN_id_smime_ct_contentInfo: &[u8; 24usize] = b"id-smime-ct-contentInfo\0";
pub const NID_id_smime_ct_contentInfo: u32 = 209;
pub const SN_id_smime_ct_DVCSRequestData: &[u8; 28usize] = b"id-smime-ct-DVCSRequestData\0";
pub const NID_id_smime_ct_DVCSRequestData: u32 = 210;
pub const SN_id_smime_ct_DVCSResponseData: &[u8; 29usize] = b"id-smime-ct-DVCSResponseData\0";
pub const NID_id_smime_ct_DVCSResponseData: u32 = 211;
pub const SN_id_smime_ct_compressedData: &[u8; 27usize] = b"id-smime-ct-compressedData\0";
pub const NID_id_smime_ct_compressedData: u32 = 786;
pub const SN_id_smime_ct_contentCollection: &[u8; 30usize] = b"id-smime-ct-contentCollection\0";
pub const NID_id_smime_ct_contentCollection: u32 = 1058;
pub const SN_id_smime_ct_authEnvelopedData: &[u8; 30usize] = b"id-smime-ct-authEnvelopedData\0";
pub const NID_id_smime_ct_authEnvelopedData: u32 = 1059;
pub const SN_id_ct_asciiTextWithCRLF: &[u8; 24usize] = b"id-ct-asciiTextWithCRLF\0";
pub const NID_id_ct_asciiTextWithCRLF: u32 = 787;
pub const SN_id_ct_xml: &[u8; 10usize] = b"id-ct-xml\0";
pub const NID_id_ct_xml: u32 = 1060;
pub const SN_id_smime_aa_receiptRequest: &[u8; 27usize] = b"id-smime-aa-receiptRequest\0";
pub const NID_id_smime_aa_receiptRequest: u32 = 212;
pub const SN_id_smime_aa_securityLabel: &[u8; 26usize] = b"id-smime-aa-securityLabel\0";
pub const NID_id_smime_aa_securityLabel: u32 = 213;
pub const SN_id_smime_aa_mlExpandHistory: &[u8; 28usize] = b"id-smime-aa-mlExpandHistory\0";
pub const NID_id_smime_aa_mlExpandHistory: u32 = 214;
pub const SN_id_smime_aa_contentHint: &[u8; 24usize] = b"id-smime-aa-contentHint\0";
pub const NID_id_smime_aa_contentHint: u32 = 215;
pub const SN_id_smime_aa_msgSigDigest: &[u8; 25usize] = b"id-smime-aa-msgSigDigest\0";
pub const NID_id_smime_aa_msgSigDigest: u32 = 216;
pub const SN_id_smime_aa_encapContentType: &[u8; 29usize] = b"id-smime-aa-encapContentType\0";
pub const NID_id_smime_aa_encapContentType: u32 = 217;
pub const SN_id_smime_aa_contentIdentifier: &[u8; 30usize] = b"id-smime-aa-contentIdentifier\0";
pub const NID_id_smime_aa_contentIdentifier: u32 = 218;
pub const SN_id_smime_aa_macValue: &[u8; 21usize] = b"id-smime-aa-macValue\0";
pub const NID_id_smime_aa_macValue: u32 = 219;
pub const SN_id_smime_aa_equivalentLabels: &[u8; 29usize] = b"id-smime-aa-equivalentLabels\0";
pub const NID_id_smime_aa_equivalentLabels: u32 = 220;
pub const SN_id_smime_aa_contentReference: &[u8; 29usize] = b"id-smime-aa-contentReference\0";
pub const NID_id_smime_aa_contentReference: u32 = 221;
pub const SN_id_smime_aa_encrypKeyPref: &[u8; 26usize] = b"id-smime-aa-encrypKeyPref\0";
pub const NID_id_smime_aa_encrypKeyPref: u32 = 222;
pub const SN_id_smime_aa_signingCertificate: &[u8; 31usize] = b"id-smime-aa-signingCertificate\0";
pub const NID_id_smime_aa_signingCertificate: u32 = 223;
pub const SN_id_smime_aa_smimeEncryptCerts: &[u8; 30usize] = b"id-smime-aa-smimeEncryptCerts\0";
pub const NID_id_smime_aa_smimeEncryptCerts: u32 = 224;
pub const SN_id_smime_aa_timeStampToken: &[u8; 27usize] = b"id-smime-aa-timeStampToken\0";
pub const NID_id_smime_aa_timeStampToken: u32 = 225;
pub const SN_id_smime_aa_ets_sigPolicyId: &[u8; 28usize] = b"id-smime-aa-ets-sigPolicyId\0";
pub const NID_id_smime_aa_ets_sigPolicyId: u32 = 226;
pub const SN_id_smime_aa_ets_commitmentType: &[u8; 31usize] = b"id-smime-aa-ets-commitmentType\0";
pub const NID_id_smime_aa_ets_commitmentType: u32 = 227;
pub const SN_id_smime_aa_ets_signerLocation: &[u8; 31usize] = b"id-smime-aa-ets-signerLocation\0";
pub const NID_id_smime_aa_ets_signerLocation: u32 = 228;
pub const SN_id_smime_aa_ets_signerAttr: &[u8; 27usize] = b"id-smime-aa-ets-signerAttr\0";
pub const NID_id_smime_aa_ets_signerAttr: u32 = 229;
pub const SN_id_smime_aa_ets_otherSigCert: &[u8; 29usize] = b"id-smime-aa-ets-otherSigCert\0";
pub const NID_id_smime_aa_ets_otherSigCert: u32 = 230;
pub const SN_id_smime_aa_ets_contentTimestamp: &[u8; 33usize] =
    b"id-smime-aa-ets-contentTimestamp\0";
pub const NID_id_smime_aa_ets_contentTimestamp: u32 = 231;
pub const SN_id_smime_aa_ets_CertificateRefs: &[u8; 32usize] = b"id-smime-aa-ets-CertificateRefs\0";
pub const NID_id_smime_aa_ets_CertificateRefs: u32 = 232;
pub const SN_id_smime_aa_ets_RevocationRefs: &[u8; 31usize] = b"id-smime-aa-ets-RevocationRefs\0";
pub const NID_id_smime_aa_ets_RevocationRefs: u32 = 233;
pub const SN_id_smime_aa_ets_certValues: &[u8; 27usize] = b"id-smime-aa-ets-certValues\0";
pub const NID_id_smime_aa_ets_certValues: u32 = 234;
pub const SN_id_smime_aa_ets_revocationValues: &[u8; 33usize] =
    b"id-smime-aa-ets-revocationValues\0";
pub const NID_id_smime_aa_ets_revocationValues: u32 = 235;
pub const SN_id_smime_aa_ets_escTimeStamp: &[u8; 29usize] = b"id-smime-aa-ets-escTimeStamp\0";
pub const NID_id_smime_aa_ets_escTimeStamp: u32 = 236;
pub const SN_id_smime_aa_ets_certCRLTimestamp: &[u8; 33usize] =
    b"id-smime-aa-ets-certCRLTimestamp\0";
pub const NID_id_smime_aa_ets_certCRLTimestamp: u32 = 237;
pub const SN_id_smime_aa_ets_archiveTimeStamp: &[u8; 33usize] =
    b"id-smime-aa-ets-archiveTimeStamp\0";
pub const NID_id_smime_aa_ets_archiveTimeStamp: u32 = 238;
pub const SN_id_smime_aa_signatureType: &[u8; 26usize] = b"id-smime-aa-signatureType\0";
pub const NID_id_smime_aa_signatureType: u32 = 239;
pub const SN_id_smime_aa_dvcs_dvc: &[u8; 21usize] = b"id-smime-aa-dvcs-dvc\0";
pub const NID_id_smime_aa_dvcs_dvc: u32 = 240;
pub const SN_id_smime_aa_signingCertificateV2: &[u8; 33usize] =
    b"id-smime-aa-signingCertificateV2\0";
pub const NID_id_smime_aa_signingCertificateV2: u32 = 1086;
pub const SN_id_smime_alg_ESDHwith3DES: &[u8; 26usize] = b"id-smime-alg-ESDHwith3DES\0";
pub const NID_id_smime_alg_ESDHwith3DES: u32 = 241;
pub const SN_id_smime_alg_ESDHwithRC2: &[u8; 25usize] = b"id-smime-alg-ESDHwithRC2\0";
pub const NID_id_smime_alg_ESDHwithRC2: u32 = 242;
pub const SN_id_smime_alg_3DESwrap: &[u8; 22usize] = b"id-smime-alg-3DESwrap\0";
pub const NID_id_smime_alg_3DESwrap: u32 = 243;
pub const SN_id_smime_alg_RC2wrap: &[u8; 21usize] = b"id-smime-alg-RC2wrap\0";
pub const NID_id_smime_alg_RC2wrap: u32 = 244;
pub const SN_id_smime_alg_ESDH: &[u8; 18usize] = b"id-smime-alg-ESDH\0";
pub const NID_id_smime_alg_ESDH: u32 = 245;
pub const SN_id_smime_alg_CMS3DESwrap: &[u8; 25usize] = b"id-smime-alg-CMS3DESwrap\0";
pub const NID_id_smime_alg_CMS3DESwrap: u32 = 246;
pub const SN_id_smime_alg_CMSRC2wrap: &[u8; 24usize] = b"id-smime-alg-CMSRC2wrap\0";
pub const NID_id_smime_alg_CMSRC2wrap: u32 = 247;
pub const SN_id_alg_PWRI_KEK: &[u8; 16usize] = b"id-alg-PWRI-KEK\0";
pub const NID_id_alg_PWRI_KEK: u32 = 893;
pub const SN_id_smime_cd_ldap: &[u8; 17usize] = b"id-smime-cd-ldap\0";
pub const NID_id_smime_cd_ldap: u32 = 248;
pub const SN_id_smime_spq_ets_sqt_uri: &[u8; 25usize] = b"id-smime-spq-ets-sqt-uri\0";
pub const NID_id_smime_spq_ets_sqt_uri: u32 = 249;
pub const SN_id_smime_spq_ets_sqt_unotice: &[u8; 29usize] = b"id-smime-spq-ets-sqt-unotice\0";
pub const NID_id_smime_spq_ets_sqt_unotice: u32 = 250;
pub const SN_id_smime_cti_ets_proofOfOrigin: &[u8; 31usize] = b"id-smime-cti-ets-proofOfOrigin\0";
pub const NID_id_smime_cti_ets_proofOfOrigin: u32 = 251;
pub const SN_id_smime_cti_ets_proofOfReceipt: &[u8; 32usize] = b"id-smime-cti-ets-proofOfReceipt\0";
pub const NID_id_smime_cti_ets_proofOfReceipt: u32 = 252;
pub const SN_id_smime_cti_ets_proofOfDelivery: &[u8; 33usize] =
    b"id-smime-cti-ets-proofOfDelivery\0";
pub const NID_id_smime_cti_ets_proofOfDelivery: u32 = 253;
pub const SN_id_smime_cti_ets_proofOfSender: &[u8; 31usize] = b"id-smime-cti-ets-proofOfSender\0";
pub const NID_id_smime_cti_ets_proofOfSender: u32 = 254;
pub const SN_id_smime_cti_ets_proofOfApproval: &[u8; 33usize] =
    b"id-smime-cti-ets-proofOfApproval\0";
pub const NID_id_smime_cti_ets_proofOfApproval: u32 = 255;
pub const SN_id_smime_cti_ets_proofOfCreation: &[u8; 33usize] =
    b"id-smime-cti-ets-proofOfCreation\0";
pub const NID_id_smime_cti_ets_proofOfCreation: u32 = 256;
pub const LN_friendlyName: &[u8; 13usize] = b"friendlyName\0";
pub const NID_friendlyName: u32 = 156;
pub const LN_localKeyID: &[u8; 11usize] = b"localKeyID\0";
pub const NID_localKeyID: u32 = 157;
pub const SN_ms_csp_name: &[u8; 8usize] = b"CSPName\0";
pub const LN_ms_csp_name: &[u8; 19usize] = b"Microsoft CSP Name\0";
pub const NID_ms_csp_name: u32 = 417;
pub const SN_LocalKeySet: &[u8; 12usize] = b"LocalKeySet\0";
pub const LN_LocalKeySet: &[u8; 24usize] = b"Microsoft Local Key set\0";
pub const NID_LocalKeySet: u32 = 856;
pub const LN_x509Certificate: &[u8; 16usize] = b"x509Certificate\0";
pub const NID_x509Certificate: u32 = 158;
pub const LN_sdsiCertificate: &[u8; 16usize] = b"sdsiCertificate\0";
pub const NID_sdsiCertificate: u32 = 159;
pub const LN_x509Crl: &[u8; 8usize] = b"x509Crl\0";
pub const NID_x509Crl: u32 = 160;
pub const SN_pbe_WithSHA1And128BitRC4: &[u8; 17usize] = b"PBE-SHA1-RC4-128\0";
pub const LN_pbe_WithSHA1And128BitRC4: &[u8; 24usize] = b"pbeWithSHA1And128BitRC4\0";
pub const NID_pbe_WithSHA1And128BitRC4: u32 = 144;
pub const SN_pbe_WithSHA1And40BitRC4: &[u8; 16usize] = b"PBE-SHA1-RC4-40\0";
pub const LN_pbe_WithSHA1And40BitRC4: &[u8; 23usize] = b"pbeWithSHA1And40BitRC4\0";
pub const NID_pbe_WithSHA1And40BitRC4: u32 = 145;
pub const SN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 14usize] = b"PBE-SHA1-3DES\0";
pub const LN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 33usize] =
    b"pbeWithSHA1And3-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC: u32 = 146;
pub const SN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 14usize] = b"PBE-SHA1-2DES\0";
pub const LN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 33usize] =
    b"pbeWithSHA1And2-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC: u32 = 147;
pub const SN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 17usize] = b"PBE-SHA1-RC2-128\0";
pub const LN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 28usize] = b"pbeWithSHA1And128BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And128BitRC2_CBC: u32 = 148;
pub const SN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 16usize] = b"PBE-SHA1-RC2-40\0";
pub const LN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 27usize] = b"pbeWithSHA1And40BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And40BitRC2_CBC: u32 = 149;
pub const LN_keyBag: &[u8; 7usize] = b"keyBag\0";
pub const NID_keyBag: u32 = 150;
pub const LN_pkcs8ShroudedKeyBag: &[u8; 20usize] = b"pkcs8ShroudedKeyBag\0";
pub const NID_pkcs8ShroudedKeyBag: u32 = 151;
pub const LN_certBag: &[u8; 8usize] = b"certBag\0";
pub const NID_certBag: u32 = 152;
pub const LN_crlBag: &[u8; 7usize] = b"crlBag\0";
pub const NID_crlBag: u32 = 153;
pub const LN_secretBag: &[u8; 10usize] = b"secretBag\0";
pub const NID_secretBag: u32 = 154;
pub const LN_safeContentsBag: &[u8; 16usize] = b"safeContentsBag\0";
pub const NID_safeContentsBag: u32 = 155;
pub const SN_md2: &[u8; 4usize] = b"MD2\0";
pub const LN_md2: &[u8; 4usize] = b"md2\0";
pub const NID_md2: u32 = 3;
pub const SN_md4: &[u8; 4usize] = b"MD4\0";
pub const LN_md4: &[u8; 4usize] = b"md4\0";
pub const NID_md4: u32 = 257;
pub const SN_md5: &[u8; 4usize] = b"MD5\0";
pub const LN_md5: &[u8; 4usize] = b"md5\0";
pub const NID_md5: u32 = 4;
pub const SN_md5_sha1: &[u8; 9usize] = b"MD5-SHA1\0";
pub const LN_md5_sha1: &[u8; 9usize] = b"md5-sha1\0";
pub const NID_md5_sha1: u32 = 114;
pub const LN_hmacWithMD5: &[u8; 12usize] = b"hmacWithMD5\0";
pub const NID_hmacWithMD5: u32 = 797;
pub const LN_hmacWithSHA1: &[u8; 13usize] = b"hmacWithSHA1\0";
pub const NID_hmacWithSHA1: u32 = 163;
pub const SN_sm2: &[u8; 4usize] = b"SM2\0";
pub const LN_sm2: &[u8; 4usize] = b"sm2\0";
pub const NID_sm2: u32 = 1172;
pub const SN_sm3: &[u8; 4usize] = b"SM3\0";
pub const LN_sm3: &[u8; 4usize] = b"sm3\0";
pub const NID_sm3: u32 = 1143;
pub const SN_sm3WithRSAEncryption: &[u8; 8usize] = b"RSA-SM3\0";
pub const LN_sm3WithRSAEncryption: &[u8; 21usize] = b"sm3WithRSAEncryption\0";
pub const NID_sm3WithRSAEncryption: u32 = 1144;
pub const LN_hmacWithSHA224: &[u8; 15usize] = b"hmacWithSHA224\0";
pub const NID_hmacWithSHA224: u32 = 798;
pub const LN_hmacWithSHA256: &[u8; 15usize] = b"hmacWithSHA256\0";
pub const NID_hmacWithSHA256: u32 = 799;
pub const LN_hmacWithSHA384: &[u8; 15usize] = b"hmacWithSHA384\0";
pub const NID_hmacWithSHA384: u32 = 800;
pub const LN_hmacWithSHA512: &[u8; 15usize] = b"hmacWithSHA512\0";
pub const NID_hmacWithSHA512: u32 = 801;
pub const LN_hmacWithSHA512_224: &[u8; 19usize] = b"hmacWithSHA512-224\0";
pub const NID_hmacWithSHA512_224: u32 = 1193;
pub const LN_hmacWithSHA512_256: &[u8; 19usize] = b"hmacWithSHA512-256\0";
pub const NID_hmacWithSHA512_256: u32 = 1194;
pub const SN_rc2_cbc: &[u8; 8usize] = b"RC2-CBC\0";
pub const LN_rc2_cbc: &[u8; 8usize] = b"rc2-cbc\0";
pub const NID_rc2_cbc: u32 = 37;
pub const SN_rc2_ecb: &[u8; 8usize] = b"RC2-ECB\0";
pub const LN_rc2_ecb: &[u8; 8usize] = b"rc2-ecb\0";
pub const NID_rc2_ecb: u32 = 38;
pub const SN_rc2_cfb64: &[u8; 8usize] = b"RC2-CFB\0";
pub const LN_rc2_cfb64: &[u8; 8usize] = b"rc2-cfb\0";
pub const NID_rc2_cfb64: u32 = 39;
pub const SN_rc2_ofb64: &[u8; 8usize] = b"RC2-OFB\0";
pub const LN_rc2_ofb64: &[u8; 8usize] = b"rc2-ofb\0";
pub const NID_rc2_ofb64: u32 = 40;
pub const SN_rc2_40_cbc: &[u8; 11usize] = b"RC2-40-CBC\0";
pub const LN_rc2_40_cbc: &[u8; 11usize] = b"rc2-40-cbc\0";
pub const NID_rc2_40_cbc: u32 = 98;
pub const SN_rc2_64_cbc: &[u8; 11usize] = b"RC2-64-CBC\0";
pub const LN_rc2_64_cbc: &[u8; 11usize] = b"rc2-64-cbc\0";
pub const NID_rc2_64_cbc: u32 = 166;
pub const SN_rc4: &[u8; 4usize] = b"RC4\0";
pub const LN_rc4: &[u8; 4usize] = b"rc4\0";
pub const NID_rc4: u32 = 5;
pub const SN_rc4_40: &[u8; 7usize] = b"RC4-40\0";
pub const LN_rc4_40: &[u8; 7usize] = b"rc4-40\0";
pub const NID_rc4_40: u32 = 97;
pub const SN_des_ede3_cbc: &[u8; 13usize] = b"DES-EDE3-CBC\0";
pub const LN_des_ede3_cbc: &[u8; 13usize] = b"des-ede3-cbc\0";
pub const NID_des_ede3_cbc: u32 = 44;
pub const SN_rc5_cbc: &[u8; 8usize] = b"RC5-CBC\0";
pub const LN_rc5_cbc: &[u8; 8usize] = b"rc5-cbc\0";
pub const NID_rc5_cbc: u32 = 120;
pub const SN_rc5_ecb: &[u8; 8usize] = b"RC5-ECB\0";
pub const LN_rc5_ecb: &[u8; 8usize] = b"rc5-ecb\0";
pub const NID_rc5_ecb: u32 = 121;
pub const SN_rc5_cfb64: &[u8; 8usize] = b"RC5-CFB\0";
pub const LN_rc5_cfb64: &[u8; 8usize] = b"rc5-cfb\0";
pub const NID_rc5_cfb64: u32 = 122;
pub const SN_rc5_ofb64: &[u8; 8usize] = b"RC5-OFB\0";
pub const LN_rc5_ofb64: &[u8; 8usize] = b"rc5-ofb\0";
pub const NID_rc5_ofb64: u32 = 123;
pub const SN_ms_ext_req: &[u8; 9usize] = b"msExtReq\0";
pub const LN_ms_ext_req: &[u8; 28usize] = b"Microsoft Extension Request\0";
pub const NID_ms_ext_req: u32 = 171;
pub const SN_ms_code_ind: &[u8; 10usize] = b"msCodeInd\0";
pub const LN_ms_code_ind: &[u8; 34usize] = b"Microsoft Individual Code Signing\0";
pub const NID_ms_code_ind: u32 = 134;
pub const SN_ms_code_com: &[u8; 10usize] = b"msCodeCom\0";
pub const LN_ms_code_com: &[u8; 34usize] = b"Microsoft Commercial Code Signing\0";
pub const NID_ms_code_com: u32 = 135;
pub const SN_ms_ctl_sign: &[u8; 10usize] = b"msCTLSign\0";
pub const LN_ms_ctl_sign: &[u8; 29usize] = b"Microsoft Trust List Signing\0";
pub const NID_ms_ctl_sign: u32 = 136;
pub const SN_ms_sgc: &[u8; 6usize] = b"msSGC\0";
pub const LN_ms_sgc: &[u8; 30usize] = b"Microsoft Server Gated Crypto\0";
pub const NID_ms_sgc: u32 = 137;
pub const SN_ms_efs: &[u8; 6usize] = b"msEFS\0";
pub const LN_ms_efs: &[u8; 32usize] = b"Microsoft Encrypted File System\0";
pub const NID_ms_efs: u32 = 138;
pub const SN_ms_smartcard_login: &[u8; 17usize] = b"msSmartcardLogin\0";
pub const LN_ms_smartcard_login: &[u8; 25usize] = b"Microsoft Smartcardlogin\0";
pub const NID_ms_smartcard_login: u32 = 648;
pub const SN_ms_upn: &[u8; 6usize] = b"msUPN\0";
pub const LN_ms_upn: &[u8; 35usize] = b"Microsoft Universal Principal Name\0";
pub const NID_ms_upn: u32 = 649;
pub const SN_idea_cbc: &[u8; 9usize] = b"IDEA-CBC\0";
pub const LN_idea_cbc: &[u8; 9usize] = b"idea-cbc\0";
pub const NID_idea_cbc: u32 = 34;
pub const SN_idea_ecb: &[u8; 9usize] = b"IDEA-ECB\0";
pub const LN_idea_ecb: &[u8; 9usize] = b"idea-ecb\0";
pub const NID_idea_ecb: u32 = 36;
pub const SN_idea_cfb64: &[u8; 9usize] = b"IDEA-CFB\0";
pub const LN_idea_cfb64: &[u8; 9usize] = b"idea-cfb\0";
pub const NID_idea_cfb64: u32 = 35;
pub const SN_idea_ofb64: &[u8; 9usize] = b"IDEA-OFB\0";
pub const LN_idea_ofb64: &[u8; 9usize] = b"idea-ofb\0";
pub const NID_idea_ofb64: u32 = 46;
pub const SN_bf_cbc: &[u8; 7usize] = b"BF-CBC\0";
pub const LN_bf_cbc: &[u8; 7usize] = b"bf-cbc\0";
pub const NID_bf_cbc: u32 = 91;
pub const SN_bf_ecb: &[u8; 7usize] = b"BF-ECB\0";
pub const LN_bf_ecb: &[u8; 7usize] = b"bf-ecb\0";
pub const NID_bf_ecb: u32 = 92;
pub const SN_bf_cfb64: &[u8; 7usize] = b"BF-CFB\0";
pub const LN_bf_cfb64: &[u8; 7usize] = b"bf-cfb\0";
pub const NID_bf_cfb64: u32 = 93;
pub const SN_bf_ofb64: &[u8; 7usize] = b"BF-OFB\0";
pub const LN_bf_ofb64: &[u8; 7usize] = b"bf-ofb\0";
pub const NID_bf_ofb64: u32 = 94;
pub const SN_id_pkix: &[u8; 5usize] = b"PKIX\0";
pub const NID_id_pkix: u32 = 127;
pub const SN_id_pkix_mod: &[u8; 12usize] = b"id-pkix-mod\0";
pub const NID_id_pkix_mod: u32 = 258;
pub const SN_id_pe: &[u8; 6usize] = b"id-pe\0";
pub const NID_id_pe: u32 = 175;
pub const SN_id_qt: &[u8; 6usize] = b"id-qt\0";
pub const NID_id_qt: u32 = 259;
pub const SN_id_kp: &[u8; 6usize] = b"id-kp\0";
pub const NID_id_kp: u32 = 128;
pub const SN_id_it: &[u8; 6usize] = b"id-it\0";
pub const NID_id_it: u32 = 260;
pub const SN_id_pkip: &[u8; 8usize] = b"id-pkip\0";
pub const NID_id_pkip: u32 = 261;
pub const SN_id_alg: &[u8; 7usize] = b"id-alg\0";
pub const NID_id_alg: u32 = 262;
pub const SN_id_cmc: &[u8; 7usize] = b"id-cmc\0";
pub const NID_id_cmc: u32 = 263;
pub const SN_id_on: &[u8; 6usize] = b"id-on\0";
pub const NID_id_on: u32 = 264;
pub const SN_id_pda: &[u8; 7usize] = b"id-pda\0";
pub const NID_id_pda: u32 = 265;
pub const SN_id_aca: &[u8; 7usize] = b"id-aca\0";
pub const NID_id_aca: u32 = 266;
pub const SN_id_qcs: &[u8; 7usize] = b"id-qcs\0";
pub const NID_id_qcs: u32 = 267;
pub const SN_id_cct: &[u8; 7usize] = b"id-cct\0";
pub const NID_id_cct: u32 = 268;
pub const SN_id_ppl: &[u8; 7usize] = b"id-ppl\0";
pub const NID_id_ppl: u32 = 662;
pub const SN_id_ad: &[u8; 6usize] = b"id-ad\0";
pub const NID_id_ad: u32 = 176;
pub const SN_id_pkix1_explicit_88: &[u8; 21usize] = b"id-pkix1-explicit-88\0";
pub const NID_id_pkix1_explicit_88: u32 = 269;
pub const SN_id_pkix1_implicit_88: &[u8; 21usize] = b"id-pkix1-implicit-88\0";
pub const NID_id_pkix1_implicit_88: u32 = 270;
pub const SN_id_pkix1_explicit_93: &[u8; 21usize] = b"id-pkix1-explicit-93\0";
pub const NID_id_pkix1_explicit_93: u32 = 271;
pub const SN_id_pkix1_implicit_93: &[u8; 21usize] = b"id-pkix1-implicit-93\0";
pub const NID_id_pkix1_implicit_93: u32 = 272;
pub const SN_id_mod_crmf: &[u8; 12usize] = b"id-mod-crmf\0";
pub const NID_id_mod_crmf: u32 = 273;
pub const SN_id_mod_cmc: &[u8; 11usize] = b"id-mod-cmc\0";
pub const NID_id_mod_cmc: u32 = 274;
pub const SN_id_mod_kea_profile_88: &[u8; 22usize] = b"id-mod-kea-profile-88\0";
pub const NID_id_mod_kea_profile_88: u32 = 275;
pub const SN_id_mod_kea_profile_93: &[u8; 22usize] = b"id-mod-kea-profile-93\0";
pub const NID_id_mod_kea_profile_93: u32 = 276;
pub const SN_id_mod_cmp: &[u8; 11usize] = b"id-mod-cmp\0";
pub const NID_id_mod_cmp: u32 = 277;
pub const SN_id_mod_qualified_cert_88: &[u8; 25usize] = b"id-mod-qualified-cert-88\0";
pub const NID_id_mod_qualified_cert_88: u32 = 278;
pub const SN_id_mod_qualified_cert_93: &[u8; 25usize] = b"id-mod-qualified-cert-93\0";
pub const NID_id_mod_qualified_cert_93: u32 = 279;
pub const SN_id_mod_attribute_cert: &[u8; 22usize] = b"id-mod-attribute-cert\0";
pub const NID_id_mod_attribute_cert: u32 = 280;
pub const SN_id_mod_timestamp_protocol: &[u8; 26usize] = b"id-mod-timestamp-protocol\0";
pub const NID_id_mod_timestamp_protocol: u32 = 281;
pub const SN_id_mod_ocsp: &[u8; 12usize] = b"id-mod-ocsp\0";
pub const NID_id_mod_ocsp: u32 = 282;
pub const SN_id_mod_dvcs: &[u8; 12usize] = b"id-mod-dvcs\0";
pub const NID_id_mod_dvcs: u32 = 283;
pub const SN_id_mod_cmp2000: &[u8; 15usize] = b"id-mod-cmp2000\0";
pub const NID_id_mod_cmp2000: u32 = 284;
pub const SN_info_access: &[u8; 20usize] = b"authorityInfoAccess\0";
pub const LN_info_access: &[u8; 29usize] = b"Authority Information Access\0";
pub const NID_info_access: u32 = 177;
pub const SN_biometricInfo: &[u8; 14usize] = b"biometricInfo\0";
pub const LN_biometricInfo: &[u8; 15usize] = b"Biometric Info\0";
pub const NID_biometricInfo: u32 = 285;
pub const SN_qcStatements: &[u8; 13usize] = b"qcStatements\0";
pub const NID_qcStatements: u32 = 286;
pub const SN_ac_auditEntity: &[u8; 15usize] = b"ac-auditEntity\0";
pub const NID_ac_auditEntity: u32 = 287;
pub const SN_ac_targeting: &[u8; 13usize] = b"ac-targeting\0";
pub const NID_ac_targeting: u32 = 288;
pub const SN_aaControls: &[u8; 11usize] = b"aaControls\0";
pub const NID_aaControls: u32 = 289;
pub const SN_sbgp_ipAddrBlock: &[u8; 17usize] = b"sbgp-ipAddrBlock\0";
pub const NID_sbgp_ipAddrBlock: u32 = 290;
pub const SN_sbgp_autonomousSysNum: &[u8; 22usize] = b"sbgp-autonomousSysNum\0";
pub const NID_sbgp_autonomousSysNum: u32 = 291;
pub const SN_sbgp_routerIdentifier: &[u8; 22usize] = b"sbgp-routerIdentifier\0";
pub const NID_sbgp_routerIdentifier: u32 = 292;
pub const SN_ac_proxying: &[u8; 12usize] = b"ac-proxying\0";
pub const NID_ac_proxying: u32 = 397;
pub const SN_sinfo_access: &[u8; 18usize] = b"subjectInfoAccess\0";
pub const LN_sinfo_access: &[u8; 27usize] = b"Subject Information Access\0";
pub const NID_sinfo_access: u32 = 398;
pub const SN_proxyCertInfo: &[u8; 14usize] = b"proxyCertInfo\0";
pub const LN_proxyCertInfo: &[u8; 30usize] = b"Proxy Certificate Information\0";
pub const NID_proxyCertInfo: u32 = 663;
pub const SN_tlsfeature: &[u8; 11usize] = b"tlsfeature\0";
pub const LN_tlsfeature: &[u8; 12usize] = b"TLS Feature\0";
pub const NID_tlsfeature: u32 = 1020;
pub const SN_id_qt_cps: &[u8; 10usize] = b"id-qt-cps\0";
pub const LN_id_qt_cps: &[u8; 21usize] = b"Policy Qualifier CPS\0";
pub const NID_id_qt_cps: u32 = 164;
pub const SN_id_qt_unotice: &[u8; 14usize] = b"id-qt-unotice\0";
pub const LN_id_qt_unotice: &[u8; 29usize] = b"Policy Qualifier User Notice\0";
pub const NID_id_qt_unotice: u32 = 165;
pub const SN_textNotice: &[u8; 11usize] = b"textNotice\0";
pub const NID_textNotice: u32 = 293;
pub const SN_server_auth: &[u8; 11usize] = b"serverAuth\0";
pub const LN_server_auth: &[u8; 30usize] = b"TLS Web Server Authentication\0";
pub const NID_server_auth: u32 = 129;
pub const SN_client_auth: &[u8; 11usize] = b"clientAuth\0";
pub const LN_client_auth: &[u8; 30usize] = b"TLS Web Client Authentication\0";
pub const NID_client_auth: u32 = 130;
pub const SN_code_sign: &[u8; 12usize] = b"codeSigning\0";
pub const LN_code_sign: &[u8; 13usize] = b"Code Signing\0";
pub const NID_code_sign: u32 = 131;
pub const SN_email_protect: &[u8; 16usize] = b"emailProtection\0";
pub const LN_email_protect: &[u8; 18usize] = b"E-mail Protection\0";
pub const NID_email_protect: u32 = 132;
pub const SN_ipsecEndSystem: &[u8; 15usize] = b"ipsecEndSystem\0";
pub const LN_ipsecEndSystem: &[u8; 17usize] = b"IPSec End System\0";
pub const NID_ipsecEndSystem: u32 = 294;
pub const SN_ipsecTunnel: &[u8; 12usize] = b"ipsecTunnel\0";
pub const LN_ipsecTunnel: &[u8; 13usize] = b"IPSec Tunnel\0";
pub const NID_ipsecTunnel: u32 = 295;
pub const SN_ipsecUser: &[u8; 10usize] = b"ipsecUser\0";
pub const LN_ipsecUser: &[u8; 11usize] = b"IPSec User\0";
pub const NID_ipsecUser: u32 = 296;
pub const SN_time_stamp: &[u8; 13usize] = b"timeStamping\0";
pub const LN_time_stamp: &[u8; 14usize] = b"Time Stamping\0";
pub const NID_time_stamp: u32 = 133;
pub const SN_OCSP_sign: &[u8; 12usize] = b"OCSPSigning\0";
pub const LN_OCSP_sign: &[u8; 13usize] = b"OCSP Signing\0";
pub const NID_OCSP_sign: u32 = 180;
pub const SN_dvcs: &[u8; 5usize] = b"DVCS\0";
pub const LN_dvcs: &[u8; 5usize] = b"dvcs\0";
pub const NID_dvcs: u32 = 297;
pub const SN_ipsec_IKE: &[u8; 9usize] = b"ipsecIKE\0";
pub const LN_ipsec_IKE: &[u8; 28usize] = b"ipsec Internet Key Exchange\0";
pub const NID_ipsec_IKE: u32 = 1022;
pub const SN_capwapAC: &[u8; 9usize] = b"capwapAC\0";
pub const LN_capwapAC: &[u8; 26usize] = b"Ctrl/provision WAP Access\0";
pub const NID_capwapAC: u32 = 1023;
pub const SN_capwapWTP: &[u8; 10usize] = b"capwapWTP\0";
pub const LN_capwapWTP: &[u8; 31usize] = b"Ctrl/Provision WAP Termination\0";
pub const NID_capwapWTP: u32 = 1024;
pub const SN_sshClient: &[u8; 18usize] = b"secureShellClient\0";
pub const LN_sshClient: &[u8; 11usize] = b"SSH Client\0";
pub const NID_sshClient: u32 = 1025;
pub const SN_sshServer: &[u8; 18usize] = b"secureShellServer\0";
pub const LN_sshServer: &[u8; 11usize] = b"SSH Server\0";
pub const NID_sshServer: u32 = 1026;
pub const SN_sendRouter: &[u8; 11usize] = b"sendRouter\0";
pub const LN_sendRouter: &[u8; 12usize] = b"Send Router\0";
pub const NID_sendRouter: u32 = 1027;
pub const SN_sendProxiedRouter: &[u8; 18usize] = b"sendProxiedRouter\0";
pub const LN_sendProxiedRouter: &[u8; 20usize] = b"Send Proxied Router\0";
pub const NID_sendProxiedRouter: u32 = 1028;
pub const SN_sendOwner: &[u8; 10usize] = b"sendOwner\0";
pub const LN_sendOwner: &[u8; 11usize] = b"Send Owner\0";
pub const NID_sendOwner: u32 = 1029;
pub const SN_sendProxiedOwner: &[u8; 17usize] = b"sendProxiedOwner\0";
pub const LN_sendProxiedOwner: &[u8; 19usize] = b"Send Proxied Owner\0";
pub const NID_sendProxiedOwner: u32 = 1030;
pub const SN_cmcCA: &[u8; 6usize] = b"cmcCA\0";
pub const LN_cmcCA: &[u8; 26usize] = b"CMC Certificate Authority\0";
pub const NID_cmcCA: u32 = 1131;
pub const SN_cmcRA: &[u8; 6usize] = b"cmcRA\0";
pub const LN_cmcRA: &[u8; 27usize] = b"CMC Registration Authority\0";
pub const NID_cmcRA: u32 = 1132;
pub const SN_id_it_caProtEncCert: &[u8; 20usize] = b"id-it-caProtEncCert\0";
pub const NID_id_it_caProtEncCert: u32 = 298;
pub const SN_id_it_signKeyPairTypes: &[u8; 23usize] = b"id-it-signKeyPairTypes\0";
pub const NID_id_it_signKeyPairTypes: u32 = 299;
pub const SN_id_it_encKeyPairTypes: &[u8; 22usize] = b"id-it-encKeyPairTypes\0";
pub const NID_id_it_encKeyPairTypes: u32 = 300;
pub const SN_id_it_preferredSymmAlg: &[u8; 23usize] = b"id-it-preferredSymmAlg\0";
pub const NID_id_it_preferredSymmAlg: u32 = 301;
pub const SN_id_it_caKeyUpdateInfo: &[u8; 22usize] = b"id-it-caKeyUpdateInfo\0";
pub const NID_id_it_caKeyUpdateInfo: u32 = 302;
pub const SN_id_it_currentCRL: &[u8; 17usize] = b"id-it-currentCRL\0";
pub const NID_id_it_currentCRL: u32 = 303;
pub const SN_id_it_unsupportedOIDs: &[u8; 22usize] = b"id-it-unsupportedOIDs\0";
pub const NID_id_it_unsupportedOIDs: u32 = 304;
pub const SN_id_it_subscriptionRequest: &[u8; 26usize] = b"id-it-subscriptionRequest\0";
pub const NID_id_it_subscriptionRequest: u32 = 305;
pub const SN_id_it_subscriptionResponse: &[u8; 27usize] = b"id-it-subscriptionResponse\0";
pub const NID_id_it_subscriptionResponse: u32 = 306;
pub const SN_id_it_keyPairParamReq: &[u8; 22usize] = b"id-it-keyPairParamReq\0";
pub const NID_id_it_keyPairParamReq: u32 = 307;
pub const SN_id_it_keyPairParamRep: &[u8; 22usize] = b"id-it-keyPairParamRep\0";
pub const NID_id_it_keyPairParamRep: u32 = 308;
pub const SN_id_it_revPassphrase: &[u8; 20usize] = b"id-it-revPassphrase\0";
pub const NID_id_it_revPassphrase: u32 = 309;
pub const SN_id_it_implicitConfirm: &[u8; 22usize] = b"id-it-implicitConfirm\0";
pub const NID_id_it_implicitConfirm: u32 = 310;
pub const SN_id_it_confirmWaitTime: &[u8; 22usize] = b"id-it-confirmWaitTime\0";
pub const NID_id_it_confirmWaitTime: u32 = 311;
pub const SN_id_it_origPKIMessage: &[u8; 21usize] = b"id-it-origPKIMessage\0";
pub const NID_id_it_origPKIMessage: u32 = 312;
pub const SN_id_it_suppLangTags: &[u8; 19usize] = b"id-it-suppLangTags\0";
pub const NID_id_it_suppLangTags: u32 = 784;
pub const SN_id_regCtrl: &[u8; 11usize] = b"id-regCtrl\0";
pub const NID_id_regCtrl: u32 = 313;
pub const SN_id_regInfo: &[u8; 11usize] = b"id-regInfo\0";
pub const NID_id_regInfo: u32 = 314;
pub const SN_id_regCtrl_regToken: &[u8; 20usize] = b"id-regCtrl-regToken\0";
pub const NID_id_regCtrl_regToken: u32 = 315;
pub const SN_id_regCtrl_authenticator: &[u8; 25usize] = b"id-regCtrl-authenticator\0";
pub const NID_id_regCtrl_authenticator: u32 = 316;
pub const SN_id_regCtrl_pkiPublicationInfo: &[u8; 30usize] = b"id-regCtrl-pkiPublicationInfo\0";
pub const NID_id_regCtrl_pkiPublicationInfo: u32 = 317;
pub const SN_id_regCtrl_pkiArchiveOptions: &[u8; 29usize] = b"id-regCtrl-pkiArchiveOptions\0";
pub const NID_id_regCtrl_pkiArchiveOptions: u32 = 318;
pub const SN_id_regCtrl_oldCertID: &[u8; 21usize] = b"id-regCtrl-oldCertID\0";
pub const NID_id_regCtrl_oldCertID: u32 = 319;
pub const SN_id_regCtrl_protocolEncrKey: &[u8; 27usize] = b"id-regCtrl-protocolEncrKey\0";
pub const NID_id_regCtrl_protocolEncrKey: u32 = 320;
pub const SN_id_regInfo_utf8Pairs: &[u8; 21usize] = b"id-regInfo-utf8Pairs\0";
pub const NID_id_regInfo_utf8Pairs: u32 = 321;
pub const SN_id_regInfo_certReq: &[u8; 19usize] = b"id-regInfo-certReq\0";
pub const NID_id_regInfo_certReq: u32 = 322;
pub const SN_id_alg_des40: &[u8; 13usize] = b"id-alg-des40\0";
pub const NID_id_alg_des40: u32 = 323;
pub const SN_id_alg_noSignature: &[u8; 19usize] = b"id-alg-noSignature\0";
pub const NID_id_alg_noSignature: u32 = 324;
pub const SN_id_alg_dh_sig_hmac_sha1: &[u8; 24usize] = b"id-alg-dh-sig-hmac-sha1\0";
pub const NID_id_alg_dh_sig_hmac_sha1: u32 = 325;
pub const SN_id_alg_dh_pop: &[u8; 14usize] = b"id-alg-dh-pop\0";
pub const NID_id_alg_dh_pop: u32 = 326;
pub const SN_id_cmc_statusInfo: &[u8; 18usize] = b"id-cmc-statusInfo\0";
pub const NID_id_cmc_statusInfo: u32 = 327;
pub const SN_id_cmc_identification: &[u8; 22usize] = b"id-cmc-identification\0";
pub const NID_id_cmc_identification: u32 = 328;
pub const SN_id_cmc_identityProof: &[u8; 21usize] = b"id-cmc-identityProof\0";
pub const NID_id_cmc_identityProof: u32 = 329;
pub const SN_id_cmc_dataReturn: &[u8; 18usize] = b"id-cmc-dataReturn\0";
pub const NID_id_cmc_dataReturn: u32 = 330;
pub const SN_id_cmc_transactionId: &[u8; 21usize] = b"id-cmc-transactionId\0";
pub const NID_id_cmc_transactionId: u32 = 331;
pub const SN_id_cmc_senderNonce: &[u8; 19usize] = b"id-cmc-senderNonce\0";
pub const NID_id_cmc_senderNonce: u32 = 332;
pub const SN_id_cmc_recipientNonce: &[u8; 22usize] = b"id-cmc-recipientNonce\0";
pub const NID_id_cmc_recipientNonce: u32 = 333;
pub const SN_id_cmc_addExtensions: &[u8; 21usize] = b"id-cmc-addExtensions\0";
pub const NID_id_cmc_addExtensions: u32 = 334;
pub const SN_id_cmc_encryptedPOP: &[u8; 20usize] = b"id-cmc-encryptedPOP\0";
pub const NID_id_cmc_encryptedPOP: u32 = 335;
pub const SN_id_cmc_decryptedPOP: &[u8; 20usize] = b"id-cmc-decryptedPOP\0";
pub const NID_id_cmc_decryptedPOP: u32 = 336;
pub const SN_id_cmc_lraPOPWitness: &[u8; 21usize] = b"id-cmc-lraPOPWitness\0";
pub const NID_id_cmc_lraPOPWitness: u32 = 337;
pub const SN_id_cmc_getCert: &[u8; 15usize] = b"id-cmc-getCert\0";
pub const NID_id_cmc_getCert: u32 = 338;
pub const SN_id_cmc_getCRL: &[u8; 14usize] = b"id-cmc-getCRL\0";
pub const NID_id_cmc_getCRL: u32 = 339;
pub const SN_id_cmc_revokeRequest: &[u8; 21usize] = b"id-cmc-revokeRequest\0";
pub const NID_id_cmc_revokeRequest: u32 = 340;
pub const SN_id_cmc_regInfo: &[u8; 15usize] = b"id-cmc-regInfo\0";
pub const NID_id_cmc_regInfo: u32 = 341;
pub const SN_id_cmc_responseInfo: &[u8; 20usize] = b"id-cmc-responseInfo\0";
pub const NID_id_cmc_responseInfo: u32 = 342;
pub const SN_id_cmc_queryPending: &[u8; 20usize] = b"id-cmc-queryPending\0";
pub const NID_id_cmc_queryPending: u32 = 343;
pub const SN_id_cmc_popLinkRandom: &[u8; 21usize] = b"id-cmc-popLinkRandom\0";
pub const NID_id_cmc_popLinkRandom: u32 = 344;
pub const SN_id_cmc_popLinkWitness: &[u8; 22usize] = b"id-cmc-popLinkWitness\0";
pub const NID_id_cmc_popLinkWitness: u32 = 345;
pub const SN_id_cmc_confirmCertAcceptance: &[u8; 29usize] = b"id-cmc-confirmCertAcceptance\0";
pub const NID_id_cmc_confirmCertAcceptance: u32 = 346;
pub const SN_id_on_personalData: &[u8; 19usize] = b"id-on-personalData\0";
pub const NID_id_on_personalData: u32 = 347;
pub const SN_id_on_permanentIdentifier: &[u8; 26usize] = b"id-on-permanentIdentifier\0";
pub const LN_id_on_permanentIdentifier: &[u8; 21usize] = b"Permanent Identifier\0";
pub const NID_id_on_permanentIdentifier: u32 = 858;
pub const SN_id_pda_dateOfBirth: &[u8; 19usize] = b"id-pda-dateOfBirth\0";
pub const NID_id_pda_dateOfBirth: u32 = 348;
pub const SN_id_pda_placeOfBirth: &[u8; 20usize] = b"id-pda-placeOfBirth\0";
pub const NID_id_pda_placeOfBirth: u32 = 349;
pub const SN_id_pda_gender: &[u8; 14usize] = b"id-pda-gender\0";
pub const NID_id_pda_gender: u32 = 351;
pub const SN_id_pda_countryOfCitizenship: &[u8; 28usize] = b"id-pda-countryOfCitizenship\0";
pub const NID_id_pda_countryOfCitizenship: u32 = 352;
pub const SN_id_pda_countryOfResidence: &[u8; 26usize] = b"id-pda-countryOfResidence\0";
pub const NID_id_pda_countryOfResidence: u32 = 353;
pub const SN_id_aca_authenticationInfo: &[u8; 26usize] = b"id-aca-authenticationInfo\0";
pub const NID_id_aca_authenticationInfo: u32 = 354;
pub const SN_id_aca_accessIdentity: &[u8; 22usize] = b"id-aca-accessIdentity\0";
pub const NID_id_aca_accessIdentity: u32 = 355;
pub const SN_id_aca_chargingIdentity: &[u8; 24usize] = b"id-aca-chargingIdentity\0";
pub const NID_id_aca_chargingIdentity: u32 = 356;
pub const SN_id_aca_group: &[u8; 13usize] = b"id-aca-group\0";
pub const NID_id_aca_group: u32 = 357;
pub const SN_id_aca_role: &[u8; 12usize] = b"id-aca-role\0";
pub const NID_id_aca_role: u32 = 358;
pub const SN_id_aca_encAttrs: &[u8; 16usize] = b"id-aca-encAttrs\0";
pub const NID_id_aca_encAttrs: u32 = 399;
pub const SN_id_qcs_pkixQCSyntax_v1: &[u8; 23usize] = b"id-qcs-pkixQCSyntax-v1\0";
pub const NID_id_qcs_pkixQCSyntax_v1: u32 = 359;
pub const SN_id_cct_crs: &[u8; 11usize] = b"id-cct-crs\0";
pub const NID_id_cct_crs: u32 = 360;
pub const SN_id_cct_PKIData: &[u8; 15usize] = b"id-cct-PKIData\0";
pub const NID_id_cct_PKIData: u32 = 361;
pub const SN_id_cct_PKIResponse: &[u8; 19usize] = b"id-cct-PKIResponse\0";
pub const NID_id_cct_PKIResponse: u32 = 362;
pub const SN_id_ppl_anyLanguage: &[u8; 19usize] = b"id-ppl-anyLanguage\0";
pub const LN_id_ppl_anyLanguage: &[u8; 13usize] = b"Any language\0";
pub const NID_id_ppl_anyLanguage: u32 = 664;
pub const SN_id_ppl_inheritAll: &[u8; 18usize] = b"id-ppl-inheritAll\0";
pub const LN_id_ppl_inheritAll: &[u8; 12usize] = b"Inherit all\0";
pub const NID_id_ppl_inheritAll: u32 = 665;
pub const SN_Independent: &[u8; 19usize] = b"id-ppl-independent\0";
pub const LN_Independent: &[u8; 12usize] = b"Independent\0";
pub const NID_Independent: u32 = 667;
pub const SN_ad_OCSP: &[u8; 5usize] = b"OCSP\0";
pub const LN_ad_OCSP: &[u8; 5usize] = b"OCSP\0";
pub const NID_ad_OCSP: u32 = 178;
pub const SN_ad_ca_issuers: &[u8; 10usize] = b"caIssuers\0";
pub const LN_ad_ca_issuers: &[u8; 11usize] = b"CA Issuers\0";
pub const NID_ad_ca_issuers: u32 = 179;
pub const SN_ad_timeStamping: &[u8; 16usize] = b"ad_timestamping\0";
pub const LN_ad_timeStamping: &[u8; 17usize] = b"AD Time Stamping\0";
pub const NID_ad_timeStamping: u32 = 363;
pub const SN_ad_dvcs: &[u8; 8usize] = b"AD_DVCS\0";
pub const LN_ad_dvcs: &[u8; 8usize] = b"ad dvcs\0";
pub const NID_ad_dvcs: u32 = 364;
pub const SN_caRepository: &[u8; 13usize] = b"caRepository\0";
pub const LN_caRepository: &[u8; 14usize] = b"CA Repository\0";
pub const NID_caRepository: u32 = 785;
pub const SN_id_pkix_OCSP_basic: &[u8; 18usize] = b"basicOCSPResponse\0";
pub const LN_id_pkix_OCSP_basic: &[u8; 20usize] = b"Basic OCSP Response\0";
pub const NID_id_pkix_OCSP_basic: u32 = 365;
pub const SN_id_pkix_OCSP_Nonce: &[u8; 6usize] = b"Nonce\0";
pub const LN_id_pkix_OCSP_Nonce: &[u8; 11usize] = b"OCSP Nonce\0";
pub const NID_id_pkix_OCSP_Nonce: u32 = 366;
pub const SN_id_pkix_OCSP_CrlID: &[u8; 6usize] = b"CrlID\0";
pub const LN_id_pkix_OCSP_CrlID: &[u8; 12usize] = b"OCSP CRL ID\0";
pub const NID_id_pkix_OCSP_CrlID: u32 = 367;
pub const SN_id_pkix_OCSP_acceptableResponses: &[u8; 20usize] = b"acceptableResponses\0";
pub const LN_id_pkix_OCSP_acceptableResponses: &[u8; 26usize] = b"Acceptable OCSP Responses\0";
pub const NID_id_pkix_OCSP_acceptableResponses: u32 = 368;
pub const SN_id_pkix_OCSP_noCheck: &[u8; 8usize] = b"noCheck\0";
pub const LN_id_pkix_OCSP_noCheck: &[u8; 14usize] = b"OCSP No Check\0";
pub const NID_id_pkix_OCSP_noCheck: u32 = 369;
pub const SN_id_pkix_OCSP_archiveCutoff: &[u8; 14usize] = b"archiveCutoff\0";
pub const LN_id_pkix_OCSP_archiveCutoff: &[u8; 20usize] = b"OCSP Archive Cutoff\0";
pub const NID_id_pkix_OCSP_archiveCutoff: u32 = 370;
pub const SN_id_pkix_OCSP_serviceLocator: &[u8; 15usize] = b"serviceLocator\0";
pub const LN_id_pkix_OCSP_serviceLocator: &[u8; 21usize] = b"OCSP Service Locator\0";
pub const NID_id_pkix_OCSP_serviceLocator: u32 = 371;
pub const SN_id_pkix_OCSP_extendedStatus: &[u8; 15usize] = b"extendedStatus\0";
pub const LN_id_pkix_OCSP_extendedStatus: &[u8; 21usize] = b"Extended OCSP Status\0";
pub const NID_id_pkix_OCSP_extendedStatus: u32 = 372;
pub const SN_id_pkix_OCSP_valid: &[u8; 6usize] = b"valid\0";
pub const NID_id_pkix_OCSP_valid: u32 = 373;
pub const SN_id_pkix_OCSP_path: &[u8; 5usize] = b"path\0";
pub const NID_id_pkix_OCSP_path: u32 = 374;
pub const SN_id_pkix_OCSP_trustRoot: &[u8; 10usize] = b"trustRoot\0";
pub const LN_id_pkix_OCSP_trustRoot: &[u8; 11usize] = b"Trust Root\0";
pub const NID_id_pkix_OCSP_trustRoot: u32 = 375;
pub const SN_algorithm: &[u8; 10usize] = b"algorithm\0";
pub const LN_algorithm: &[u8; 10usize] = b"algorithm\0";
pub const NID_algorithm: u32 = 376;
pub const SN_md5WithRSA: &[u8; 11usize] = b"RSA-NP-MD5\0";
pub const LN_md5WithRSA: &[u8; 11usize] = b"md5WithRSA\0";
pub const NID_md5WithRSA: u32 = 104;
pub const SN_des_ecb: &[u8; 8usize] = b"DES-ECB\0";
pub const LN_des_ecb: &[u8; 8usize] = b"des-ecb\0";
pub const NID_des_ecb: u32 = 29;
pub const SN_des_cbc: &[u8; 8usize] = b"DES-CBC\0";
pub const LN_des_cbc: &[u8; 8usize] = b"des-cbc\0";
pub const NID_des_cbc: u32 = 31;
pub const SN_des_ofb64: &[u8; 8usize] = b"DES-OFB\0";
pub const LN_des_ofb64: &[u8; 8usize] = b"des-ofb\0";
pub const NID_des_ofb64: u32 = 45;
pub const SN_des_cfb64: &[u8; 8usize] = b"DES-CFB\0";
pub const LN_des_cfb64: &[u8; 8usize] = b"des-cfb\0";
pub const NID_des_cfb64: u32 = 30;
pub const SN_rsaSignature: &[u8; 13usize] = b"rsaSignature\0";
pub const NID_rsaSignature: u32 = 377;
pub const SN_dsa_2: &[u8; 8usize] = b"DSA-old\0";
pub const LN_dsa_2: &[u8; 18usize] = b"dsaEncryption-old\0";
pub const NID_dsa_2: u32 = 67;
pub const SN_dsaWithSHA: &[u8; 8usize] = b"DSA-SHA\0";
pub const LN_dsaWithSHA: &[u8; 11usize] = b"dsaWithSHA\0";
pub const NID_dsaWithSHA: u32 = 66;
pub const SN_shaWithRSAEncryption: &[u8; 8usize] = b"RSA-SHA\0";
pub const LN_shaWithRSAEncryption: &[u8; 21usize] = b"shaWithRSAEncryption\0";
pub const NID_shaWithRSAEncryption: u32 = 42;
pub const SN_des_ede_ecb: &[u8; 8usize] = b"DES-EDE\0";
pub const LN_des_ede_ecb: &[u8; 8usize] = b"des-ede\0";
pub const NID_des_ede_ecb: u32 = 32;
pub const SN_des_ede3_ecb: &[u8; 9usize] = b"DES-EDE3\0";
pub const LN_des_ede3_ecb: &[u8; 9usize] = b"des-ede3\0";
pub const NID_des_ede3_ecb: u32 = 33;
pub const SN_des_ede_cbc: &[u8; 12usize] = b"DES-EDE-CBC\0";
pub const LN_des_ede_cbc: &[u8; 12usize] = b"des-ede-cbc\0";
pub const NID_des_ede_cbc: u32 = 43;
pub const SN_des_ede_cfb64: &[u8; 12usize] = b"DES-EDE-CFB\0";
pub const LN_des_ede_cfb64: &[u8; 12usize] = b"des-ede-cfb\0";
pub const NID_des_ede_cfb64: u32 = 60;
pub const SN_des_ede3_cfb64: &[u8; 13usize] = b"DES-EDE3-CFB\0";
pub const LN_des_ede3_cfb64: &[u8; 13usize] = b"des-ede3-cfb\0";
pub const NID_des_ede3_cfb64: u32 = 61;
pub const SN_des_ede_ofb64: &[u8; 12usize] = b"DES-EDE-OFB\0";
pub const LN_des_ede_ofb64: &[u8; 12usize] = b"des-ede-ofb\0";
pub const NID_des_ede_ofb64: u32 = 62;
pub const SN_des_ede3_ofb64: &[u8; 13usize] = b"DES-EDE3-OFB\0";
pub const LN_des_ede3_ofb64: &[u8; 13usize] = b"des-ede3-ofb\0";
pub const NID_des_ede3_ofb64: u32 = 63;
pub const SN_desx_cbc: &[u8; 9usize] = b"DESX-CBC\0";
pub const LN_desx_cbc: &[u8; 9usize] = b"desx-cbc\0";
pub const NID_desx_cbc: u32 = 80;
pub const SN_sha: &[u8; 4usize] = b"SHA\0";
pub const LN_sha: &[u8; 4usize] = b"sha\0";
pub const NID_sha: u32 = 41;
pub const SN_sha1: &[u8; 5usize] = b"SHA1\0";
pub const LN_sha1: &[u8; 5usize] = b"sha1\0";
pub const NID_sha1: u32 = 64;
pub const SN_dsaWithSHA1_2: &[u8; 13usize] = b"DSA-SHA1-old\0";
pub const LN_dsaWithSHA1_2: &[u8; 16usize] = b"dsaWithSHA1-old\0";
pub const NID_dsaWithSHA1_2: u32 = 70;
pub const SN_sha1WithRSA: &[u8; 11usize] = b"RSA-SHA1-2\0";
pub const LN_sha1WithRSA: &[u8; 12usize] = b"sha1WithRSA\0";
pub const NID_sha1WithRSA: u32 = 115;
pub const SN_ripemd160: &[u8; 10usize] = b"RIPEMD160\0";
pub const LN_ripemd160: &[u8; 10usize] = b"ripemd160\0";
pub const NID_ripemd160: u32 = 117;
pub const SN_ripemd160WithRSA: &[u8; 14usize] = b"RSA-RIPEMD160\0";
pub const LN_ripemd160WithRSA: &[u8; 17usize] = b"ripemd160WithRSA\0";
pub const NID_ripemd160WithRSA: u32 = 119;
pub const SN_blake2b512: &[u8; 11usize] = b"BLAKE2b512\0";
pub const LN_blake2b512: &[u8; 11usize] = b"blake2b512\0";
pub const NID_blake2b512: u32 = 1056;
pub const SN_blake2s256: &[u8; 11usize] = b"BLAKE2s256\0";
pub const LN_blake2s256: &[u8; 11usize] = b"blake2s256\0";
pub const NID_blake2s256: u32 = 1057;
pub const SN_sxnet: &[u8; 8usize] = b"SXNetID\0";
pub const LN_sxnet: &[u8; 19usize] = b"Strong Extranet ID\0";
pub const NID_sxnet: u32 = 143;
pub const SN_X500: &[u8; 5usize] = b"X500\0";
pub const LN_X500: &[u8; 27usize] = b"directory services (X.500)\0";
pub const NID_X500: u32 = 11;
pub const SN_X509: &[u8; 5usize] = b"X509\0";
pub const NID_X509: u32 = 12;
pub const SN_commonName: &[u8; 3usize] = b"CN\0";
pub const LN_commonName: &[u8; 11usize] = b"commonName\0";
pub const NID_commonName: u32 = 13;
pub const SN_surname: &[u8; 3usize] = b"SN\0";
pub const LN_surname: &[u8; 8usize] = b"surname\0";
pub const NID_surname: u32 = 100;
pub const LN_serialNumber: &[u8; 13usize] = b"serialNumber\0";
pub const NID_serialNumber: u32 = 105;
pub const SN_countryName: &[u8; 2usize] = b"C\0";
pub const LN_countryName: &[u8; 12usize] = b"countryName\0";
pub const NID_countryName: u32 = 14;
pub const SN_localityName: &[u8; 2usize] = b"L\0";
pub const LN_localityName: &[u8; 13usize] = b"localityName\0";
pub const NID_localityName: u32 = 15;
pub const SN_stateOrProvinceName: &[u8; 3usize] = b"ST\0";
pub const LN_stateOrProvinceName: &[u8; 20usize] = b"stateOrProvinceName\0";
pub const NID_stateOrProvinceName: u32 = 16;
pub const SN_streetAddress: &[u8; 7usize] = b"street\0";
pub const LN_streetAddress: &[u8; 14usize] = b"streetAddress\0";
pub const NID_streetAddress: u32 = 660;
pub const SN_organizationName: &[u8; 2usize] = b"O\0";
pub const LN_organizationName: &[u8; 17usize] = b"organizationName\0";
pub const NID_organizationName: u32 = 17;
pub const SN_organizationalUnitName: &[u8; 3usize] = b"OU\0";
pub const LN_organizationalUnitName: &[u8; 23usize] = b"organizationalUnitName\0";
pub const NID_organizationalUnitName: u32 = 18;
pub const SN_title: &[u8; 6usize] = b"title\0";
pub const LN_title: &[u8; 6usize] = b"title\0";
pub const NID_title: u32 = 106;
pub const LN_description: &[u8; 12usize] = b"description\0";
pub const NID_description: u32 = 107;
pub const LN_searchGuide: &[u8; 12usize] = b"searchGuide\0";
pub const NID_searchGuide: u32 = 859;
pub const LN_businessCategory: &[u8; 17usize] = b"businessCategory\0";
pub const NID_businessCategory: u32 = 860;
pub const LN_postalAddress: &[u8; 14usize] = b"postalAddress\0";
pub const NID_postalAddress: u32 = 861;
pub const LN_postalCode: &[u8; 11usize] = b"postalCode\0";
pub const NID_postalCode: u32 = 661;
pub const LN_postOfficeBox: &[u8; 14usize] = b"postOfficeBox\0";
pub const NID_postOfficeBox: u32 = 862;
pub const LN_physicalDeliveryOfficeName: &[u8; 27usize] = b"physicalDeliveryOfficeName\0";
pub const NID_physicalDeliveryOfficeName: u32 = 863;
pub const LN_telephoneNumber: &[u8; 16usize] = b"telephoneNumber\0";
pub const NID_telephoneNumber: u32 = 864;
pub const LN_telexNumber: &[u8; 12usize] = b"telexNumber\0";
pub const NID_telexNumber: u32 = 865;
pub const LN_teletexTerminalIdentifier: &[u8; 26usize] = b"teletexTerminalIdentifier\0";
pub const NID_teletexTerminalIdentifier: u32 = 866;
pub const LN_facsimileTelephoneNumber: &[u8; 25usize] = b"facsimileTelephoneNumber\0";
pub const NID_facsimileTelephoneNumber: u32 = 867;
pub const LN_x121Address: &[u8; 12usize] = b"x121Address\0";
pub const NID_x121Address: u32 = 868;
pub const LN_internationaliSDNNumber: &[u8; 24usize] = b"internationaliSDNNumber\0";
pub const NID_internationaliSDNNumber: u32 = 869;
pub const LN_registeredAddress: &[u8; 18usize] = b"registeredAddress\0";
pub const NID_registeredAddress: u32 = 870;
pub const LN_destinationIndicator: &[u8; 21usize] = b"destinationIndicator\0";
pub const NID_destinationIndicator: u32 = 871;
pub const LN_preferredDeliveryMethod: &[u8; 24usize] = b"preferredDeliveryMethod\0";
pub const NID_preferredDeliveryMethod: u32 = 872;
pub const LN_presentationAddress: &[u8; 20usize] = b"presentationAddress\0";
pub const NID_presentationAddress: u32 = 873;
pub const LN_supportedApplicationContext: &[u8; 28usize] = b"supportedApplicationContext\0";
pub const NID_supportedApplicationContext: u32 = 874;
pub const SN_member: &[u8; 7usize] = b"member\0";
pub const NID_member: u32 = 875;
pub const SN_owner: &[u8; 6usize] = b"owner\0";
pub const NID_owner: u32 = 876;
pub const LN_roleOccupant: &[u8; 13usize] = b"roleOccupant\0";
pub const NID_roleOccupant: u32 = 877;
pub const SN_seeAlso: &[u8; 8usize] = b"seeAlso\0";
pub const NID_seeAlso: u32 = 878;
pub const LN_userPassword: &[u8; 13usize] = b"userPassword\0";
pub const NID_userPassword: u32 = 879;
pub const LN_userCertificate: &[u8; 16usize] = b"userCertificate\0";
pub const NID_userCertificate: u32 = 880;
pub const LN_cACertificate: &[u8; 14usize] = b"cACertificate\0";
pub const NID_cACertificate: u32 = 881;
pub const LN_authorityRevocationList: &[u8; 24usize] = b"authorityRevocationList\0";
pub const NID_authorityRevocationList: u32 = 882;
pub const LN_certificateRevocationList: &[u8; 26usize] = b"certificateRevocationList\0";
pub const NID_certificateRevocationList: u32 = 883;
pub const LN_crossCertificatePair: &[u8; 21usize] = b"crossCertificatePair\0";
pub const NID_crossCertificatePair: u32 = 884;
pub const SN_name: &[u8; 5usize] = b"name\0";
pub const LN_name: &[u8; 5usize] = b"name\0";
pub const NID_name: u32 = 173;
pub const SN_givenName: &[u8; 3usize] = b"GN\0";
pub const LN_givenName: &[u8; 10usize] = b"givenName\0";
pub const NID_givenName: u32 = 99;
pub const SN_initials: &[u8; 9usize] = b"initials\0";
pub const LN_initials: &[u8; 9usize] = b"initials\0";
pub const NID_initials: u32 = 101;
pub const LN_generationQualifier: &[u8; 20usize] = b"generationQualifier\0";
pub const NID_generationQualifier: u32 = 509;
pub const LN_x500UniqueIdentifier: &[u8; 21usize] = b"x500UniqueIdentifier\0";
pub const NID_x500UniqueIdentifier: u32 = 503;
pub const SN_dnQualifier: &[u8; 12usize] = b"dnQualifier\0";
pub const LN_dnQualifier: &[u8; 12usize] = b"dnQualifier\0";
pub const NID_dnQualifier: u32 = 174;
pub const LN_enhancedSearchGuide: &[u8; 20usize] = b"enhancedSearchGuide\0";
pub const NID_enhancedSearchGuide: u32 = 885;
pub const LN_protocolInformation: &[u8; 20usize] = b"protocolInformation\0";
pub const NID_protocolInformation: u32 = 886;
pub const LN_distinguishedName: &[u8; 18usize] = b"distinguishedName\0";
pub const NID_distinguishedName: u32 = 887;
pub const LN_uniqueMember: &[u8; 13usize] = b"uniqueMember\0";
pub const NID_uniqueMember: u32 = 888;
pub const LN_houseIdentifier: &[u8; 16usize] = b"houseIdentifier\0";
pub const NID_houseIdentifier: u32 = 889;
pub const LN_supportedAlgorithms: &[u8; 20usize] = b"supportedAlgorithms\0";
pub const NID_supportedAlgorithms: u32 = 890;
pub const LN_deltaRevocationList: &[u8; 20usize] = b"deltaRevocationList\0";
pub const NID_deltaRevocationList: u32 = 891;
pub const SN_dmdName: &[u8; 8usize] = b"dmdName\0";
pub const NID_dmdName: u32 = 892;
pub const LN_pseudonym: &[u8; 10usize] = b"pseudonym\0";
pub const NID_pseudonym: u32 = 510;
pub const SN_role: &[u8; 5usize] = b"role\0";
pub const LN_role: &[u8; 5usize] = b"role\0";
pub const NID_role: u32 = 400;
pub const LN_organizationIdentifier: &[u8; 23usize] = b"organizationIdentifier\0";
pub const NID_organizationIdentifier: u32 = 1089;
pub const SN_countryCode3c: &[u8; 3usize] = b"c3\0";
pub const LN_countryCode3c: &[u8; 14usize] = b"countryCode3c\0";
pub const NID_countryCode3c: u32 = 1090;
pub const SN_countryCode3n: &[u8; 3usize] = b"n3\0";
pub const LN_countryCode3n: &[u8; 14usize] = b"countryCode3n\0";
pub const NID_countryCode3n: u32 = 1091;
pub const LN_dnsName: &[u8; 8usize] = b"dnsName\0";
pub const NID_dnsName: u32 = 1092;
pub const SN_X500algorithms: &[u8; 15usize] = b"X500algorithms\0";
pub const LN_X500algorithms: &[u8; 32usize] = b"directory services - algorithms\0";
pub const NID_X500algorithms: u32 = 378;
pub const SN_rsa: &[u8; 4usize] = b"RSA\0";
pub const LN_rsa: &[u8; 4usize] = b"rsa\0";
pub const NID_rsa: u32 = 19;
pub const SN_mdc2WithRSA: &[u8; 9usize] = b"RSA-MDC2\0";
pub const LN_mdc2WithRSA: &[u8; 12usize] = b"mdc2WithRSA\0";
pub const NID_mdc2WithRSA: u32 = 96;
pub const SN_mdc2: &[u8; 5usize] = b"MDC2\0";
pub const LN_mdc2: &[u8; 5usize] = b"mdc2\0";
pub const NID_mdc2: u32 = 95;
pub const SN_id_ce: &[u8; 6usize] = b"id-ce\0";
pub const NID_id_ce: u32 = 81;
pub const SN_subject_directory_attributes: &[u8; 27usize] = b"subjectDirectoryAttributes\0";
pub const LN_subject_directory_attributes: &[u8; 36usize] =
    b"X509v3 Subject Directory Attributes\0";
pub const NID_subject_directory_attributes: u32 = 769;
pub const SN_subject_key_identifier: &[u8; 21usize] = b"subjectKeyIdentifier\0";
pub const LN_subject_key_identifier: &[u8; 30usize] = b"X509v3 Subject Key Identifier\0";
pub const NID_subject_key_identifier: u32 = 82;
pub const SN_key_usage: &[u8; 9usize] = b"keyUsage\0";
pub const LN_key_usage: &[u8; 17usize] = b"X509v3 Key Usage\0";
pub const NID_key_usage: u32 = 83;
pub const SN_private_key_usage_period: &[u8; 22usize] = b"privateKeyUsagePeriod\0";
pub const LN_private_key_usage_period: &[u8; 32usize] = b"X509v3 Private Key Usage Period\0";
pub const NID_private_key_usage_period: u32 = 84;
pub const SN_subject_alt_name: &[u8; 15usize] = b"subjectAltName\0";
pub const LN_subject_alt_name: &[u8; 32usize] = b"X509v3 Subject Alternative Name\0";
pub const NID_subject_alt_name: u32 = 85;
pub const SN_issuer_alt_name: &[u8; 14usize] = b"issuerAltName\0";
pub const LN_issuer_alt_name: &[u8; 31usize] = b"X509v3 Issuer Alternative Name\0";
pub const NID_issuer_alt_name: u32 = 86;
pub const SN_basic_constraints: &[u8; 17usize] = b"basicConstraints\0";
pub const LN_basic_constraints: &[u8; 25usize] = b"X509v3 Basic Constraints\0";
pub const NID_basic_constraints: u32 = 87;
pub const SN_crl_number: &[u8; 10usize] = b"crlNumber\0";
pub const LN_crl_number: &[u8; 18usize] = b"X509v3 CRL Number\0";
pub const NID_crl_number: u32 = 88;
pub const SN_crl_reason: &[u8; 10usize] = b"CRLReason\0";
pub const LN_crl_reason: &[u8; 23usize] = b"X509v3 CRL Reason Code\0";
pub const NID_crl_reason: u32 = 141;
pub const SN_invalidity_date: &[u8; 15usize] = b"invalidityDate\0";
pub const LN_invalidity_date: &[u8; 16usize] = b"Invalidity Date\0";
pub const NID_invalidity_date: u32 = 142;
pub const SN_delta_crl: &[u8; 9usize] = b"deltaCRL\0";
pub const LN_delta_crl: &[u8; 27usize] = b"X509v3 Delta CRL Indicator\0";
pub const NID_delta_crl: u32 = 140;
pub const SN_issuing_distribution_point: &[u8; 25usize] = b"issuingDistributionPoint\0";
pub const LN_issuing_distribution_point: &[u8; 34usize] = b"X509v3 Issuing Distribution Point\0";
pub const NID_issuing_distribution_point: u32 = 770;
pub const SN_certificate_issuer: &[u8; 18usize] = b"certificateIssuer\0";
pub const LN_certificate_issuer: &[u8; 26usize] = b"X509v3 Certificate Issuer\0";
pub const NID_certificate_issuer: u32 = 771;
pub const SN_name_constraints: &[u8; 16usize] = b"nameConstraints\0";
pub const LN_name_constraints: &[u8; 24usize] = b"X509v3 Name Constraints\0";
pub const NID_name_constraints: u32 = 666;
pub const SN_crl_distribution_points: &[u8; 22usize] = b"crlDistributionPoints\0";
pub const LN_crl_distribution_points: &[u8; 31usize] = b"X509v3 CRL Distribution Points\0";
pub const NID_crl_distribution_points: u32 = 103;
pub const SN_certificate_policies: &[u8; 20usize] = b"certificatePolicies\0";
pub const LN_certificate_policies: &[u8; 28usize] = b"X509v3 Certificate Policies\0";
pub const NID_certificate_policies: u32 = 89;
pub const SN_any_policy: &[u8; 10usize] = b"anyPolicy\0";
pub const LN_any_policy: &[u8; 18usize] = b"X509v3 Any Policy\0";
pub const NID_any_policy: u32 = 746;
pub const SN_policy_mappings: &[u8; 15usize] = b"policyMappings\0";
pub const LN_policy_mappings: &[u8; 23usize] = b"X509v3 Policy Mappings\0";
pub const NID_policy_mappings: u32 = 747;
pub const SN_authority_key_identifier: &[u8; 23usize] = b"authorityKeyIdentifier\0";
pub const LN_authority_key_identifier: &[u8; 32usize] = b"X509v3 Authority Key Identifier\0";
pub const NID_authority_key_identifier: u32 = 90;
pub const SN_policy_constraints: &[u8; 18usize] = b"policyConstraints\0";
pub const LN_policy_constraints: &[u8; 26usize] = b"X509v3 Policy Constraints\0";
pub const NID_policy_constraints: u32 = 401;
pub const SN_ext_key_usage: &[u8; 17usize] = b"extendedKeyUsage\0";
pub const LN_ext_key_usage: &[u8; 26usize] = b"X509v3 Extended Key Usage\0";
pub const NID_ext_key_usage: u32 = 126;
pub const SN_freshest_crl: &[u8; 12usize] = b"freshestCRL\0";
pub const LN_freshest_crl: &[u8; 20usize] = b"X509v3 Freshest CRL\0";
pub const NID_freshest_crl: u32 = 857;
pub const SN_inhibit_any_policy: &[u8; 17usize] = b"inhibitAnyPolicy\0";
pub const LN_inhibit_any_policy: &[u8; 26usize] = b"X509v3 Inhibit Any Policy\0";
pub const NID_inhibit_any_policy: u32 = 748;
pub const SN_target_information: &[u8; 18usize] = b"targetInformation\0";
pub const LN_target_information: &[u8; 20usize] = b"X509v3 AC Targeting\0";
pub const NID_target_information: u32 = 402;
pub const SN_no_rev_avail: &[u8; 11usize] = b"noRevAvail\0";
pub const LN_no_rev_avail: &[u8; 31usize] = b"X509v3 No Revocation Available\0";
pub const NID_no_rev_avail: u32 = 403;
pub const SN_anyExtendedKeyUsage: &[u8; 20usize] = b"anyExtendedKeyUsage\0";
pub const LN_anyExtendedKeyUsage: &[u8; 23usize] = b"Any Extended Key Usage\0";
pub const NID_anyExtendedKeyUsage: u32 = 910;
pub const SN_netscape: &[u8; 9usize] = b"Netscape\0";
pub const LN_netscape: &[u8; 30usize] = b"Netscape Communications Corp.\0";
pub const NID_netscape: u32 = 57;
pub const SN_netscape_cert_extension: &[u8; 10usize] = b"nsCertExt\0";
pub const LN_netscape_cert_extension: &[u8; 31usize] = b"Netscape Certificate Extension\0";
pub const NID_netscape_cert_extension: u32 = 58;
pub const SN_netscape_data_type: &[u8; 11usize] = b"nsDataType\0";
pub const LN_netscape_data_type: &[u8; 19usize] = b"Netscape Data Type\0";
pub const NID_netscape_data_type: u32 = 59;
pub const SN_netscape_cert_type: &[u8; 11usize] = b"nsCertType\0";
pub const LN_netscape_cert_type: &[u8; 19usize] = b"Netscape Cert Type\0";
pub const NID_netscape_cert_type: u32 = 71;
pub const SN_netscape_base_url: &[u8; 10usize] = b"nsBaseUrl\0";
pub const LN_netscape_base_url: &[u8; 18usize] = b"Netscape Base Url\0";
pub const NID_netscape_base_url: u32 = 72;
pub const SN_netscape_revocation_url: &[u8; 16usize] = b"nsRevocationUrl\0";
pub const LN_netscape_revocation_url: &[u8; 24usize] = b"Netscape Revocation Url\0";
pub const NID_netscape_revocation_url: u32 = 73;
pub const SN_netscape_ca_revocation_url: &[u8; 18usize] = b"nsCaRevocationUrl\0";
pub const LN_netscape_ca_revocation_url: &[u8; 27usize] = b"Netscape CA Revocation Url\0";
pub const NID_netscape_ca_revocation_url: u32 = 74;
pub const SN_netscape_renewal_url: &[u8; 13usize] = b"nsRenewalUrl\0";
pub const LN_netscape_renewal_url: &[u8; 21usize] = b"Netscape Renewal Url\0";
pub const NID_netscape_renewal_url: u32 = 75;
pub const SN_netscape_ca_policy_url: &[u8; 14usize] = b"nsCaPolicyUrl\0";
pub const LN_netscape_ca_policy_url: &[u8; 23usize] = b"Netscape CA Policy Url\0";
pub const NID_netscape_ca_policy_url: u32 = 76;
pub const SN_netscape_ssl_server_name: &[u8; 16usize] = b"nsSslServerName\0";
pub const LN_netscape_ssl_server_name: &[u8; 25usize] = b"Netscape SSL Server Name\0";
pub const NID_netscape_ssl_server_name: u32 = 77;
pub const SN_netscape_comment: &[u8; 10usize] = b"nsComment\0";
pub const LN_netscape_comment: &[u8; 17usize] = b"Netscape Comment\0";
pub const NID_netscape_comment: u32 = 78;
pub const SN_netscape_cert_sequence: &[u8; 15usize] = b"nsCertSequence\0";
pub const LN_netscape_cert_sequence: &[u8; 30usize] = b"Netscape Certificate Sequence\0";
pub const NID_netscape_cert_sequence: u32 = 79;
pub const SN_ns_sgc: &[u8; 6usize] = b"nsSGC\0";
pub const LN_ns_sgc: &[u8; 29usize] = b"Netscape Server Gated Crypto\0";
pub const NID_ns_sgc: u32 = 139;
pub const SN_org: &[u8; 4usize] = b"ORG\0";
pub const LN_org: &[u8; 4usize] = b"org\0";
pub const NID_org: u32 = 379;
pub const SN_dod: &[u8; 4usize] = b"DOD\0";
pub const LN_dod: &[u8; 4usize] = b"dod\0";
pub const NID_dod: u32 = 380;
pub const SN_iana: &[u8; 5usize] = b"IANA\0";
pub const LN_iana: &[u8; 5usize] = b"iana\0";
pub const NID_iana: u32 = 381;
pub const SN_Directory: &[u8; 10usize] = b"directory\0";
pub const LN_Directory: &[u8; 10usize] = b"Directory\0";
pub const NID_Directory: u32 = 382;
pub const SN_Management: &[u8; 5usize] = b"mgmt\0";
pub const LN_Management: &[u8; 11usize] = b"Management\0";
pub const NID_Management: u32 = 383;
pub const SN_Experimental: &[u8; 13usize] = b"experimental\0";
pub const LN_Experimental: &[u8; 13usize] = b"Experimental\0";
pub const NID_Experimental: u32 = 384;
pub const SN_Private: &[u8; 8usize] = b"private\0";
pub const LN_Private: &[u8; 8usize] = b"Private\0";
pub const NID_Private: u32 = 385;
pub const SN_Security: &[u8; 9usize] = b"security\0";
pub const LN_Security: &[u8; 9usize] = b"Security\0";
pub const NID_Security: u32 = 386;
pub const SN_SNMPv2: &[u8; 7usize] = b"snmpv2\0";
pub const LN_SNMPv2: &[u8; 7usize] = b"SNMPv2\0";
pub const NID_SNMPv2: u32 = 387;
pub const LN_Mail: &[u8; 5usize] = b"Mail\0";
pub const NID_Mail: u32 = 388;
pub const SN_Enterprises: &[u8; 12usize] = b"enterprises\0";
pub const LN_Enterprises: &[u8; 12usize] = b"Enterprises\0";
pub const NID_Enterprises: u32 = 389;
pub const SN_dcObject: &[u8; 9usize] = b"dcobject\0";
pub const LN_dcObject: &[u8; 9usize] = b"dcObject\0";
pub const NID_dcObject: u32 = 390;
pub const SN_mime_mhs: &[u8; 9usize] = b"mime-mhs\0";
pub const LN_mime_mhs: &[u8; 9usize] = b"MIME MHS\0";
pub const NID_mime_mhs: u32 = 504;
pub const SN_mime_mhs_headings: &[u8; 18usize] = b"mime-mhs-headings\0";
pub const LN_mime_mhs_headings: &[u8; 18usize] = b"mime-mhs-headings\0";
pub const NID_mime_mhs_headings: u32 = 505;
pub const SN_mime_mhs_bodies: &[u8; 16usize] = b"mime-mhs-bodies\0";
pub const LN_mime_mhs_bodies: &[u8; 16usize] = b"mime-mhs-bodies\0";
pub const NID_mime_mhs_bodies: u32 = 506;
pub const SN_id_hex_partial_message: &[u8; 23usize] = b"id-hex-partial-message\0";
pub const LN_id_hex_partial_message: &[u8; 23usize] = b"id-hex-partial-message\0";
pub const NID_id_hex_partial_message: u32 = 507;
pub const SN_id_hex_multipart_message: &[u8; 25usize] = b"id-hex-multipart-message\0";
pub const LN_id_hex_multipart_message: &[u8; 25usize] = b"id-hex-multipart-message\0";
pub const NID_id_hex_multipart_message: u32 = 508;
pub const SN_zlib_compression: &[u8; 5usize] = b"ZLIB\0";
pub const LN_zlib_compression: &[u8; 17usize] = b"zlib compression\0";
pub const NID_zlib_compression: u32 = 125;
pub const SN_aes_128_ecb: &[u8; 12usize] = b"AES-128-ECB\0";
pub const LN_aes_128_ecb: &[u8; 12usize] = b"aes-128-ecb\0";
pub const NID_aes_128_ecb: u32 = 418;
pub const SN_aes_128_cbc: &[u8; 12usize] = b"AES-128-CBC\0";
pub const LN_aes_128_cbc: &[u8; 12usize] = b"aes-128-cbc\0";
pub const NID_aes_128_cbc: u32 = 419;
pub const SN_aes_128_ofb128: &[u8; 12usize] = b"AES-128-OFB\0";
pub const LN_aes_128_ofb128: &[u8; 12usize] = b"aes-128-ofb\0";
pub const NID_aes_128_ofb128: u32 = 420;
pub const SN_aes_128_cfb128: &[u8; 12usize] = b"AES-128-CFB\0";
pub const LN_aes_128_cfb128: &[u8; 12usize] = b"aes-128-cfb\0";
pub const NID_aes_128_cfb128: u32 = 421;
pub const SN_id_aes128_wrap: &[u8; 15usize] = b"id-aes128-wrap\0";
pub const NID_id_aes128_wrap: u32 = 788;
pub const SN_aes_128_gcm: &[u8; 14usize] = b"id-aes128-GCM\0";
pub const LN_aes_128_gcm: &[u8; 12usize] = b"aes-128-gcm\0";
pub const NID_aes_128_gcm: u32 = 895;
pub const SN_aes_128_ccm: &[u8; 14usize] = b"id-aes128-CCM\0";
pub const LN_aes_128_ccm: &[u8; 12usize] = b"aes-128-ccm\0";
pub const NID_aes_128_ccm: u32 = 896;
pub const SN_id_aes128_wrap_pad: &[u8; 19usize] = b"id-aes128-wrap-pad\0";
pub const NID_id_aes128_wrap_pad: u32 = 897;
pub const SN_aes_192_ecb: &[u8; 12usize] = b"AES-192-ECB\0";
pub const LN_aes_192_ecb: &[u8; 12usize] = b"aes-192-ecb\0";
pub const NID_aes_192_ecb: u32 = 422;
pub const SN_aes_192_cbc: &[u8; 12usize] = b"AES-192-CBC\0";
pub const LN_aes_192_cbc: &[u8; 12usize] = b"aes-192-cbc\0";
pub const NID_aes_192_cbc: u32 = 423;
pub const SN_aes_192_ofb128: &[u8; 12usize] = b"AES-192-OFB\0";
pub const LN_aes_192_ofb128: &[u8; 12usize] = b"aes-192-ofb\0";
pub const NID_aes_192_ofb128: u32 = 424;
pub const SN_aes_192_cfb128: &[u8; 12usize] = b"AES-192-CFB\0";
pub const LN_aes_192_cfb128: &[u8; 12usize] = b"aes-192-cfb\0";
pub const NID_aes_192_cfb128: u32 = 425;
pub const SN_id_aes192_wrap: &[u8; 15usize] = b"id-aes192-wrap\0";
pub const NID_id_aes192_wrap: u32 = 789;
pub const SN_aes_192_gcm: &[u8; 14usize] = b"id-aes192-GCM\0";
pub const LN_aes_192_gcm: &[u8; 12usize] = b"aes-192-gcm\0";
pub const NID_aes_192_gcm: u32 = 898;
pub const SN_aes_192_ccm: &[u8; 14usize] = b"id-aes192-CCM\0";
pub const LN_aes_192_ccm: &[u8; 12usize] = b"aes-192-ccm\0";
pub const NID_aes_192_ccm: u32 = 899;
pub const SN_id_aes192_wrap_pad: &[u8; 19usize] = b"id-aes192-wrap-pad\0";
pub const NID_id_aes192_wrap_pad: u32 = 900;
pub const SN_aes_256_ecb: &[u8; 12usize] = b"AES-256-ECB\0";
pub const LN_aes_256_ecb: &[u8; 12usize] = b"aes-256-ecb\0";
pub const NID_aes_256_ecb: u32 = 426;
pub const SN_aes_256_cbc: &[u8; 12usize] = b"AES-256-CBC\0";
pub const LN_aes_256_cbc: &[u8; 12usize] = b"aes-256-cbc\0";
pub const NID_aes_256_cbc: u32 = 427;
pub const SN_aes_256_ofb128: &[u8; 12usize] = b"AES-256-OFB\0";
pub const LN_aes_256_ofb128: &[u8; 12usize] = b"aes-256-ofb\0";
pub const NID_aes_256_ofb128: u32 = 428;
pub const SN_aes_256_cfb128: &[u8; 12usize] = b"AES-256-CFB\0";
pub const LN_aes_256_cfb128: &[u8; 12usize] = b"aes-256-cfb\0";
pub const NID_aes_256_cfb128: u32 = 429;
pub const SN_id_aes256_wrap: &[u8; 15usize] = b"id-aes256-wrap\0";
pub const NID_id_aes256_wrap: u32 = 790;
pub const SN_aes_256_gcm: &[u8; 14usize] = b"id-aes256-GCM\0";
pub const LN_aes_256_gcm: &[u8; 12usize] = b"aes-256-gcm\0";
pub const NID_aes_256_gcm: u32 = 901;
pub const SN_aes_256_ccm: &[u8; 14usize] = b"id-aes256-CCM\0";
pub const LN_aes_256_ccm: &[u8; 12usize] = b"aes-256-ccm\0";
pub const NID_aes_256_ccm: u32 = 902;
pub const SN_id_aes256_wrap_pad: &[u8; 19usize] = b"id-aes256-wrap-pad\0";
pub const NID_id_aes256_wrap_pad: u32 = 903;
pub const SN_aes_128_xts: &[u8; 12usize] = b"AES-128-XTS\0";
pub const LN_aes_128_xts: &[u8; 12usize] = b"aes-128-xts\0";
pub const NID_aes_128_xts: u32 = 913;
pub const SN_aes_256_xts: &[u8; 12usize] = b"AES-256-XTS\0";
pub const LN_aes_256_xts: &[u8; 12usize] = b"aes-256-xts\0";
pub const NID_aes_256_xts: u32 = 914;
pub const SN_aes_128_cfb1: &[u8; 13usize] = b"AES-128-CFB1\0";
pub const LN_aes_128_cfb1: &[u8; 13usize] = b"aes-128-cfb1\0";
pub const NID_aes_128_cfb1: u32 = 650;
pub const SN_aes_192_cfb1: &[u8; 13usize] = b"AES-192-CFB1\0";
pub const LN_aes_192_cfb1: &[u8; 13usize] = b"aes-192-cfb1\0";
pub const NID_aes_192_cfb1: u32 = 651;
pub const SN_aes_256_cfb1: &[u8; 13usize] = b"AES-256-CFB1\0";
pub const LN_aes_256_cfb1: &[u8; 13usize] = b"aes-256-cfb1\0";
pub const NID_aes_256_cfb1: u32 = 652;
pub const SN_aes_128_cfb8: &[u8; 13usize] = b"AES-128-CFB8\0";
pub const LN_aes_128_cfb8: &[u8; 13usize] = b"aes-128-cfb8\0";
pub const NID_aes_128_cfb8: u32 = 653;
pub const SN_aes_192_cfb8: &[u8; 13usize] = b"AES-192-CFB8\0";
pub const LN_aes_192_cfb8: &[u8; 13usize] = b"aes-192-cfb8\0";
pub const NID_aes_192_cfb8: u32 = 654;
pub const SN_aes_256_cfb8: &[u8; 13usize] = b"AES-256-CFB8\0";
pub const LN_aes_256_cfb8: &[u8; 13usize] = b"aes-256-cfb8\0";
pub const NID_aes_256_cfb8: u32 = 655;
pub const SN_aes_128_ctr: &[u8; 12usize] = b"AES-128-CTR\0";
pub const LN_aes_128_ctr: &[u8; 12usize] = b"aes-128-ctr\0";
pub const NID_aes_128_ctr: u32 = 904;
pub const SN_aes_192_ctr: &[u8; 12usize] = b"AES-192-CTR\0";
pub const LN_aes_192_ctr: &[u8; 12usize] = b"aes-192-ctr\0";
pub const NID_aes_192_ctr: u32 = 905;
pub const SN_aes_256_ctr: &[u8; 12usize] = b"AES-256-CTR\0";
pub const LN_aes_256_ctr: &[u8; 12usize] = b"aes-256-ctr\0";
pub const NID_aes_256_ctr: u32 = 906;
pub const SN_aes_128_ocb: &[u8; 12usize] = b"AES-128-OCB\0";
pub const LN_aes_128_ocb: &[u8; 12usize] = b"aes-128-ocb\0";
pub const NID_aes_128_ocb: u32 = 958;
pub const SN_aes_192_ocb: &[u8; 12usize] = b"AES-192-OCB\0";
pub const LN_aes_192_ocb: &[u8; 12usize] = b"aes-192-ocb\0";
pub const NID_aes_192_ocb: u32 = 959;
pub const SN_aes_256_ocb: &[u8; 12usize] = b"AES-256-OCB\0";
pub const LN_aes_256_ocb: &[u8; 12usize] = b"aes-256-ocb\0";
pub const NID_aes_256_ocb: u32 = 960;
pub const SN_des_cfb1: &[u8; 9usize] = b"DES-CFB1\0";
pub const LN_des_cfb1: &[u8; 9usize] = b"des-cfb1\0";
pub const NID_des_cfb1: u32 = 656;
pub const SN_des_cfb8: &[u8; 9usize] = b"DES-CFB8\0";
pub const LN_des_cfb8: &[u8; 9usize] = b"des-cfb8\0";
pub const NID_des_cfb8: u32 = 657;
pub const SN_des_ede3_cfb1: &[u8; 14usize] = b"DES-EDE3-CFB1\0";
pub const LN_des_ede3_cfb1: &[u8; 14usize] = b"des-ede3-cfb1\0";
pub const NID_des_ede3_cfb1: u32 = 658;
pub const SN_des_ede3_cfb8: &[u8; 14usize] = b"DES-EDE3-CFB8\0";
pub const LN_des_ede3_cfb8: &[u8; 14usize] = b"des-ede3-cfb8\0";
pub const NID_des_ede3_cfb8: u32 = 659;
pub const SN_sha256: &[u8; 7usize] = b"SHA256\0";
pub const LN_sha256: &[u8; 7usize] = b"sha256\0";
pub const NID_sha256: u32 = 672;
pub const SN_sha384: &[u8; 7usize] = b"SHA384\0";
pub const LN_sha384: &[u8; 7usize] = b"sha384\0";
pub const NID_sha384: u32 = 673;
pub const SN_sha512: &[u8; 7usize] = b"SHA512\0";
pub const LN_sha512: &[u8; 7usize] = b"sha512\0";
pub const NID_sha512: u32 = 674;
pub const SN_sha224: &[u8; 7usize] = b"SHA224\0";
pub const LN_sha224: &[u8; 7usize] = b"sha224\0";
pub const NID_sha224: u32 = 675;
pub const SN_sha512_224: &[u8; 11usize] = b"SHA512-224\0";
pub const LN_sha512_224: &[u8; 11usize] = b"sha512-224\0";
pub const NID_sha512_224: u32 = 1094;
pub const SN_sha512_256: &[u8; 11usize] = b"SHA512-256\0";
pub const LN_sha512_256: &[u8; 11usize] = b"sha512-256\0";
pub const NID_sha512_256: u32 = 1095;
pub const SN_sha3_224: &[u8; 9usize] = b"SHA3-224\0";
pub const LN_sha3_224: &[u8; 9usize] = b"sha3-224\0";
pub const NID_sha3_224: u32 = 1096;
pub const SN_sha3_256: &[u8; 9usize] = b"SHA3-256\0";
pub const LN_sha3_256: &[u8; 9usize] = b"sha3-256\0";
pub const NID_sha3_256: u32 = 1097;
pub const SN_sha3_384: &[u8; 9usize] = b"SHA3-384\0";
pub const LN_sha3_384: &[u8; 9usize] = b"sha3-384\0";
pub const NID_sha3_384: u32 = 1098;
pub const SN_sha3_512: &[u8; 9usize] = b"SHA3-512\0";
pub const LN_sha3_512: &[u8; 9usize] = b"sha3-512\0";
pub const NID_sha3_512: u32 = 1099;
pub const SN_shake128: &[u8; 9usize] = b"SHAKE128\0";
pub const LN_shake128: &[u8; 9usize] = b"shake128\0";
pub const NID_shake128: u32 = 1100;
pub const SN_shake256: &[u8; 9usize] = b"SHAKE256\0";
pub const LN_shake256: &[u8; 9usize] = b"shake256\0";
pub const NID_shake256: u32 = 1101;
pub const SN_hmac_sha3_224: &[u8; 20usize] = b"id-hmacWithSHA3-224\0";
pub const LN_hmac_sha3_224: &[u8; 14usize] = b"hmac-sha3-224\0";
pub const NID_hmac_sha3_224: u32 = 1102;
pub const SN_hmac_sha3_256: &[u8; 20usize] = b"id-hmacWithSHA3-256\0";
pub const LN_hmac_sha3_256: &[u8; 14usize] = b"hmac-sha3-256\0";
pub const NID_hmac_sha3_256: u32 = 1103;
pub const SN_hmac_sha3_384: &[u8; 20usize] = b"id-hmacWithSHA3-384\0";
pub const LN_hmac_sha3_384: &[u8; 14usize] = b"hmac-sha3-384\0";
pub const NID_hmac_sha3_384: u32 = 1104;
pub const SN_hmac_sha3_512: &[u8; 20usize] = b"id-hmacWithSHA3-512\0";
pub const LN_hmac_sha3_512: &[u8; 14usize] = b"hmac-sha3-512\0";
pub const NID_hmac_sha3_512: u32 = 1105;
pub const SN_dsa_with_SHA224: &[u8; 16usize] = b"dsa_with_SHA224\0";
pub const NID_dsa_with_SHA224: u32 = 802;
pub const SN_dsa_with_SHA256: &[u8; 16usize] = b"dsa_with_SHA256\0";
pub const NID_dsa_with_SHA256: u32 = 803;
pub const SN_dsa_with_SHA384: &[u8; 19usize] = b"id-dsa-with-sha384\0";
pub const LN_dsa_with_SHA384: &[u8; 16usize] = b"dsa_with_SHA384\0";
pub const NID_dsa_with_SHA384: u32 = 1106;
pub const SN_dsa_with_SHA512: &[u8; 19usize] = b"id-dsa-with-sha512\0";
pub const LN_dsa_with_SHA512: &[u8; 16usize] = b"dsa_with_SHA512\0";
pub const NID_dsa_with_SHA512: u32 = 1107;
pub const SN_dsa_with_SHA3_224: &[u8; 21usize] = b"id-dsa-with-sha3-224\0";
pub const LN_dsa_with_SHA3_224: &[u8; 18usize] = b"dsa_with_SHA3-224\0";
pub const NID_dsa_with_SHA3_224: u32 = 1108;
pub const SN_dsa_with_SHA3_256: &[u8; 21usize] = b"id-dsa-with-sha3-256\0";
pub const LN_dsa_with_SHA3_256: &[u8; 18usize] = b"dsa_with_SHA3-256\0";
pub const NID_dsa_with_SHA3_256: u32 = 1109;
pub const SN_dsa_with_SHA3_384: &[u8; 21usize] = b"id-dsa-with-sha3-384\0";
pub const LN_dsa_with_SHA3_384: &[u8; 18usize] = b"dsa_with_SHA3-384\0";
pub const NID_dsa_with_SHA3_384: u32 = 1110;
pub const SN_dsa_with_SHA3_512: &[u8; 21usize] = b"id-dsa-with-sha3-512\0";
pub const LN_dsa_with_SHA3_512: &[u8; 18usize] = b"dsa_with_SHA3-512\0";
pub const NID_dsa_with_SHA3_512: u32 = 1111;
pub const SN_ecdsa_with_SHA3_224: &[u8; 23usize] = b"id-ecdsa-with-sha3-224\0";
pub const LN_ecdsa_with_SHA3_224: &[u8; 20usize] = b"ecdsa_with_SHA3-224\0";
pub const NID_ecdsa_with_SHA3_224: u32 = 1112;
pub const SN_ecdsa_with_SHA3_256: &[u8; 23usize] = b"id-ecdsa-with-sha3-256\0";
pub const LN_ecdsa_with_SHA3_256: &[u8; 20usize] = b"ecdsa_with_SHA3-256\0";
pub const NID_ecdsa_with_SHA3_256: u32 = 1113;
pub const SN_ecdsa_with_SHA3_384: &[u8; 23usize] = b"id-ecdsa-with-sha3-384\0";
pub const LN_ecdsa_with_SHA3_384: &[u8; 20usize] = b"ecdsa_with_SHA3-384\0";
pub const NID_ecdsa_with_SHA3_384: u32 = 1114;
pub const SN_ecdsa_with_SHA3_512: &[u8; 23usize] = b"id-ecdsa-with-sha3-512\0";
pub const LN_ecdsa_with_SHA3_512: &[u8; 20usize] = b"ecdsa_with_SHA3-512\0";
pub const NID_ecdsa_with_SHA3_512: u32 = 1115;
pub const SN_RSA_SHA3_224: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-224\0";
pub const LN_RSA_SHA3_224: &[u8; 13usize] = b"RSA-SHA3-224\0";
pub const NID_RSA_SHA3_224: u32 = 1116;
pub const SN_RSA_SHA3_256: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-256\0";
pub const LN_RSA_SHA3_256: &[u8; 13usize] = b"RSA-SHA3-256\0";
pub const NID_RSA_SHA3_256: u32 = 1117;
pub const SN_RSA_SHA3_384: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-384\0";
pub const LN_RSA_SHA3_384: &[u8; 13usize] = b"RSA-SHA3-384\0";
pub const NID_RSA_SHA3_384: u32 = 1118;
pub const SN_RSA_SHA3_512: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-512\0";
pub const LN_RSA_SHA3_512: &[u8; 13usize] = b"RSA-SHA3-512\0";
pub const NID_RSA_SHA3_512: u32 = 1119;
pub const SN_hold_instruction_code: &[u8; 20usize] = b"holdInstructionCode\0";
pub const LN_hold_instruction_code: &[u8; 22usize] = b"Hold Instruction Code\0";
pub const NID_hold_instruction_code: u32 = 430;
pub const SN_hold_instruction_none: &[u8; 20usize] = b"holdInstructionNone\0";
pub const LN_hold_instruction_none: &[u8; 22usize] = b"Hold Instruction None\0";
pub const NID_hold_instruction_none: u32 = 431;
pub const SN_hold_instruction_call_issuer: &[u8; 26usize] = b"holdInstructionCallIssuer\0";
pub const LN_hold_instruction_call_issuer: &[u8; 29usize] = b"Hold Instruction Call Issuer\0";
pub const NID_hold_instruction_call_issuer: u32 = 432;
pub const SN_hold_instruction_reject: &[u8; 22usize] = b"holdInstructionReject\0";
pub const LN_hold_instruction_reject: &[u8; 24usize] = b"Hold Instruction Reject\0";
pub const NID_hold_instruction_reject: u32 = 433;
pub const SN_data: &[u8; 5usize] = b"data\0";
pub const NID_data: u32 = 434;
pub const SN_pss: &[u8; 4usize] = b"pss\0";
pub const NID_pss: u32 = 435;
pub const SN_ucl: &[u8; 4usize] = b"ucl\0";
pub const NID_ucl: u32 = 436;
pub const SN_pilot: &[u8; 6usize] = b"pilot\0";
pub const NID_pilot: u32 = 437;
pub const LN_pilotAttributeType: &[u8; 19usize] = b"pilotAttributeType\0";
pub const NID_pilotAttributeType: u32 = 438;
pub const LN_pilotAttributeSyntax: &[u8; 21usize] = b"pilotAttributeSyntax\0";
pub const NID_pilotAttributeSyntax: u32 = 439;
pub const LN_pilotObjectClass: &[u8; 17usize] = b"pilotObjectClass\0";
pub const NID_pilotObjectClass: u32 = 440;
pub const LN_pilotGroups: &[u8; 12usize] = b"pilotGroups\0";
pub const NID_pilotGroups: u32 = 441;
pub const LN_iA5StringSyntax: &[u8; 16usize] = b"iA5StringSyntax\0";
pub const NID_iA5StringSyntax: u32 = 442;
pub const LN_caseIgnoreIA5StringSyntax: &[u8; 26usize] = b"caseIgnoreIA5StringSyntax\0";
pub const NID_caseIgnoreIA5StringSyntax: u32 = 443;
pub const LN_pilotObject: &[u8; 12usize] = b"pilotObject\0";
pub const NID_pilotObject: u32 = 444;
pub const LN_pilotPerson: &[u8; 12usize] = b"pilotPerson\0";
pub const NID_pilotPerson: u32 = 445;
pub const SN_account: &[u8; 8usize] = b"account\0";
pub const NID_account: u32 = 446;
pub const SN_document: &[u8; 9usize] = b"document\0";
pub const NID_document: u32 = 447;
pub const SN_room: &[u8; 5usize] = b"room\0";
pub const NID_room: u32 = 448;
pub const LN_documentSeries: &[u8; 15usize] = b"documentSeries\0";
pub const NID_documentSeries: u32 = 449;
pub const SN_Domain: &[u8; 7usize] = b"domain\0";
pub const LN_Domain: &[u8; 7usize] = b"Domain\0";
pub const NID_Domain: u32 = 392;
pub const LN_rFC822localPart: &[u8; 16usize] = b"rFC822localPart\0";
pub const NID_rFC822localPart: u32 = 450;
pub const LN_dNSDomain: &[u8; 10usize] = b"dNSDomain\0";
pub const NID_dNSDomain: u32 = 451;
pub const LN_domainRelatedObject: &[u8; 20usize] = b"domainRelatedObject\0";
pub const NID_domainRelatedObject: u32 = 452;
pub const LN_friendlyCountry: &[u8; 16usize] = b"friendlyCountry\0";
pub const NID_friendlyCountry: u32 = 453;
pub const LN_simpleSecurityObject: &[u8; 21usize] = b"simpleSecurityObject\0";
pub const NID_simpleSecurityObject: u32 = 454;
pub const LN_pilotOrganization: &[u8; 18usize] = b"pilotOrganization\0";
pub const NID_pilotOrganization: u32 = 455;
pub const LN_pilotDSA: &[u8; 9usize] = b"pilotDSA\0";
pub const NID_pilotDSA: u32 = 456;
pub const LN_qualityLabelledData: &[u8; 20usize] = b"qualityLabelledData\0";
pub const NID_qualityLabelledData: u32 = 457;
pub const SN_userId: &[u8; 4usize] = b"UID\0";
pub const LN_userId: &[u8; 7usize] = b"userId\0";
pub const NID_userId: u32 = 458;
pub const LN_textEncodedORAddress: &[u8; 21usize] = b"textEncodedORAddress\0";
pub const NID_textEncodedORAddress: u32 = 459;
pub const SN_rfc822Mailbox: &[u8; 5usize] = b"mail\0";
pub const LN_rfc822Mailbox: &[u8; 14usize] = b"rfc822Mailbox\0";
pub const NID_rfc822Mailbox: u32 = 460;
pub const SN_info: &[u8; 5usize] = b"info\0";
pub const NID_info: u32 = 461;
pub const LN_favouriteDrink: &[u8; 15usize] = b"favouriteDrink\0";
pub const NID_favouriteDrink: u32 = 462;
pub const LN_roomNumber: &[u8; 11usize] = b"roomNumber\0";
pub const NID_roomNumber: u32 = 463;
pub const SN_photo: &[u8; 6usize] = b"photo\0";
pub const NID_photo: u32 = 464;
pub const LN_userClass: &[u8; 10usize] = b"userClass\0";
pub const NID_userClass: u32 = 465;
pub const SN_host: &[u8; 5usize] = b"host\0";
pub const NID_host: u32 = 466;
pub const SN_manager: &[u8; 8usize] = b"manager\0";
pub const NID_manager: u32 = 467;
pub const LN_documentIdentifier: &[u8; 19usize] = b"documentIdentifier\0";
pub const NID_documentIdentifier: u32 = 468;
pub const LN_documentTitle: &[u8; 14usize] = b"documentTitle\0";
pub const NID_documentTitle: u32 = 469;
pub const LN_documentVersion: &[u8; 16usize] = b"documentVersion\0";
pub const NID_documentVersion: u32 = 470;
pub const LN_documentAuthor: &[u8; 15usize] = b"documentAuthor\0";
pub const NID_documentAuthor: u32 = 471;
pub const LN_documentLocation: &[u8; 17usize] = b"documentLocation\0";
pub const NID_documentLocation: u32 = 472;
pub const LN_homeTelephoneNumber: &[u8; 20usize] = b"homeTelephoneNumber\0";
pub const NID_homeTelephoneNumber: u32 = 473;
pub const SN_secretary: &[u8; 10usize] = b"secretary\0";
pub const NID_secretary: u32 = 474;
pub const LN_otherMailbox: &[u8; 13usize] = b"otherMailbox\0";
pub const NID_otherMailbox: u32 = 475;
pub const LN_lastModifiedTime: &[u8; 17usize] = b"lastModifiedTime\0";
pub const NID_lastModifiedTime: u32 = 476;
pub const LN_lastModifiedBy: &[u8; 15usize] = b"lastModifiedBy\0";
pub const NID_lastModifiedBy: u32 = 477;
pub const SN_domainComponent: &[u8; 3usize] = b"DC\0";
pub const LN_domainComponent: &[u8; 16usize] = b"domainComponent\0";
pub const NID_domainComponent: u32 = 391;
pub const LN_aRecord: &[u8; 8usize] = b"aRecord\0";
pub const NID_aRecord: u32 = 478;
pub const LN_pilotAttributeType27: &[u8; 21usize] = b"pilotAttributeType27\0";
pub const NID_pilotAttributeType27: u32 = 479;
pub const LN_mXRecord: &[u8; 9usize] = b"mXRecord\0";
pub const NID_mXRecord: u32 = 480;
pub const LN_nSRecord: &[u8; 9usize] = b"nSRecord\0";
pub const NID_nSRecord: u32 = 481;
pub const LN_sOARecord: &[u8; 10usize] = b"sOARecord\0";
pub const NID_sOARecord: u32 = 482;
pub const LN_cNAMERecord: &[u8; 12usize] = b"cNAMERecord\0";
pub const NID_cNAMERecord: u32 = 483;
pub const LN_associatedDomain: &[u8; 17usize] = b"associatedDomain\0";
pub const NID_associatedDomain: u32 = 484;
pub const LN_associatedName: &[u8; 15usize] = b"associatedName\0";
pub const NID_associatedName: u32 = 485;
pub const LN_homePostalAddress: &[u8; 18usize] = b"homePostalAddress\0";
pub const NID_homePostalAddress: u32 = 486;
pub const LN_personalTitle: &[u8; 14usize] = b"personalTitle\0";
pub const NID_personalTitle: u32 = 487;
pub const LN_mobileTelephoneNumber: &[u8; 22usize] = b"mobileTelephoneNumber\0";
pub const NID_mobileTelephoneNumber: u32 = 488;
pub const LN_pagerTelephoneNumber: &[u8; 21usize] = b"pagerTelephoneNumber\0";
pub const NID_pagerTelephoneNumber: u32 = 489;
pub const LN_friendlyCountryName: &[u8; 20usize] = b"friendlyCountryName\0";
pub const NID_friendlyCountryName: u32 = 490;
pub const SN_uniqueIdentifier: &[u8; 4usize] = b"uid\0";
pub const LN_uniqueIdentifier: &[u8; 17usize] = b"uniqueIdentifier\0";
pub const NID_uniqueIdentifier: u32 = 102;
pub const LN_organizationalStatus: &[u8; 21usize] = b"organizationalStatus\0";
pub const NID_organizationalStatus: u32 = 491;
pub const LN_janetMailbox: &[u8; 13usize] = b"janetMailbox\0";
pub const NID_janetMailbox: u32 = 492;
pub const LN_mailPreferenceOption: &[u8; 21usize] = b"mailPreferenceOption\0";
pub const NID_mailPreferenceOption: u32 = 493;
pub const LN_buildingName: &[u8; 13usize] = b"buildingName\0";
pub const NID_buildingName: u32 = 494;
pub const LN_dSAQuality: &[u8; 11usize] = b"dSAQuality\0";
pub const NID_dSAQuality: u32 = 495;
pub const LN_singleLevelQuality: &[u8; 19usize] = b"singleLevelQuality\0";
pub const NID_singleLevelQuality: u32 = 496;
pub const LN_subtreeMinimumQuality: &[u8; 22usize] = b"subtreeMinimumQuality\0";
pub const NID_subtreeMinimumQuality: u32 = 497;
pub const LN_subtreeMaximumQuality: &[u8; 22usize] = b"subtreeMaximumQuality\0";
pub const NID_subtreeMaximumQuality: u32 = 498;
pub const LN_personalSignature: &[u8; 18usize] = b"personalSignature\0";
pub const NID_personalSignature: u32 = 499;
pub const LN_dITRedirect: &[u8; 12usize] = b"dITRedirect\0";
pub const NID_dITRedirect: u32 = 500;
pub const SN_audio: &[u8; 6usize] = b"audio\0";
pub const NID_audio: u32 = 501;
pub const LN_documentPublisher: &[u8; 18usize] = b"documentPublisher\0";
pub const NID_documentPublisher: u32 = 502;
pub const SN_id_set: &[u8; 7usize] = b"id-set\0";
pub const LN_id_set: &[u8; 31usize] = b"Secure Electronic Transactions\0";
pub const NID_id_set: u32 = 512;
pub const SN_set_ctype: &[u8; 10usize] = b"set-ctype\0";
pub const LN_set_ctype: &[u8; 14usize] = b"content types\0";
pub const NID_set_ctype: u32 = 513;
pub const SN_set_msgExt: &[u8; 11usize] = b"set-msgExt\0";
pub const LN_set_msgExt: &[u8; 19usize] = b"message extensions\0";
pub const NID_set_msgExt: u32 = 514;
pub const SN_set_attr: &[u8; 9usize] = b"set-attr\0";
pub const NID_set_attr: u32 = 515;
pub const SN_set_policy: &[u8; 11usize] = b"set-policy\0";
pub const NID_set_policy: u32 = 516;
pub const SN_set_certExt: &[u8; 12usize] = b"set-certExt\0";
pub const LN_set_certExt: &[u8; 23usize] = b"certificate extensions\0";
pub const NID_set_certExt: u32 = 517;
pub const SN_set_brand: &[u8; 10usize] = b"set-brand\0";
pub const NID_set_brand: u32 = 518;
pub const SN_setct_PANData: &[u8; 14usize] = b"setct-PANData\0";
pub const NID_setct_PANData: u32 = 519;
pub const SN_setct_PANToken: &[u8; 15usize] = b"setct-PANToken\0";
pub const NID_setct_PANToken: u32 = 520;
pub const SN_setct_PANOnly: &[u8; 14usize] = b"setct-PANOnly\0";
pub const NID_setct_PANOnly: u32 = 521;
pub const SN_setct_OIData: &[u8; 13usize] = b"setct-OIData\0";
pub const NID_setct_OIData: u32 = 522;
pub const SN_setct_PI: &[u8; 9usize] = b"setct-PI\0";
pub const NID_setct_PI: u32 = 523;
pub const SN_setct_PIData: &[u8; 13usize] = b"setct-PIData\0";
pub const NID_setct_PIData: u32 = 524;
pub const SN_setct_PIDataUnsigned: &[u8; 21usize] = b"setct-PIDataUnsigned\0";
pub const NID_setct_PIDataUnsigned: u32 = 525;
pub const SN_setct_HODInput: &[u8; 15usize] = b"setct-HODInput\0";
pub const NID_setct_HODInput: u32 = 526;
pub const SN_setct_AuthResBaggage: &[u8; 21usize] = b"setct-AuthResBaggage\0";
pub const NID_setct_AuthResBaggage: u32 = 527;
pub const SN_setct_AuthRevReqBaggage: &[u8; 24usize] = b"setct-AuthRevReqBaggage\0";
pub const NID_setct_AuthRevReqBaggage: u32 = 528;
pub const SN_setct_AuthRevResBaggage: &[u8; 24usize] = b"setct-AuthRevResBaggage\0";
pub const NID_setct_AuthRevResBaggage: u32 = 529;
pub const SN_setct_CapTokenSeq: &[u8; 18usize] = b"setct-CapTokenSeq\0";
pub const NID_setct_CapTokenSeq: u32 = 530;
pub const SN_setct_PInitResData: &[u8; 19usize] = b"setct-PInitResData\0";
pub const NID_setct_PInitResData: u32 = 531;
pub const SN_setct_PI_TBS: &[u8; 13usize] = b"setct-PI-TBS\0";
pub const NID_setct_PI_TBS: u32 = 532;
pub const SN_setct_PResData: &[u8; 15usize] = b"setct-PResData\0";
pub const NID_setct_PResData: u32 = 533;
pub const SN_setct_AuthReqTBS: &[u8; 17usize] = b"setct-AuthReqTBS\0";
pub const NID_setct_AuthReqTBS: u32 = 534;
pub const SN_setct_AuthResTBS: &[u8; 17usize] = b"setct-AuthResTBS\0";
pub const NID_setct_AuthResTBS: u32 = 535;
pub const SN_setct_AuthResTBSX: &[u8; 18usize] = b"setct-AuthResTBSX\0";
pub const NID_setct_AuthResTBSX: u32 = 536;
pub const SN_setct_AuthTokenTBS: &[u8; 19usize] = b"setct-AuthTokenTBS\0";
pub const NID_setct_AuthTokenTBS: u32 = 537;
pub const SN_setct_CapTokenData: &[u8; 19usize] = b"setct-CapTokenData\0";
pub const NID_setct_CapTokenData: u32 = 538;
pub const SN_setct_CapTokenTBS: &[u8; 18usize] = b"setct-CapTokenTBS\0";
pub const NID_setct_CapTokenTBS: u32 = 539;
pub const SN_setct_AcqCardCodeMsg: &[u8; 21usize] = b"setct-AcqCardCodeMsg\0";
pub const NID_setct_AcqCardCodeMsg: u32 = 540;
pub const SN_setct_AuthRevReqTBS: &[u8; 20usize] = b"setct-AuthRevReqTBS\0";
pub const NID_setct_AuthRevReqTBS: u32 = 541;
pub const SN_setct_AuthRevResData: &[u8; 21usize] = b"setct-AuthRevResData\0";
pub const NID_setct_AuthRevResData: u32 = 542;
pub const SN_setct_AuthRevResTBS: &[u8; 20usize] = b"setct-AuthRevResTBS\0";
pub const NID_setct_AuthRevResTBS: u32 = 543;
pub const SN_setct_CapReqTBS: &[u8; 16usize] = b"setct-CapReqTBS\0";
pub const NID_setct_CapReqTBS: u32 = 544;
pub const SN_setct_CapReqTBSX: &[u8; 17usize] = b"setct-CapReqTBSX\0";
pub const NID_setct_CapReqTBSX: u32 = 545;
pub const SN_setct_CapResData: &[u8; 17usize] = b"setct-CapResData\0";
pub const NID_setct_CapResData: u32 = 546;
pub const SN_setct_CapRevReqTBS: &[u8; 19usize] = b"setct-CapRevReqTBS\0";
pub const NID_setct_CapRevReqTBS: u32 = 547;
pub const SN_setct_CapRevReqTBSX: &[u8; 20usize] = b"setct-CapRevReqTBSX\0";
pub const NID_setct_CapRevReqTBSX: u32 = 548;
pub const SN_setct_CapRevResData: &[u8; 20usize] = b"setct-CapRevResData\0";
pub const NID_setct_CapRevResData: u32 = 549;
pub const SN_setct_CredReqTBS: &[u8; 17usize] = b"setct-CredReqTBS\0";
pub const NID_setct_CredReqTBS: u32 = 550;
pub const SN_setct_CredReqTBSX: &[u8; 18usize] = b"setct-CredReqTBSX\0";
pub const NID_setct_CredReqTBSX: u32 = 551;
pub const SN_setct_CredResData: &[u8; 18usize] = b"setct-CredResData\0";
pub const NID_setct_CredResData: u32 = 552;
pub const SN_setct_CredRevReqTBS: &[u8; 20usize] = b"setct-CredRevReqTBS\0";
pub const NID_setct_CredRevReqTBS: u32 = 553;
pub const SN_setct_CredRevReqTBSX: &[u8; 21usize] = b"setct-CredRevReqTBSX\0";
pub const NID_setct_CredRevReqTBSX: u32 = 554;
pub const SN_setct_CredRevResData: &[u8; 21usize] = b"setct-CredRevResData\0";
pub const NID_setct_CredRevResData: u32 = 555;
pub const SN_setct_PCertReqData: &[u8; 19usize] = b"setct-PCertReqData\0";
pub const NID_setct_PCertReqData: u32 = 556;
pub const SN_setct_PCertResTBS: &[u8; 18usize] = b"setct-PCertResTBS\0";
pub const NID_setct_PCertResTBS: u32 = 557;
pub const SN_setct_BatchAdminReqData: &[u8; 24usize] = b"setct-BatchAdminReqData\0";
pub const NID_setct_BatchAdminReqData: u32 = 558;
pub const SN_setct_BatchAdminResData: &[u8; 24usize] = b"setct-BatchAdminResData\0";
pub const NID_setct_BatchAdminResData: u32 = 559;
pub const SN_setct_CardCInitResTBS: &[u8; 22usize] = b"setct-CardCInitResTBS\0";
pub const NID_setct_CardCInitResTBS: u32 = 560;
pub const SN_setct_MeAqCInitResTBS: &[u8; 22usize] = b"setct-MeAqCInitResTBS\0";
pub const NID_setct_MeAqCInitResTBS: u32 = 561;
pub const SN_setct_RegFormResTBS: &[u8; 20usize] = b"setct-RegFormResTBS\0";
pub const NID_setct_RegFormResTBS: u32 = 562;
pub const SN_setct_CertReqData: &[u8; 18usize] = b"setct-CertReqData\0";
pub const NID_setct_CertReqData: u32 = 563;
pub const SN_setct_CertReqTBS: &[u8; 17usize] = b"setct-CertReqTBS\0";
pub const NID_setct_CertReqTBS: u32 = 564;
pub const SN_setct_CertResData: &[u8; 18usize] = b"setct-CertResData\0";
pub const NID_setct_CertResData: u32 = 565;
pub const SN_setct_CertInqReqTBS: &[u8; 20usize] = b"setct-CertInqReqTBS\0";
pub const NID_setct_CertInqReqTBS: u32 = 566;
pub const SN_setct_ErrorTBS: &[u8; 15usize] = b"setct-ErrorTBS\0";
pub const NID_setct_ErrorTBS: u32 = 567;
pub const SN_setct_PIDualSignedTBE: &[u8; 22usize] = b"setct-PIDualSignedTBE\0";
pub const NID_setct_PIDualSignedTBE: u32 = 568;
pub const SN_setct_PIUnsignedTBE: &[u8; 20usize] = b"setct-PIUnsignedTBE\0";
pub const NID_setct_PIUnsignedTBE: u32 = 569;
pub const SN_setct_AuthReqTBE: &[u8; 17usize] = b"setct-AuthReqTBE\0";
pub const NID_setct_AuthReqTBE: u32 = 570;
pub const SN_setct_AuthResTBE: &[u8; 17usize] = b"setct-AuthResTBE\0";
pub const NID_setct_AuthResTBE: u32 = 571;
pub const SN_setct_AuthResTBEX: &[u8; 18usize] = b"setct-AuthResTBEX\0";
pub const NID_setct_AuthResTBEX: u32 = 572;
pub const SN_setct_AuthTokenTBE: &[u8; 19usize] = b"setct-AuthTokenTBE\0";
pub const NID_setct_AuthTokenTBE: u32 = 573;
pub const SN_setct_CapTokenTBE: &[u8; 18usize] = b"setct-CapTokenTBE\0";
pub const NID_setct_CapTokenTBE: u32 = 574;
pub const SN_setct_CapTokenTBEX: &[u8; 19usize] = b"setct-CapTokenTBEX\0";
pub const NID_setct_CapTokenTBEX: u32 = 575;
pub const SN_setct_AcqCardCodeMsgTBE: &[u8; 24usize] = b"setct-AcqCardCodeMsgTBE\0";
pub const NID_setct_AcqCardCodeMsgTBE: u32 = 576;
pub const SN_setct_AuthRevReqTBE: &[u8; 20usize] = b"setct-AuthRevReqTBE\0";
pub const NID_setct_AuthRevReqTBE: u32 = 577;
pub const SN_setct_AuthRevResTBE: &[u8; 20usize] = b"setct-AuthRevResTBE\0";
pub const NID_setct_AuthRevResTBE: u32 = 578;
pub const SN_setct_AuthRevResTBEB: &[u8; 21usize] = b"setct-AuthRevResTBEB\0";
pub const NID_setct_AuthRevResTBEB: u32 = 579;
pub const SN_setct_CapReqTBE: &[u8; 16usize] = b"setct-CapReqTBE\0";
pub const NID_setct_CapReqTBE: u32 = 580;
pub const SN_setct_CapReqTBEX: &[u8; 17usize] = b"setct-CapReqTBEX\0";
pub const NID_setct_CapReqTBEX: u32 = 581;
pub const SN_setct_CapResTBE: &[u8; 16usize] = b"setct-CapResTBE\0";
pub const NID_setct_CapResTBE: u32 = 582;
pub const SN_setct_CapRevReqTBE: &[u8; 19usize] = b"setct-CapRevReqTBE\0";
pub const NID_setct_CapRevReqTBE: u32 = 583;
pub const SN_setct_CapRevReqTBEX: &[u8; 20usize] = b"setct-CapRevReqTBEX\0";
pub const NID_setct_CapRevReqTBEX: u32 = 584;
pub const SN_setct_CapRevResTBE: &[u8; 19usize] = b"setct-CapRevResTBE\0";
pub const NID_setct_CapRevResTBE: u32 = 585;
pub const SN_setct_CredReqTBE: &[u8; 17usize] = b"setct-CredReqTBE\0";
pub const NID_setct_CredReqTBE: u32 = 586;
pub const SN_setct_CredReqTBEX: &[u8; 18usize] = b"setct-CredReqTBEX\0";
pub const NID_setct_CredReqTBEX: u32 = 587;
pub const SN_setct_CredResTBE: &[u8; 17usize] = b"setct-CredResTBE\0";
pub const NID_setct_CredResTBE: u32 = 588;
pub const SN_setct_CredRevReqTBE: &[u8; 20usize] = b"setct-CredRevReqTBE\0";
pub const NID_setct_CredRevReqTBE: u32 = 589;
pub const SN_setct_CredRevReqTBEX: &[u8; 21usize] = b"setct-CredRevReqTBEX\0";
pub const NID_setct_CredRevReqTBEX: u32 = 590;
pub const SN_setct_CredRevResTBE: &[u8; 20usize] = b"setct-CredRevResTBE\0";
pub const NID_setct_CredRevResTBE: u32 = 591;
pub const SN_setct_BatchAdminReqTBE: &[u8; 23usize] = b"setct-BatchAdminReqTBE\0";
pub const NID_setct_BatchAdminReqTBE: u32 = 592;
pub const SN_setct_BatchAdminResTBE: &[u8; 23usize] = b"setct-BatchAdminResTBE\0";
pub const NID_setct_BatchAdminResTBE: u32 = 593;
pub const SN_setct_RegFormReqTBE: &[u8; 20usize] = b"setct-RegFormReqTBE\0";
pub const NID_setct_RegFormReqTBE: u32 = 594;
pub const SN_setct_CertReqTBE: &[u8; 17usize] = b"setct-CertReqTBE\0";
pub const NID_setct_CertReqTBE: u32 = 595;
pub const SN_setct_CertReqTBEX: &[u8; 18usize] = b"setct-CertReqTBEX\0";
pub const NID_setct_CertReqTBEX: u32 = 596;
pub const SN_setct_CertResTBE: &[u8; 17usize] = b"setct-CertResTBE\0";
pub const NID_setct_CertResTBE: u32 = 597;
pub const SN_setct_CRLNotificationTBS: &[u8; 25usize] = b"setct-CRLNotificationTBS\0";
pub const NID_setct_CRLNotificationTBS: u32 = 598;
pub const SN_setct_CRLNotificationResTBS: &[u8; 28usize] = b"setct-CRLNotificationResTBS\0";
pub const NID_setct_CRLNotificationResTBS: u32 = 599;
pub const SN_setct_BCIDistributionTBS: &[u8; 25usize] = b"setct-BCIDistributionTBS\0";
pub const NID_setct_BCIDistributionTBS: u32 = 600;
pub const SN_setext_genCrypt: &[u8; 16usize] = b"setext-genCrypt\0";
pub const LN_setext_genCrypt: &[u8; 19usize] = b"generic cryptogram\0";
pub const NID_setext_genCrypt: u32 = 601;
pub const SN_setext_miAuth: &[u8; 14usize] = b"setext-miAuth\0";
pub const LN_setext_miAuth: &[u8; 24usize] = b"merchant initiated auth\0";
pub const NID_setext_miAuth: u32 = 602;
pub const SN_setext_pinSecure: &[u8; 17usize] = b"setext-pinSecure\0";
pub const NID_setext_pinSecure: u32 = 603;
pub const SN_setext_pinAny: &[u8; 14usize] = b"setext-pinAny\0";
pub const NID_setext_pinAny: u32 = 604;
pub const SN_setext_track2: &[u8; 14usize] = b"setext-track2\0";
pub const NID_setext_track2: u32 = 605;
pub const SN_setext_cv: &[u8; 10usize] = b"setext-cv\0";
pub const LN_setext_cv: &[u8; 24usize] = b"additional verification\0";
pub const NID_setext_cv: u32 = 606;
pub const SN_set_policy_root: &[u8; 16usize] = b"set-policy-root\0";
pub const NID_set_policy_root: u32 = 607;
pub const SN_setCext_hashedRoot: &[u8; 19usize] = b"setCext-hashedRoot\0";
pub const NID_setCext_hashedRoot: u32 = 608;
pub const SN_setCext_certType: &[u8; 17usize] = b"setCext-certType\0";
pub const NID_setCext_certType: u32 = 609;
pub const SN_setCext_merchData: &[u8; 18usize] = b"setCext-merchData\0";
pub const NID_setCext_merchData: u32 = 610;
pub const SN_setCext_cCertRequired: &[u8; 22usize] = b"setCext-cCertRequired\0";
pub const NID_setCext_cCertRequired: u32 = 611;
pub const SN_setCext_tunneling: &[u8; 18usize] = b"setCext-tunneling\0";
pub const NID_setCext_tunneling: u32 = 612;
pub const SN_setCext_setExt: &[u8; 15usize] = b"setCext-setExt\0";
pub const NID_setCext_setExt: u32 = 613;
pub const SN_setCext_setQualf: &[u8; 17usize] = b"setCext-setQualf\0";
pub const NID_setCext_setQualf: u32 = 614;
pub const SN_setCext_PGWYcapabilities: &[u8; 25usize] = b"setCext-PGWYcapabilities\0";
pub const NID_setCext_PGWYcapabilities: u32 = 615;
pub const SN_setCext_TokenIdentifier: &[u8; 24usize] = b"setCext-TokenIdentifier\0";
pub const NID_setCext_TokenIdentifier: u32 = 616;
pub const SN_setCext_Track2Data: &[u8; 19usize] = b"setCext-Track2Data\0";
pub const NID_setCext_Track2Data: u32 = 617;
pub const SN_setCext_TokenType: &[u8; 18usize] = b"setCext-TokenType\0";
pub const NID_setCext_TokenType: u32 = 618;
pub const SN_setCext_IssuerCapabilities: &[u8; 27usize] = b"setCext-IssuerCapabilities\0";
pub const NID_setCext_IssuerCapabilities: u32 = 619;
pub const SN_setAttr_Cert: &[u8; 13usize] = b"setAttr-Cert\0";
pub const NID_setAttr_Cert: u32 = 620;
pub const SN_setAttr_PGWYcap: &[u8; 16usize] = b"setAttr-PGWYcap\0";
pub const LN_setAttr_PGWYcap: &[u8; 29usize] = b"payment gateway capabilities\0";
pub const NID_setAttr_PGWYcap: u32 = 621;
pub const SN_setAttr_TokenType: &[u8; 18usize] = b"setAttr-TokenType\0";
pub const NID_setAttr_TokenType: u32 = 622;
pub const SN_setAttr_IssCap: &[u8; 15usize] = b"setAttr-IssCap\0";
pub const LN_setAttr_IssCap: &[u8; 20usize] = b"issuer capabilities\0";
pub const NID_setAttr_IssCap: u32 = 623;
pub const SN_set_rootKeyThumb: &[u8; 17usize] = b"set-rootKeyThumb\0";
pub const NID_set_rootKeyThumb: u32 = 624;
pub const SN_set_addPolicy: &[u8; 14usize] = b"set-addPolicy\0";
pub const NID_set_addPolicy: u32 = 625;
pub const SN_setAttr_Token_EMV: &[u8; 18usize] = b"setAttr-Token-EMV\0";
pub const NID_setAttr_Token_EMV: u32 = 626;
pub const SN_setAttr_Token_B0Prime: &[u8; 22usize] = b"setAttr-Token-B0Prime\0";
pub const NID_setAttr_Token_B0Prime: u32 = 627;
pub const SN_setAttr_IssCap_CVM: &[u8; 19usize] = b"setAttr-IssCap-CVM\0";
pub const NID_setAttr_IssCap_CVM: u32 = 628;
pub const SN_setAttr_IssCap_T2: &[u8; 18usize] = b"setAttr-IssCap-T2\0";
pub const NID_setAttr_IssCap_T2: u32 = 629;
pub const SN_setAttr_IssCap_Sig: &[u8; 19usize] = b"setAttr-IssCap-Sig\0";
pub const NID_setAttr_IssCap_Sig: u32 = 630;
pub const SN_setAttr_GenCryptgrm: &[u8; 20usize] = b"setAttr-GenCryptgrm\0";
pub const LN_setAttr_GenCryptgrm: &[u8; 20usize] = b"generate cryptogram\0";
pub const NID_setAttr_GenCryptgrm: u32 = 631;
pub const SN_setAttr_T2Enc: &[u8; 14usize] = b"setAttr-T2Enc\0";
pub const LN_setAttr_T2Enc: &[u8; 18usize] = b"encrypted track 2\0";
pub const NID_setAttr_T2Enc: u32 = 632;
pub const SN_setAttr_T2cleartxt: &[u8; 19usize] = b"setAttr-T2cleartxt\0";
pub const LN_setAttr_T2cleartxt: &[u8; 18usize] = b"cleartext track 2\0";
pub const NID_setAttr_T2cleartxt: u32 = 633;
pub const SN_setAttr_TokICCsig: &[u8; 18usize] = b"setAttr-TokICCsig\0";
pub const LN_setAttr_TokICCsig: &[u8; 23usize] = b"ICC or token signature\0";
pub const NID_setAttr_TokICCsig: u32 = 634;
pub const SN_setAttr_SecDevSig: &[u8; 18usize] = b"setAttr-SecDevSig\0";
pub const LN_setAttr_SecDevSig: &[u8; 24usize] = b"secure device signature\0";
pub const NID_setAttr_SecDevSig: u32 = 635;
pub const SN_set_brand_IATA_ATA: &[u8; 19usize] = b"set-brand-IATA-ATA\0";
pub const NID_set_brand_IATA_ATA: u32 = 636;
pub const SN_set_brand_Diners: &[u8; 17usize] = b"set-brand-Diners\0";
pub const NID_set_brand_Diners: u32 = 637;
pub const SN_set_brand_AmericanExpress: &[u8; 26usize] = b"set-brand-AmericanExpress\0";
pub const NID_set_brand_AmericanExpress: u32 = 638;
pub const SN_set_brand_JCB: &[u8; 14usize] = b"set-brand-JCB\0";
pub const NID_set_brand_JCB: u32 = 639;
pub const SN_set_brand_Visa: &[u8; 15usize] = b"set-brand-Visa\0";
pub const NID_set_brand_Visa: u32 = 640;
pub const SN_set_brand_MasterCard: &[u8; 21usize] = b"set-brand-MasterCard\0";
pub const NID_set_brand_MasterCard: u32 = 641;
pub const SN_set_brand_Novus: &[u8; 16usize] = b"set-brand-Novus\0";
pub const NID_set_brand_Novus: u32 = 642;
pub const SN_des_cdmf: &[u8; 9usize] = b"DES-CDMF\0";
pub const LN_des_cdmf: &[u8; 9usize] = b"des-cdmf\0";
pub const NID_des_cdmf: u32 = 643;
pub const SN_rsaOAEPEncryptionSET: &[u8; 21usize] = b"rsaOAEPEncryptionSET\0";
pub const NID_rsaOAEPEncryptionSET: u32 = 644;
pub const SN_ipsec3: &[u8; 14usize] = b"Oakley-EC2N-3\0";
pub const LN_ipsec3: &[u8; 7usize] = b"ipsec3\0";
pub const NID_ipsec3: u32 = 749;
pub const SN_ipsec4: &[u8; 14usize] = b"Oakley-EC2N-4\0";
pub const LN_ipsec4: &[u8; 7usize] = b"ipsec4\0";
pub const NID_ipsec4: u32 = 750;
pub const SN_whirlpool: &[u8; 10usize] = b"whirlpool\0";
pub const NID_whirlpool: u32 = 804;
pub const SN_cryptopro: &[u8; 10usize] = b"cryptopro\0";
pub const NID_cryptopro: u32 = 805;
pub const SN_cryptocom: &[u8; 10usize] = b"cryptocom\0";
pub const NID_cryptocom: u32 = 806;
pub const SN_id_tc26: &[u8; 8usize] = b"id-tc26\0";
pub const NID_id_tc26: u32 = 974;
pub const SN_id_GostR3411_94_with_GostR3410_2001: &[u8; 36usize] =
    b"id-GostR3411-94-with-GostR3410-2001\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001: &[u8; 39usize] =
    b"GOST R 34.11-94 with GOST R 34.10-2001\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001: u32 = 807;
pub const SN_id_GostR3411_94_with_GostR3410_94: &[u8; 34usize] =
    b"id-GostR3411-94-with-GostR3410-94\0";
pub const LN_id_GostR3411_94_with_GostR3410_94: &[u8; 37usize] =
    b"GOST R 34.11-94 with GOST R 34.10-94\0";
pub const NID_id_GostR3411_94_with_GostR3410_94: u32 = 808;
pub const SN_id_GostR3411_94: &[u8; 10usize] = b"md_gost94\0";
pub const LN_id_GostR3411_94: &[u8; 16usize] = b"GOST R 34.11-94\0";
pub const NID_id_GostR3411_94: u32 = 809;
pub const SN_id_HMACGostR3411_94: &[u8; 20usize] = b"id-HMACGostR3411-94\0";
pub const LN_id_HMACGostR3411_94: &[u8; 19usize] = b"HMAC GOST 34.11-94\0";
pub const NID_id_HMACGostR3411_94: u32 = 810;
pub const SN_id_GostR3410_2001: &[u8; 9usize] = b"gost2001\0";
pub const LN_id_GostR3410_2001: &[u8; 18usize] = b"GOST R 34.10-2001\0";
pub const NID_id_GostR3410_2001: u32 = 811;
pub const SN_id_GostR3410_94: &[u8; 7usize] = b"gost94\0";
pub const LN_id_GostR3410_94: &[u8; 16usize] = b"GOST R 34.10-94\0";
pub const NID_id_GostR3410_94: u32 = 812;
pub const SN_id_Gost28147_89: &[u8; 7usize] = b"gost89\0";
pub const LN_id_Gost28147_89: &[u8; 14usize] = b"GOST 28147-89\0";
pub const NID_id_Gost28147_89: u32 = 813;
pub const SN_gost89_cnt: &[u8; 11usize] = b"gost89-cnt\0";
pub const NID_gost89_cnt: u32 = 814;
pub const SN_gost89_cnt_12: &[u8; 14usize] = b"gost89-cnt-12\0";
pub const NID_gost89_cnt_12: u32 = 975;
pub const SN_gost89_cbc: &[u8; 11usize] = b"gost89-cbc\0";
pub const NID_gost89_cbc: u32 = 1009;
pub const SN_gost89_ecb: &[u8; 11usize] = b"gost89-ecb\0";
pub const NID_gost89_ecb: u32 = 1010;
pub const SN_gost89_ctr: &[u8; 11usize] = b"gost89-ctr\0";
pub const NID_gost89_ctr: u32 = 1011;
pub const SN_id_Gost28147_89_MAC: &[u8; 9usize] = b"gost-mac\0";
pub const LN_id_Gost28147_89_MAC: &[u8; 18usize] = b"GOST 28147-89 MAC\0";
pub const NID_id_Gost28147_89_MAC: u32 = 815;
pub const SN_gost_mac_12: &[u8; 12usize] = b"gost-mac-12\0";
pub const NID_gost_mac_12: u32 = 976;
pub const SN_id_GostR3411_94_prf: &[u8; 17usize] = b"prf-gostr3411-94\0";
pub const LN_id_GostR3411_94_prf: &[u8; 20usize] = b"GOST R 34.11-94 PRF\0";
pub const NID_id_GostR3411_94_prf: u32 = 816;
pub const SN_id_GostR3410_2001DH: &[u8; 20usize] = b"id-GostR3410-2001DH\0";
pub const LN_id_GostR3410_2001DH: &[u8; 21usize] = b"GOST R 34.10-2001 DH\0";
pub const NID_id_GostR3410_2001DH: u32 = 817;
pub const SN_id_GostR3410_94DH: &[u8; 18usize] = b"id-GostR3410-94DH\0";
pub const LN_id_GostR3410_94DH: &[u8; 19usize] = b"GOST R 34.10-94 DH\0";
pub const NID_id_GostR3410_94DH: u32 = 818;
pub const SN_id_Gost28147_89_CryptoPro_KeyMeshing: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-KeyMeshing\0";
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing: u32 = 819;
pub const SN_id_Gost28147_89_None_KeyMeshing: &[u8; 32usize] = b"id-Gost28147-89-None-KeyMeshing\0";
pub const NID_id_Gost28147_89_None_KeyMeshing: u32 = 820;
pub const SN_id_GostR3411_94_TestParamSet: &[u8; 29usize] = b"id-GostR3411-94-TestParamSet\0";
pub const NID_id_GostR3411_94_TestParamSet: u32 = 821;
pub const SN_id_GostR3411_94_CryptoProParamSet: &[u8; 34usize] =
    b"id-GostR3411-94-CryptoProParamSet\0";
pub const NID_id_GostR3411_94_CryptoProParamSet: u32 = 822;
pub const SN_id_Gost28147_89_TestParamSet: &[u8; 29usize] = b"id-Gost28147-89-TestParamSet\0";
pub const NID_id_Gost28147_89_TestParamSet: u32 = 823;
pub const SN_id_Gost28147_89_CryptoPro_A_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-A-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet: u32 = 824;
pub const SN_id_Gost28147_89_CryptoPro_B_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-B-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet: u32 = 825;
pub const SN_id_Gost28147_89_CryptoPro_C_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-C-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet: u32 = 826;
pub const SN_id_Gost28147_89_CryptoPro_D_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-D-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet: u32 = 827;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: &[u8; 45usize] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: u32 = 828;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: &[u8; 45usize] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: u32 = 829;
pub const SN_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: &[u8; 41usize] =
    b"id-Gost28147-89-CryptoPro-RIC-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: u32 = 830;
pub const SN_id_GostR3410_94_TestParamSet: &[u8; 29usize] = b"id-GostR3410-94-TestParamSet\0";
pub const NID_id_GostR3410_94_TestParamSet: u32 = 831;
pub const SN_id_GostR3410_94_CryptoPro_A_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet: u32 = 832;
pub const SN_id_GostR3410_94_CryptoPro_B_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet: u32 = 833;
pub const SN_id_GostR3410_94_CryptoPro_C_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet: u32 = 834;
pub const SN_id_GostR3410_94_CryptoPro_D_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-D-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet: u32 = 835;
pub const SN_id_GostR3410_94_CryptoPro_XchA_ParamSet: &[u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet: u32 = 836;
pub const SN_id_GostR3410_94_CryptoPro_XchB_ParamSet: &[u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet: u32 = 837;
pub const SN_id_GostR3410_94_CryptoPro_XchC_ParamSet: &[u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchC-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet: u32 = 838;
pub const SN_id_GostR3410_2001_TestParamSet: &[u8; 31usize] = b"id-GostR3410-2001-TestParamSet\0";
pub const NID_id_GostR3410_2001_TestParamSet: u32 = 839;
pub const SN_id_GostR3410_2001_CryptoPro_A_ParamSet: &[u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet: u32 = 840;
pub const SN_id_GostR3410_2001_CryptoPro_B_ParamSet: &[u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet: u32 = 841;
pub const SN_id_GostR3410_2001_CryptoPro_C_ParamSet: &[u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet: u32 = 842;
pub const SN_id_GostR3410_2001_CryptoPro_XchA_ParamSet: &[u8; 42usize] =
    b"id-GostR3410-2001-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet: u32 = 843;
pub const SN_id_GostR3410_2001_CryptoPro_XchB_ParamSet: &[u8; 42usize] =
    b"id-GostR3410-2001-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet: u32 = 844;
pub const SN_id_GostR3410_94_a: &[u8; 18usize] = b"id-GostR3410-94-a\0";
pub const NID_id_GostR3410_94_a: u32 = 845;
pub const SN_id_GostR3410_94_aBis: &[u8; 21usize] = b"id-GostR3410-94-aBis\0";
pub const NID_id_GostR3410_94_aBis: u32 = 846;
pub const SN_id_GostR3410_94_b: &[u8; 18usize] = b"id-GostR3410-94-b\0";
pub const NID_id_GostR3410_94_b: u32 = 847;
pub const SN_id_GostR3410_94_bBis: &[u8; 21usize] = b"id-GostR3410-94-bBis\0";
pub const NID_id_GostR3410_94_bBis: u32 = 848;
pub const SN_id_Gost28147_89_cc: &[u8; 19usize] = b"id-Gost28147-89-cc\0";
pub const LN_id_Gost28147_89_cc: &[u8; 33usize] = b"GOST 28147-89 Cryptocom ParamSet\0";
pub const NID_id_Gost28147_89_cc: u32 = 849;
pub const SN_id_GostR3410_94_cc: &[u8; 9usize] = b"gost94cc\0";
pub const LN_id_GostR3410_94_cc: &[u8; 24usize] = b"GOST 34.10-94 Cryptocom\0";
pub const NID_id_GostR3410_94_cc: u32 = 850;
pub const SN_id_GostR3410_2001_cc: &[u8; 11usize] = b"gost2001cc\0";
pub const LN_id_GostR3410_2001_cc: &[u8; 26usize] = b"GOST 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3410_2001_cc: u32 = 851;
pub const SN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 37usize] =
    b"id-GostR3411-94-with-GostR3410-94-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 47usize] =
    b"GOST R 34.11-94 with GOST R 34.10-94 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_94_cc: u32 = 852;
pub const SN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 39usize] =
    b"id-GostR3411-94-with-GostR3410-2001-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 49usize] =
    b"GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc: u32 = 853;
pub const SN_id_GostR3410_2001_ParamSet_cc: &[u8; 30usize] = b"id-GostR3410-2001-ParamSet-cc\0";
pub const LN_id_GostR3410_2001_ParamSet_cc: &[u8; 41usize] =
    b"GOST R 3410-2001 Parameter Set Cryptocom\0";
pub const NID_id_GostR3410_2001_ParamSet_cc: u32 = 854;
pub const SN_id_tc26_algorithms: &[u8; 19usize] = b"id-tc26-algorithms\0";
pub const NID_id_tc26_algorithms: u32 = 977;
pub const SN_id_tc26_sign: &[u8; 13usize] = b"id-tc26-sign\0";
pub const NID_id_tc26_sign: u32 = 978;
pub const SN_id_GostR3410_2012_256: &[u8; 13usize] = b"gost2012_256\0";
pub const LN_id_GostR3410_2012_256: &[u8; 39usize] = b"GOST R 34.10-2012 with 256 bit modulus\0";
pub const NID_id_GostR3410_2012_256: u32 = 979;
pub const SN_id_GostR3410_2012_512: &[u8; 13usize] = b"gost2012_512\0";
pub const LN_id_GostR3410_2012_512: &[u8; 39usize] = b"GOST R 34.10-2012 with 512 bit modulus\0";
pub const NID_id_GostR3410_2012_512: u32 = 980;
pub const SN_id_tc26_digest: &[u8; 15usize] = b"id-tc26-digest\0";
pub const NID_id_tc26_digest: u32 = 981;
pub const SN_id_GostR3411_2012_256: &[u8; 14usize] = b"md_gost12_256\0";
pub const LN_id_GostR3411_2012_256: &[u8; 36usize] = b"GOST R 34.11-2012 with 256 bit hash\0";
pub const NID_id_GostR3411_2012_256: u32 = 982;
pub const SN_id_GostR3411_2012_512: &[u8; 14usize] = b"md_gost12_512\0";
pub const LN_id_GostR3411_2012_512: &[u8; 36usize] = b"GOST R 34.11-2012 with 512 bit hash\0";
pub const NID_id_GostR3411_2012_512: u32 = 983;
pub const SN_id_tc26_signwithdigest: &[u8; 23usize] = b"id-tc26-signwithdigest\0";
pub const NID_id_tc26_signwithdigest: u32 = 984;
pub const SN_id_tc26_signwithdigest_gost3410_2012_256: &[u8; 41usize] =
    b"id-tc26-signwithdigest-gost3410-2012-256\0";
pub const LN_id_tc26_signwithdigest_gost3410_2012_256: &[u8; 51usize] =
    b"GOST R 34.10-2012 with GOST R 34.11-2012 (256 bit)\0";
pub const NID_id_tc26_signwithdigest_gost3410_2012_256: u32 = 985;
pub const SN_id_tc26_signwithdigest_gost3410_2012_512: &[u8; 41usize] =
    b"id-tc26-signwithdigest-gost3410-2012-512\0";
pub const LN_id_tc26_signwithdigest_gost3410_2012_512: &[u8; 51usize] =
    b"GOST R 34.10-2012 with GOST R 34.11-2012 (512 bit)\0";
pub const NID_id_tc26_signwithdigest_gost3410_2012_512: u32 = 986;
pub const SN_id_tc26_mac: &[u8; 12usize] = b"id-tc26-mac\0";
pub const NID_id_tc26_mac: u32 = 987;
pub const SN_id_tc26_hmac_gost_3411_2012_256: &[u8; 32usize] = b"id-tc26-hmac-gost-3411-2012-256\0";
pub const LN_id_tc26_hmac_gost_3411_2012_256: &[u8; 29usize] = b"HMAC GOST 34.11-2012 256 bit\0";
pub const NID_id_tc26_hmac_gost_3411_2012_256: u32 = 988;
pub const SN_id_tc26_hmac_gost_3411_2012_512: &[u8; 32usize] = b"id-tc26-hmac-gost-3411-2012-512\0";
pub const LN_id_tc26_hmac_gost_3411_2012_512: &[u8; 29usize] = b"HMAC GOST 34.11-2012 512 bit\0";
pub const NID_id_tc26_hmac_gost_3411_2012_512: u32 = 989;
pub const SN_id_tc26_cipher: &[u8; 15usize] = b"id-tc26-cipher\0";
pub const NID_id_tc26_cipher: u32 = 990;
pub const SN_id_tc26_cipher_gostr3412_2015_magma: &[u8; 36usize] =
    b"id-tc26-cipher-gostr3412-2015-magma\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma: u32 = 1173;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm: &[u8; 45usize] =
    b"id-tc26-cipher-gostr3412-2015-magma-ctracpkm\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm: u32 = 1174;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac: &[u8; 50usize] =
    b"id-tc26-cipher-gostr3412-2015-magma-ctracpkm-omac\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac: u32 = 1175;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik: &[u8; 41usize] =
    b"id-tc26-cipher-gostr3412-2015-kuznyechik\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik: u32 = 1176;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm: &[u8; 50usize] =
    b"id-tc26-cipher-gostr3412-2015-kuznyechik-ctracpkm\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm: u32 = 1177;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac: &[u8; 55usize] =
    b"id-tc26-cipher-gostr3412-2015-kuznyechik-ctracpkm-omac\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac: u32 = 1178;
pub const SN_id_tc26_agreement: &[u8; 18usize] = b"id-tc26-agreement\0";
pub const NID_id_tc26_agreement: u32 = 991;
pub const SN_id_tc26_agreement_gost_3410_2012_256: &[u8; 37usize] =
    b"id-tc26-agreement-gost-3410-2012-256\0";
pub const NID_id_tc26_agreement_gost_3410_2012_256: u32 = 992;
pub const SN_id_tc26_agreement_gost_3410_2012_512: &[u8; 37usize] =
    b"id-tc26-agreement-gost-3410-2012-512\0";
pub const NID_id_tc26_agreement_gost_3410_2012_512: u32 = 993;
pub const SN_id_tc26_wrap: &[u8; 13usize] = b"id-tc26-wrap\0";
pub const NID_id_tc26_wrap: u32 = 1179;
pub const SN_id_tc26_wrap_gostr3412_2015_magma: &[u8; 34usize] =
    b"id-tc26-wrap-gostr3412-2015-magma\0";
pub const NID_id_tc26_wrap_gostr3412_2015_magma: u32 = 1180;
pub const SN_id_tc26_wrap_gostr3412_2015_magma_kexp15: &[u8; 41usize] =
    b"id-tc26-wrap-gostr3412-2015-magma-kexp15\0";
pub const NID_id_tc26_wrap_gostr3412_2015_magma_kexp15: u32 = 1181;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik: &[u8; 39usize] =
    b"id-tc26-wrap-gostr3412-2015-kuznyechik\0";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik: u32 = 1182;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15: &[u8; 46usize] =
    b"id-tc26-wrap-gostr3412-2015-kuznyechik-kexp15\0";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15: u32 = 1183;
pub const SN_id_tc26_constants: &[u8; 18usize] = b"id-tc26-constants\0";
pub const NID_id_tc26_constants: u32 = 994;
pub const SN_id_tc26_sign_constants: &[u8; 23usize] = b"id-tc26-sign-constants\0";
pub const NID_id_tc26_sign_constants: u32 = 995;
pub const SN_id_tc26_gost_3410_2012_256_constants: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-constants\0";
pub const NID_id_tc26_gost_3410_2012_256_constants: u32 = 1147;
pub const SN_id_tc26_gost_3410_2012_256_paramSetA: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetA\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetA: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet A\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetA: u32 = 1148;
pub const SN_id_tc26_gost_3410_2012_256_paramSetB: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetB\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetB: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet B\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetB: u32 = 1184;
pub const SN_id_tc26_gost_3410_2012_256_paramSetC: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetC\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetC: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet C\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetC: u32 = 1185;
pub const SN_id_tc26_gost_3410_2012_256_paramSetD: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetD\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetD: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet D\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetD: u32 = 1186;
pub const SN_id_tc26_gost_3410_2012_512_constants: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-constants\0";
pub const NID_id_tc26_gost_3410_2012_512_constants: u32 = 996;
pub const SN_id_tc26_gost_3410_2012_512_paramSetTest: &[u8; 40usize] =
    b"id-tc26-gost-3410-2012-512-paramSetTest\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetTest: &[u8; 50usize] =
    b"GOST R 34.10-2012 (512 bit) testing parameter set\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetTest: u32 = 997;
pub const SN_id_tc26_gost_3410_2012_512_paramSetA: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-paramSetA\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetA: &[u8; 39usize] =
    b"GOST R 34.10-2012 (512 bit) ParamSet A\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetA: u32 = 998;
pub const SN_id_tc26_gost_3410_2012_512_paramSetB: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-paramSetB\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetB: &[u8; 39usize] =
    b"GOST R 34.10-2012 (512 bit) ParamSet B\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetB: u32 = 999;
pub const SN_id_tc26_gost_3410_2012_512_paramSetC: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-paramSetC\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetC: &[u8; 39usize] =
    b"GOST R 34.10-2012 (512 bit) ParamSet C\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetC: u32 = 1149;
pub const SN_id_tc26_digest_constants: &[u8; 25usize] = b"id-tc26-digest-constants\0";
pub const NID_id_tc26_digest_constants: u32 = 1000;
pub const SN_id_tc26_cipher_constants: &[u8; 25usize] = b"id-tc26-cipher-constants\0";
pub const NID_id_tc26_cipher_constants: u32 = 1001;
pub const SN_id_tc26_gost_28147_constants: &[u8; 29usize] = b"id-tc26-gost-28147-constants\0";
pub const NID_id_tc26_gost_28147_constants: u32 = 1002;
pub const SN_id_tc26_gost_28147_param_Z: &[u8; 27usize] = b"id-tc26-gost-28147-param-Z\0";
pub const LN_id_tc26_gost_28147_param_Z: &[u8; 33usize] = b"GOST 28147-89 TC26 parameter set\0";
pub const NID_id_tc26_gost_28147_param_Z: u32 = 1003;
pub const SN_INN: &[u8; 4usize] = b"INN\0";
pub const LN_INN: &[u8; 4usize] = b"INN\0";
pub const NID_INN: u32 = 1004;
pub const SN_OGRN: &[u8; 5usize] = b"OGRN\0";
pub const LN_OGRN: &[u8; 5usize] = b"OGRN\0";
pub const NID_OGRN: u32 = 1005;
pub const SN_SNILS: &[u8; 6usize] = b"SNILS\0";
pub const LN_SNILS: &[u8; 6usize] = b"SNILS\0";
pub const NID_SNILS: u32 = 1006;
pub const SN_subjectSignTool: &[u8; 16usize] = b"subjectSignTool\0";
pub const LN_subjectSignTool: &[u8; 24usize] = b"Signing Tool of Subject\0";
pub const NID_subjectSignTool: u32 = 1007;
pub const SN_issuerSignTool: &[u8; 15usize] = b"issuerSignTool\0";
pub const LN_issuerSignTool: &[u8; 23usize] = b"Signing Tool of Issuer\0";
pub const NID_issuerSignTool: u32 = 1008;
pub const SN_grasshopper_ecb: &[u8; 16usize] = b"grasshopper-ecb\0";
pub const NID_grasshopper_ecb: u32 = 1012;
pub const SN_grasshopper_ctr: &[u8; 16usize] = b"grasshopper-ctr\0";
pub const NID_grasshopper_ctr: u32 = 1013;
pub const SN_grasshopper_ofb: &[u8; 16usize] = b"grasshopper-ofb\0";
pub const NID_grasshopper_ofb: u32 = 1014;
pub const SN_grasshopper_cbc: &[u8; 16usize] = b"grasshopper-cbc\0";
pub const NID_grasshopper_cbc: u32 = 1015;
pub const SN_grasshopper_cfb: &[u8; 16usize] = b"grasshopper-cfb\0";
pub const NID_grasshopper_cfb: u32 = 1016;
pub const SN_grasshopper_mac: &[u8; 16usize] = b"grasshopper-mac\0";
pub const NID_grasshopper_mac: u32 = 1017;
pub const SN_magma_ecb: &[u8; 10usize] = b"magma-ecb\0";
pub const NID_magma_ecb: u32 = 1187;
pub const SN_magma_ctr: &[u8; 10usize] = b"magma-ctr\0";
pub const NID_magma_ctr: u32 = 1188;
pub const SN_magma_ofb: &[u8; 10usize] = b"magma-ofb\0";
pub const NID_magma_ofb: u32 = 1189;
pub const SN_magma_cbc: &[u8; 10usize] = b"magma-cbc\0";
pub const NID_magma_cbc: u32 = 1190;
pub const SN_magma_cfb: &[u8; 10usize] = b"magma-cfb\0";
pub const NID_magma_cfb: u32 = 1191;
pub const SN_magma_mac: &[u8; 10usize] = b"magma-mac\0";
pub const NID_magma_mac: u32 = 1192;
pub const SN_camellia_128_cbc: &[u8; 17usize] = b"CAMELLIA-128-CBC\0";
pub const LN_camellia_128_cbc: &[u8; 17usize] = b"camellia-128-cbc\0";
pub const NID_camellia_128_cbc: u32 = 751;
pub const SN_camellia_192_cbc: &[u8; 17usize] = b"CAMELLIA-192-CBC\0";
pub const LN_camellia_192_cbc: &[u8; 17usize] = b"camellia-192-cbc\0";
pub const NID_camellia_192_cbc: u32 = 752;
pub const SN_camellia_256_cbc: &[u8; 17usize] = b"CAMELLIA-256-CBC\0";
pub const LN_camellia_256_cbc: &[u8; 17usize] = b"camellia-256-cbc\0";
pub const NID_camellia_256_cbc: u32 = 753;
pub const SN_id_camellia128_wrap: &[u8; 20usize] = b"id-camellia128-wrap\0";
pub const NID_id_camellia128_wrap: u32 = 907;
pub const SN_id_camellia192_wrap: &[u8; 20usize] = b"id-camellia192-wrap\0";
pub const NID_id_camellia192_wrap: u32 = 908;
pub const SN_id_camellia256_wrap: &[u8; 20usize] = b"id-camellia256-wrap\0";
pub const NID_id_camellia256_wrap: u32 = 909;
pub const SN_camellia_128_ecb: &[u8; 17usize] = b"CAMELLIA-128-ECB\0";
pub const LN_camellia_128_ecb: &[u8; 17usize] = b"camellia-128-ecb\0";
pub const NID_camellia_128_ecb: u32 = 754;
pub const SN_camellia_128_ofb128: &[u8; 17usize] = b"CAMELLIA-128-OFB\0";
pub const LN_camellia_128_ofb128: &[u8; 17usize] = b"camellia-128-ofb\0";
pub const NID_camellia_128_ofb128: u32 = 766;
pub const SN_camellia_128_cfb128: &[u8; 17usize] = b"CAMELLIA-128-CFB\0";
pub const LN_camellia_128_cfb128: &[u8; 17usize] = b"camellia-128-cfb\0";
pub const NID_camellia_128_cfb128: u32 = 757;
pub const SN_camellia_128_gcm: &[u8; 17usize] = b"CAMELLIA-128-GCM\0";
pub const LN_camellia_128_gcm: &[u8; 17usize] = b"camellia-128-gcm\0";
pub const NID_camellia_128_gcm: u32 = 961;
pub const SN_camellia_128_ccm: &[u8; 17usize] = b"CAMELLIA-128-CCM\0";
pub const LN_camellia_128_ccm: &[u8; 17usize] = b"camellia-128-ccm\0";
pub const NID_camellia_128_ccm: u32 = 962;
pub const SN_camellia_128_ctr: &[u8; 17usize] = b"CAMELLIA-128-CTR\0";
pub const LN_camellia_128_ctr: &[u8; 17usize] = b"camellia-128-ctr\0";
pub const NID_camellia_128_ctr: u32 = 963;
pub const SN_camellia_128_cmac: &[u8; 18usize] = b"CAMELLIA-128-CMAC\0";
pub const LN_camellia_128_cmac: &[u8; 18usize] = b"camellia-128-cmac\0";
pub const NID_camellia_128_cmac: u32 = 964;
pub const SN_camellia_192_ecb: &[u8; 17usize] = b"CAMELLIA-192-ECB\0";
pub const LN_camellia_192_ecb: &[u8; 17usize] = b"camellia-192-ecb\0";
pub const NID_camellia_192_ecb: u32 = 755;
pub const SN_camellia_192_ofb128: &[u8; 17usize] = b"CAMELLIA-192-OFB\0";
pub const LN_camellia_192_ofb128: &[u8; 17usize] = b"camellia-192-ofb\0";
pub const NID_camellia_192_ofb128: u32 = 767;
pub const SN_camellia_192_cfb128: &[u8; 17usize] = b"CAMELLIA-192-CFB\0";
pub const LN_camellia_192_cfb128: &[u8; 17usize] = b"camellia-192-cfb\0";
pub const NID_camellia_192_cfb128: u32 = 758;
pub const SN_camellia_192_gcm: &[u8; 17usize] = b"CAMELLIA-192-GCM\0";
pub const LN_camellia_192_gcm: &[u8; 17usize] = b"camellia-192-gcm\0";
pub const NID_camellia_192_gcm: u32 = 965;
pub const SN_camellia_192_ccm: &[u8; 17usize] = b"CAMELLIA-192-CCM\0";
pub const LN_camellia_192_ccm: &[u8; 17usize] = b"camellia-192-ccm\0";
pub const NID_camellia_192_ccm: u32 = 966;
pub const SN_camellia_192_ctr: &[u8; 17usize] = b"CAMELLIA-192-CTR\0";
pub const LN_camellia_192_ctr: &[u8; 17usize] = b"camellia-192-ctr\0";
pub const NID_camellia_192_ctr: u32 = 967;
pub const SN_camellia_192_cmac: &[u8; 18usize] = b"CAMELLIA-192-CMAC\0";
pub const LN_camellia_192_cmac: &[u8; 18usize] = b"camellia-192-cmac\0";
pub const NID_camellia_192_cmac: u32 = 968;
pub const SN_camellia_256_ecb: &[u8; 17usize] = b"CAMELLIA-256-ECB\0";
pub const LN_camellia_256_ecb: &[u8; 17usize] = b"camellia-256-ecb\0";
pub const NID_camellia_256_ecb: u32 = 756;
pub const SN_camellia_256_ofb128: &[u8; 17usize] = b"CAMELLIA-256-OFB\0";
pub const LN_camellia_256_ofb128: &[u8; 17usize] = b"camellia-256-ofb\0";
pub const NID_camellia_256_ofb128: u32 = 768;
pub const SN_camellia_256_cfb128: &[u8; 17usize] = b"CAMELLIA-256-CFB\0";
pub const LN_camellia_256_cfb128: &[u8; 17usize] = b"camellia-256-cfb\0";
pub const NID_camellia_256_cfb128: u32 = 759;
pub const SN_camellia_256_gcm: &[u8; 17usize] = b"CAMELLIA-256-GCM\0";
pub const LN_camellia_256_gcm: &[u8; 17usize] = b"camellia-256-gcm\0";
pub const NID_camellia_256_gcm: u32 = 969;
pub const SN_camellia_256_ccm: &[u8; 17usize] = b"CAMELLIA-256-CCM\0";
pub const LN_camellia_256_ccm: &[u8; 17usize] = b"camellia-256-ccm\0";
pub const NID_camellia_256_ccm: u32 = 970;
pub const SN_camellia_256_ctr: &[u8; 17usize] = b"CAMELLIA-256-CTR\0";
pub const LN_camellia_256_ctr: &[u8; 17usize] = b"camellia-256-ctr\0";
pub const NID_camellia_256_ctr: u32 = 971;
pub const SN_camellia_256_cmac: &[u8; 18usize] = b"CAMELLIA-256-CMAC\0";
pub const LN_camellia_256_cmac: &[u8; 18usize] = b"camellia-256-cmac\0";
pub const NID_camellia_256_cmac: u32 = 972;
pub const SN_camellia_128_cfb1: &[u8; 18usize] = b"CAMELLIA-128-CFB1\0";
pub const LN_camellia_128_cfb1: &[u8; 18usize] = b"camellia-128-cfb1\0";
pub const NID_camellia_128_cfb1: u32 = 760;
pub const SN_camellia_192_cfb1: &[u8; 18usize] = b"CAMELLIA-192-CFB1\0";
pub const LN_camellia_192_cfb1: &[u8; 18usize] = b"camellia-192-cfb1\0";
pub const NID_camellia_192_cfb1: u32 = 761;
pub const SN_camellia_256_cfb1: &[u8; 18usize] = b"CAMELLIA-256-CFB1\0";
pub const LN_camellia_256_cfb1: &[u8; 18usize] = b"camellia-256-cfb1\0";
pub const NID_camellia_256_cfb1: u32 = 762;
pub const SN_camellia_128_cfb8: &[u8; 18usize] = b"CAMELLIA-128-CFB8\0";
pub const LN_camellia_128_cfb8: &[u8; 18usize] = b"camellia-128-cfb8\0";
pub const NID_camellia_128_cfb8: u32 = 763;
pub const SN_camellia_192_cfb8: &[u8; 18usize] = b"CAMELLIA-192-CFB8\0";
pub const LN_camellia_192_cfb8: &[u8; 18usize] = b"camellia-192-cfb8\0";
pub const NID_camellia_192_cfb8: u32 = 764;
pub const SN_camellia_256_cfb8: &[u8; 18usize] = b"CAMELLIA-256-CFB8\0";
pub const LN_camellia_256_cfb8: &[u8; 18usize] = b"camellia-256-cfb8\0";
pub const NID_camellia_256_cfb8: u32 = 765;
pub const SN_aria_128_ecb: &[u8; 13usize] = b"ARIA-128-ECB\0";
pub const LN_aria_128_ecb: &[u8; 13usize] = b"aria-128-ecb\0";
pub const NID_aria_128_ecb: u32 = 1065;
pub const SN_aria_128_cbc: &[u8; 13usize] = b"ARIA-128-CBC\0";
pub const LN_aria_128_cbc: &[u8; 13usize] = b"aria-128-cbc\0";
pub const NID_aria_128_cbc: u32 = 1066;
pub const SN_aria_128_cfb128: &[u8; 13usize] = b"ARIA-128-CFB\0";
pub const LN_aria_128_cfb128: &[u8; 13usize] = b"aria-128-cfb\0";
pub const NID_aria_128_cfb128: u32 = 1067;
pub const SN_aria_128_ofb128: &[u8; 13usize] = b"ARIA-128-OFB\0";
pub const LN_aria_128_ofb128: &[u8; 13usize] = b"aria-128-ofb\0";
pub const NID_aria_128_ofb128: u32 = 1068;
pub const SN_aria_128_ctr: &[u8; 13usize] = b"ARIA-128-CTR\0";
pub const LN_aria_128_ctr: &[u8; 13usize] = b"aria-128-ctr\0";
pub const NID_aria_128_ctr: u32 = 1069;
pub const SN_aria_192_ecb: &[u8; 13usize] = b"ARIA-192-ECB\0";
pub const LN_aria_192_ecb: &[u8; 13usize] = b"aria-192-ecb\0";
pub const NID_aria_192_ecb: u32 = 1070;
pub const SN_aria_192_cbc: &[u8; 13usize] = b"ARIA-192-CBC\0";
pub const LN_aria_192_cbc: &[u8; 13usize] = b"aria-192-cbc\0";
pub const NID_aria_192_cbc: u32 = 1071;
pub const SN_aria_192_cfb128: &[u8; 13usize] = b"ARIA-192-CFB\0";
pub const LN_aria_192_cfb128: &[u8; 13usize] = b"aria-192-cfb\0";
pub const NID_aria_192_cfb128: u32 = 1072;
pub const SN_aria_192_ofb128: &[u8; 13usize] = b"ARIA-192-OFB\0";
pub const LN_aria_192_ofb128: &[u8; 13usize] = b"aria-192-ofb\0";
pub const NID_aria_192_ofb128: u32 = 1073;
pub const SN_aria_192_ctr: &[u8; 13usize] = b"ARIA-192-CTR\0";
pub const LN_aria_192_ctr: &[u8; 13usize] = b"aria-192-ctr\0";
pub const NID_aria_192_ctr: u32 = 1074;
pub const SN_aria_256_ecb: &[u8; 13usize] = b"ARIA-256-ECB\0";
pub const LN_aria_256_ecb: &[u8; 13usize] = b"aria-256-ecb\0";
pub const NID_aria_256_ecb: u32 = 1075;
pub const SN_aria_256_cbc: &[u8; 13usize] = b"ARIA-256-CBC\0";
pub const LN_aria_256_cbc: &[u8; 13usize] = b"aria-256-cbc\0";
pub const NID_aria_256_cbc: u32 = 1076;
pub const SN_aria_256_cfb128: &[u8; 13usize] = b"ARIA-256-CFB\0";
pub const LN_aria_256_cfb128: &[u8; 13usize] = b"aria-256-cfb\0";
pub const NID_aria_256_cfb128: u32 = 1077;
pub const SN_aria_256_ofb128: &[u8; 13usize] = b"ARIA-256-OFB\0";
pub const LN_aria_256_ofb128: &[u8; 13usize] = b"aria-256-ofb\0";
pub const NID_aria_256_ofb128: u32 = 1078;
pub const SN_aria_256_ctr: &[u8; 13usize] = b"ARIA-256-CTR\0";
pub const LN_aria_256_ctr: &[u8; 13usize] = b"aria-256-ctr\0";
pub const NID_aria_256_ctr: u32 = 1079;
pub const SN_aria_128_cfb1: &[u8; 14usize] = b"ARIA-128-CFB1\0";
pub const LN_aria_128_cfb1: &[u8; 14usize] = b"aria-128-cfb1\0";
pub const NID_aria_128_cfb1: u32 = 1080;
pub const SN_aria_192_cfb1: &[u8; 14usize] = b"ARIA-192-CFB1\0";
pub const LN_aria_192_cfb1: &[u8; 14usize] = b"aria-192-cfb1\0";
pub const NID_aria_192_cfb1: u32 = 1081;
pub const SN_aria_256_cfb1: &[u8; 14usize] = b"ARIA-256-CFB1\0";
pub const LN_aria_256_cfb1: &[u8; 14usize] = b"aria-256-cfb1\0";
pub const NID_aria_256_cfb1: u32 = 1082;
pub const SN_aria_128_cfb8: &[u8; 14usize] = b"ARIA-128-CFB8\0";
pub const LN_aria_128_cfb8: &[u8; 14usize] = b"aria-128-cfb8\0";
pub const NID_aria_128_cfb8: u32 = 1083;
pub const SN_aria_192_cfb8: &[u8; 14usize] = b"ARIA-192-CFB8\0";
pub const LN_aria_192_cfb8: &[u8; 14usize] = b"aria-192-cfb8\0";
pub const NID_aria_192_cfb8: u32 = 1084;
pub const SN_aria_256_cfb8: &[u8; 14usize] = b"ARIA-256-CFB8\0";
pub const LN_aria_256_cfb8: &[u8; 14usize] = b"aria-256-cfb8\0";
pub const NID_aria_256_cfb8: u32 = 1085;
pub const SN_aria_128_ccm: &[u8; 13usize] = b"ARIA-128-CCM\0";
pub const LN_aria_128_ccm: &[u8; 13usize] = b"aria-128-ccm\0";
pub const NID_aria_128_ccm: u32 = 1120;
pub const SN_aria_192_ccm: &[u8; 13usize] = b"ARIA-192-CCM\0";
pub const LN_aria_192_ccm: &[u8; 13usize] = b"aria-192-ccm\0";
pub const NID_aria_192_ccm: u32 = 1121;
pub const SN_aria_256_ccm: &[u8; 13usize] = b"ARIA-256-CCM\0";
pub const LN_aria_256_ccm: &[u8; 13usize] = b"aria-256-ccm\0";
pub const NID_aria_256_ccm: u32 = 1122;
pub const SN_aria_128_gcm: &[u8; 13usize] = b"ARIA-128-GCM\0";
pub const LN_aria_128_gcm: &[u8; 13usize] = b"aria-128-gcm\0";
pub const NID_aria_128_gcm: u32 = 1123;
pub const SN_aria_192_gcm: &[u8; 13usize] = b"ARIA-192-GCM\0";
pub const LN_aria_192_gcm: &[u8; 13usize] = b"aria-192-gcm\0";
pub const NID_aria_192_gcm: u32 = 1124;
pub const SN_aria_256_gcm: &[u8; 13usize] = b"ARIA-256-GCM\0";
pub const LN_aria_256_gcm: &[u8; 13usize] = b"aria-256-gcm\0";
pub const NID_aria_256_gcm: u32 = 1125;
pub const SN_kisa: &[u8; 5usize] = b"KISA\0";
pub const LN_kisa: &[u8; 5usize] = b"kisa\0";
pub const NID_kisa: u32 = 773;
pub const SN_seed_ecb: &[u8; 9usize] = b"SEED-ECB\0";
pub const LN_seed_ecb: &[u8; 9usize] = b"seed-ecb\0";
pub const NID_seed_ecb: u32 = 776;
pub const SN_seed_cbc: &[u8; 9usize] = b"SEED-CBC\0";
pub const LN_seed_cbc: &[u8; 9usize] = b"seed-cbc\0";
pub const NID_seed_cbc: u32 = 777;
pub const SN_seed_cfb128: &[u8; 9usize] = b"SEED-CFB\0";
pub const LN_seed_cfb128: &[u8; 9usize] = b"seed-cfb\0";
pub const NID_seed_cfb128: u32 = 779;
pub const SN_seed_ofb128: &[u8; 9usize] = b"SEED-OFB\0";
pub const LN_seed_ofb128: &[u8; 9usize] = b"seed-ofb\0";
pub const NID_seed_ofb128: u32 = 778;
pub const SN_sm4_ecb: &[u8; 8usize] = b"SM4-ECB\0";
pub const LN_sm4_ecb: &[u8; 8usize] = b"sm4-ecb\0";
pub const NID_sm4_ecb: u32 = 1133;
pub const SN_sm4_cbc: &[u8; 8usize] = b"SM4-CBC\0";
pub const LN_sm4_cbc: &[u8; 8usize] = b"sm4-cbc\0";
pub const NID_sm4_cbc: u32 = 1134;
pub const SN_sm4_ofb128: &[u8; 8usize] = b"SM4-OFB\0";
pub const LN_sm4_ofb128: &[u8; 8usize] = b"sm4-ofb\0";
pub const NID_sm4_ofb128: u32 = 1135;
pub const SN_sm4_cfb128: &[u8; 8usize] = b"SM4-CFB\0";
pub const LN_sm4_cfb128: &[u8; 8usize] = b"sm4-cfb\0";
pub const NID_sm4_cfb128: u32 = 1137;
pub const SN_sm4_cfb1: &[u8; 9usize] = b"SM4-CFB1\0";
pub const LN_sm4_cfb1: &[u8; 9usize] = b"sm4-cfb1\0";
pub const NID_sm4_cfb1: u32 = 1136;
pub const SN_sm4_cfb8: &[u8; 9usize] = b"SM4-CFB8\0";
pub const LN_sm4_cfb8: &[u8; 9usize] = b"sm4-cfb8\0";
pub const NID_sm4_cfb8: u32 = 1138;
pub const SN_sm4_ctr: &[u8; 8usize] = b"SM4-CTR\0";
pub const LN_sm4_ctr: &[u8; 8usize] = b"sm4-ctr\0";
pub const NID_sm4_ctr: u32 = 1139;
pub const SN_hmac: &[u8; 5usize] = b"HMAC\0";
pub const LN_hmac: &[u8; 5usize] = b"hmac\0";
pub const NID_hmac: u32 = 855;
pub const SN_cmac: &[u8; 5usize] = b"CMAC\0";
pub const LN_cmac: &[u8; 5usize] = b"cmac\0";
pub const NID_cmac: u32 = 894;
pub const SN_rc4_hmac_md5: &[u8; 13usize] = b"RC4-HMAC-MD5\0";
pub const LN_rc4_hmac_md5: &[u8; 13usize] = b"rc4-hmac-md5\0";
pub const NID_rc4_hmac_md5: u32 = 915;
pub const SN_aes_128_cbc_hmac_sha1: &[u8; 22usize] = b"AES-128-CBC-HMAC-SHA1\0";
pub const LN_aes_128_cbc_hmac_sha1: &[u8; 22usize] = b"aes-128-cbc-hmac-sha1\0";
pub const NID_aes_128_cbc_hmac_sha1: u32 = 916;
pub const SN_aes_192_cbc_hmac_sha1: &[u8; 22usize] = b"AES-192-CBC-HMAC-SHA1\0";
pub const LN_aes_192_cbc_hmac_sha1: &[u8; 22usize] = b"aes-192-cbc-hmac-sha1\0";
pub const NID_aes_192_cbc_hmac_sha1: u32 = 917;
pub const SN_aes_256_cbc_hmac_sha1: &[u8; 22usize] = b"AES-256-CBC-HMAC-SHA1\0";
pub const LN_aes_256_cbc_hmac_sha1: &[u8; 22usize] = b"aes-256-cbc-hmac-sha1\0";
pub const NID_aes_256_cbc_hmac_sha1: u32 = 918;
pub const SN_aes_128_cbc_hmac_sha256: &[u8; 24usize] = b"AES-128-CBC-HMAC-SHA256\0";
pub const LN_aes_128_cbc_hmac_sha256: &[u8; 24usize] = b"aes-128-cbc-hmac-sha256\0";
pub const NID_aes_128_cbc_hmac_sha256: u32 = 948;
pub const SN_aes_192_cbc_hmac_sha256: &[u8; 24usize] = b"AES-192-CBC-HMAC-SHA256\0";
pub const LN_aes_192_cbc_hmac_sha256: &[u8; 24usize] = b"aes-192-cbc-hmac-sha256\0";
pub const NID_aes_192_cbc_hmac_sha256: u32 = 949;
pub const SN_aes_256_cbc_hmac_sha256: &[u8; 24usize] = b"AES-256-CBC-HMAC-SHA256\0";
pub const LN_aes_256_cbc_hmac_sha256: &[u8; 24usize] = b"aes-256-cbc-hmac-sha256\0";
pub const NID_aes_256_cbc_hmac_sha256: u32 = 950;
pub const SN_chacha20_poly1305: &[u8; 18usize] = b"ChaCha20-Poly1305\0";
pub const LN_chacha20_poly1305: &[u8; 18usize] = b"chacha20-poly1305\0";
pub const NID_chacha20_poly1305: u32 = 1018;
pub const SN_chacha20: &[u8; 9usize] = b"ChaCha20\0";
pub const LN_chacha20: &[u8; 9usize] = b"chacha20\0";
pub const NID_chacha20: u32 = 1019;
pub const SN_dhpublicnumber: &[u8; 15usize] = b"dhpublicnumber\0";
pub const LN_dhpublicnumber: &[u8; 9usize] = b"X9.42 DH\0";
pub const NID_dhpublicnumber: u32 = 920;
pub const SN_brainpoolP160r1: &[u8; 16usize] = b"brainpoolP160r1\0";
pub const NID_brainpoolP160r1: u32 = 921;
pub const SN_brainpoolP160t1: &[u8; 16usize] = b"brainpoolP160t1\0";
pub const NID_brainpoolP160t1: u32 = 922;
pub const SN_brainpoolP192r1: &[u8; 16usize] = b"brainpoolP192r1\0";
pub const NID_brainpoolP192r1: u32 = 923;
pub const SN_brainpoolP192t1: &[u8; 16usize] = b"brainpoolP192t1\0";
pub const NID_brainpoolP192t1: u32 = 924;
pub const SN_brainpoolP224r1: &[u8; 16usize] = b"brainpoolP224r1\0";
pub const NID_brainpoolP224r1: u32 = 925;
pub const SN_brainpoolP224t1: &[u8; 16usize] = b"brainpoolP224t1\0";
pub const NID_brainpoolP224t1: u32 = 926;
pub const SN_brainpoolP256r1: &[u8; 16usize] = b"brainpoolP256r1\0";
pub const NID_brainpoolP256r1: u32 = 927;
pub const SN_brainpoolP256t1: &[u8; 16usize] = b"brainpoolP256t1\0";
pub const NID_brainpoolP256t1: u32 = 928;
pub const SN_brainpoolP320r1: &[u8; 16usize] = b"brainpoolP320r1\0";
pub const NID_brainpoolP320r1: u32 = 929;
pub const SN_brainpoolP320t1: &[u8; 16usize] = b"brainpoolP320t1\0";
pub const NID_brainpoolP320t1: u32 = 930;
pub const SN_brainpoolP384r1: &[u8; 16usize] = b"brainpoolP384r1\0";
pub const NID_brainpoolP384r1: u32 = 931;
pub const SN_brainpoolP384t1: &[u8; 16usize] = b"brainpoolP384t1\0";
pub const NID_brainpoolP384t1: u32 = 932;
pub const SN_brainpoolP512r1: &[u8; 16usize] = b"brainpoolP512r1\0";
pub const NID_brainpoolP512r1: u32 = 933;
pub const SN_brainpoolP512t1: &[u8; 16usize] = b"brainpoolP512t1\0";
pub const NID_brainpoolP512t1: u32 = 934;
pub const SN_dhSinglePass_stdDH_sha1kdf_scheme: &[u8; 34usize] =
    b"dhSinglePass-stdDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme: u32 = 936;
pub const SN_dhSinglePass_stdDH_sha224kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme: u32 = 937;
pub const SN_dhSinglePass_stdDH_sha256kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme: u32 = 938;
pub const SN_dhSinglePass_stdDH_sha384kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme: u32 = 939;
pub const SN_dhSinglePass_stdDH_sha512kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme: u32 = 940;
pub const SN_dhSinglePass_cofactorDH_sha1kdf_scheme: &[u8; 39usize] =
    b"dhSinglePass-cofactorDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme: u32 = 941;
pub const SN_dhSinglePass_cofactorDH_sha224kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme: u32 = 942;
pub const SN_dhSinglePass_cofactorDH_sha256kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme: u32 = 943;
pub const SN_dhSinglePass_cofactorDH_sha384kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme: u32 = 944;
pub const SN_dhSinglePass_cofactorDH_sha512kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme: u32 = 945;
pub const SN_dh_std_kdf: &[u8; 11usize] = b"dh-std-kdf\0";
pub const NID_dh_std_kdf: u32 = 946;
pub const SN_dh_cofactor_kdf: &[u8; 16usize] = b"dh-cofactor-kdf\0";
pub const NID_dh_cofactor_kdf: u32 = 947;
pub const SN_ct_precert_scts: &[u8; 16usize] = b"ct_precert_scts\0";
pub const LN_ct_precert_scts: &[u8; 23usize] = b"CT Precertificate SCTs\0";
pub const NID_ct_precert_scts: u32 = 951;
pub const SN_ct_precert_poison: &[u8; 18usize] = b"ct_precert_poison\0";
pub const LN_ct_precert_poison: &[u8; 25usize] = b"CT Precertificate Poison\0";
pub const NID_ct_precert_poison: u32 = 952;
pub const SN_ct_precert_signer: &[u8; 18usize] = b"ct_precert_signer\0";
pub const LN_ct_precert_signer: &[u8; 25usize] = b"CT Precertificate Signer\0";
pub const NID_ct_precert_signer: u32 = 953;
pub const SN_ct_cert_scts: &[u8; 13usize] = b"ct_cert_scts\0";
pub const LN_ct_cert_scts: &[u8; 20usize] = b"CT Certificate SCTs\0";
pub const NID_ct_cert_scts: u32 = 954;
pub const SN_jurisdictionLocalityName: &[u8; 14usize] = b"jurisdictionL\0";
pub const LN_jurisdictionLocalityName: &[u8; 25usize] = b"jurisdictionLocalityName\0";
pub const NID_jurisdictionLocalityName: u32 = 955;
pub const SN_jurisdictionStateOrProvinceName: &[u8; 15usize] = b"jurisdictionST\0";
pub const LN_jurisdictionStateOrProvinceName: &[u8; 32usize] = b"jurisdictionStateOrProvinceName\0";
pub const NID_jurisdictionStateOrProvinceName: u32 = 956;
pub const SN_jurisdictionCountryName: &[u8; 14usize] = b"jurisdictionC\0";
pub const LN_jurisdictionCountryName: &[u8; 24usize] = b"jurisdictionCountryName\0";
pub const NID_jurisdictionCountryName: u32 = 957;
pub const SN_id_scrypt: &[u8; 10usize] = b"id-scrypt\0";
pub const LN_id_scrypt: &[u8; 7usize] = b"scrypt\0";
pub const NID_id_scrypt: u32 = 973;
pub const SN_tls1_prf: &[u8; 9usize] = b"TLS1-PRF\0";
pub const LN_tls1_prf: &[u8; 9usize] = b"tls1-prf\0";
pub const NID_tls1_prf: u32 = 1021;
pub const SN_hkdf: &[u8; 5usize] = b"HKDF\0";
pub const LN_hkdf: &[u8; 5usize] = b"hkdf\0";
pub const NID_hkdf: u32 = 1036;
pub const SN_id_pkinit: &[u8; 10usize] = b"id-pkinit\0";
pub const NID_id_pkinit: u32 = 1031;
pub const SN_pkInitClientAuth: &[u8; 17usize] = b"pkInitClientAuth\0";
pub const LN_pkInitClientAuth: &[u8; 19usize] = b"PKINIT Client Auth\0";
pub const NID_pkInitClientAuth: u32 = 1032;
pub const SN_pkInitKDC: &[u8; 10usize] = b"pkInitKDC\0";
pub const LN_pkInitKDC: &[u8; 21usize] = b"Signing KDC Response\0";
pub const NID_pkInitKDC: u32 = 1033;
pub const SN_X25519: &[u8; 7usize] = b"X25519\0";
pub const NID_X25519: u32 = 1034;
pub const SN_X448: &[u8; 5usize] = b"X448\0";
pub const NID_X448: u32 = 1035;
pub const SN_ED25519: &[u8; 8usize] = b"ED25519\0";
pub const NID_ED25519: u32 = 1087;
pub const SN_ED448: &[u8; 6usize] = b"ED448\0";
pub const NID_ED448: u32 = 1088;
pub const SN_kx_rsa: &[u8; 6usize] = b"KxRSA\0";
pub const LN_kx_rsa: &[u8; 7usize] = b"kx-rsa\0";
pub const NID_kx_rsa: u32 = 1037;
pub const SN_kx_ecdhe: &[u8; 8usize] = b"KxECDHE\0";
pub const LN_kx_ecdhe: &[u8; 9usize] = b"kx-ecdhe\0";
pub const NID_kx_ecdhe: u32 = 1038;
pub const SN_kx_dhe: &[u8; 6usize] = b"KxDHE\0";
pub const LN_kx_dhe: &[u8; 7usize] = b"kx-dhe\0";
pub const NID_kx_dhe: u32 = 1039;
pub const SN_kx_ecdhe_psk: &[u8; 12usize] = b"KxECDHE-PSK\0";
pub const LN_kx_ecdhe_psk: &[u8; 13usize] = b"kx-ecdhe-psk\0";
pub const NID_kx_ecdhe_psk: u32 = 1040;
pub const SN_kx_dhe_psk: &[u8; 10usize] = b"KxDHE-PSK\0";
pub const LN_kx_dhe_psk: &[u8; 11usize] = b"kx-dhe-psk\0";
pub const NID_kx_dhe_psk: u32 = 1041;
pub const SN_kx_rsa_psk: &[u8; 10usize] = b"KxRSA_PSK\0";
pub const LN_kx_rsa_psk: &[u8; 11usize] = b"kx-rsa-psk\0";
pub const NID_kx_rsa_psk: u32 = 1042;
pub const SN_kx_psk: &[u8; 6usize] = b"KxPSK\0";
pub const LN_kx_psk: &[u8; 7usize] = b"kx-psk\0";
pub const NID_kx_psk: u32 = 1043;
pub const SN_kx_srp: &[u8; 6usize] = b"KxSRP\0";
pub const LN_kx_srp: &[u8; 7usize] = b"kx-srp\0";
pub const NID_kx_srp: u32 = 1044;
pub const SN_kx_gost: &[u8; 7usize] = b"KxGOST\0";
pub const LN_kx_gost: &[u8; 8usize] = b"kx-gost\0";
pub const NID_kx_gost: u32 = 1045;
pub const SN_kx_any: &[u8; 6usize] = b"KxANY\0";
pub const LN_kx_any: &[u8; 7usize] = b"kx-any\0";
pub const NID_kx_any: u32 = 1063;
pub const SN_auth_rsa: &[u8; 8usize] = b"AuthRSA\0";
pub const LN_auth_rsa: &[u8; 9usize] = b"auth-rsa\0";
pub const NID_auth_rsa: u32 = 1046;
pub const SN_auth_ecdsa: &[u8; 10usize] = b"AuthECDSA\0";
pub const LN_auth_ecdsa: &[u8; 11usize] = b"auth-ecdsa\0";
pub const NID_auth_ecdsa: u32 = 1047;
pub const SN_auth_psk: &[u8; 8usize] = b"AuthPSK\0";
pub const LN_auth_psk: &[u8; 9usize] = b"auth-psk\0";
pub const NID_auth_psk: u32 = 1048;
pub const SN_auth_dss: &[u8; 8usize] = b"AuthDSS\0";
pub const LN_auth_dss: &[u8; 9usize] = b"auth-dss\0";
pub const NID_auth_dss: u32 = 1049;
pub const SN_auth_gost01: &[u8; 11usize] = b"AuthGOST01\0";
pub const LN_auth_gost01: &[u8; 12usize] = b"auth-gost01\0";
pub const NID_auth_gost01: u32 = 1050;
pub const SN_auth_gost12: &[u8; 11usize] = b"AuthGOST12\0";
pub const LN_auth_gost12: &[u8; 12usize] = b"auth-gost12\0";
pub const NID_auth_gost12: u32 = 1051;
pub const SN_auth_srp: &[u8; 8usize] = b"AuthSRP\0";
pub const LN_auth_srp: &[u8; 9usize] = b"auth-srp\0";
pub const NID_auth_srp: u32 = 1052;
pub const SN_auth_null: &[u8; 9usize] = b"AuthNULL\0";
pub const LN_auth_null: &[u8; 10usize] = b"auth-null\0";
pub const NID_auth_null: u32 = 1053;
pub const SN_auth_any: &[u8; 8usize] = b"AuthANY\0";
pub const LN_auth_any: &[u8; 9usize] = b"auth-any\0";
pub const NID_auth_any: u32 = 1064;
pub const SN_poly1305: &[u8; 9usize] = b"Poly1305\0";
pub const LN_poly1305: &[u8; 9usize] = b"poly1305\0";
pub const NID_poly1305: u32 = 1061;
pub const SN_siphash: &[u8; 8usize] = b"SipHash\0";
pub const LN_siphash: &[u8; 8usize] = b"siphash\0";
pub const NID_siphash: u32 = 1062;
pub const SN_ffdhe2048: &[u8; 10usize] = b"ffdhe2048\0";
pub const NID_ffdhe2048: u32 = 1126;
pub const SN_ffdhe3072: &[u8; 10usize] = b"ffdhe3072\0";
pub const NID_ffdhe3072: u32 = 1127;
pub const SN_ffdhe4096: &[u8; 10usize] = b"ffdhe4096\0";
pub const NID_ffdhe4096: u32 = 1128;
pub const SN_ffdhe6144: &[u8; 10usize] = b"ffdhe6144\0";
pub const NID_ffdhe6144: u32 = 1129;
pub const SN_ffdhe8192: &[u8; 10usize] = b"ffdhe8192\0";
pub const NID_ffdhe8192: u32 = 1130;
pub const SN_ISO_UA: &[u8; 7usize] = b"ISO-UA\0";
pub const NID_ISO_UA: u32 = 1150;
pub const SN_ua_pki: &[u8; 7usize] = b"ua-pki\0";
pub const NID_ua_pki: u32 = 1151;
pub const SN_dstu28147: &[u8; 10usize] = b"dstu28147\0";
pub const LN_dstu28147: &[u8; 21usize] = b"DSTU Gost 28147-2009\0";
pub const NID_dstu28147: u32 = 1152;
pub const SN_dstu28147_ofb: &[u8; 14usize] = b"dstu28147-ofb\0";
pub const LN_dstu28147_ofb: &[u8; 30usize] = b"DSTU Gost 28147-2009 OFB mode\0";
pub const NID_dstu28147_ofb: u32 = 1153;
pub const SN_dstu28147_cfb: &[u8; 14usize] = b"dstu28147-cfb\0";
pub const LN_dstu28147_cfb: &[u8; 30usize] = b"DSTU Gost 28147-2009 CFB mode\0";
pub const NID_dstu28147_cfb: u32 = 1154;
pub const SN_dstu28147_wrap: &[u8; 15usize] = b"dstu28147-wrap\0";
pub const LN_dstu28147_wrap: &[u8; 30usize] = b"DSTU Gost 28147-2009 key wrap\0";
pub const NID_dstu28147_wrap: u32 = 1155;
pub const SN_hmacWithDstu34311: &[u8; 18usize] = b"hmacWithDstu34311\0";
pub const LN_hmacWithDstu34311: &[u8; 24usize] = b"HMAC DSTU Gost 34311-95\0";
pub const NID_hmacWithDstu34311: u32 = 1156;
pub const SN_dstu34311: &[u8; 10usize] = b"dstu34311\0";
pub const LN_dstu34311: &[u8; 19usize] = b"DSTU Gost 34311-95\0";
pub const NID_dstu34311: u32 = 1157;
pub const SN_dstu4145le: &[u8; 11usize] = b"dstu4145le\0";
pub const LN_dstu4145le: &[u8; 29usize] = b"DSTU 4145-2002 little endian\0";
pub const NID_dstu4145le: u32 = 1158;
pub const SN_dstu4145be: &[u8; 11usize] = b"dstu4145be\0";
pub const LN_dstu4145be: &[u8; 26usize] = b"DSTU 4145-2002 big endian\0";
pub const NID_dstu4145be: u32 = 1159;
pub const SN_uacurve0: &[u8; 9usize] = b"uacurve0\0";
pub const LN_uacurve0: &[u8; 13usize] = b"DSTU curve 0\0";
pub const NID_uacurve0: u32 = 1160;
pub const SN_uacurve1: &[u8; 9usize] = b"uacurve1\0";
pub const LN_uacurve1: &[u8; 13usize] = b"DSTU curve 1\0";
pub const NID_uacurve1: u32 = 1161;
pub const SN_uacurve2: &[u8; 9usize] = b"uacurve2\0";
pub const LN_uacurve2: &[u8; 13usize] = b"DSTU curve 2\0";
pub const NID_uacurve2: u32 = 1162;
pub const SN_uacurve3: &[u8; 9usize] = b"uacurve3\0";
pub const LN_uacurve3: &[u8; 13usize] = b"DSTU curve 3\0";
pub const NID_uacurve3: u32 = 1163;
pub const SN_uacurve4: &[u8; 9usize] = b"uacurve4\0";
pub const LN_uacurve4: &[u8; 13usize] = b"DSTU curve 4\0";
pub const NID_uacurve4: u32 = 1164;
pub const SN_uacurve5: &[u8; 9usize] = b"uacurve5\0";
pub const LN_uacurve5: &[u8; 13usize] = b"DSTU curve 5\0";
pub const NID_uacurve5: u32 = 1165;
pub const SN_uacurve6: &[u8; 9usize] = b"uacurve6\0";
pub const LN_uacurve6: &[u8; 13usize] = b"DSTU curve 6\0";
pub const NID_uacurve6: u32 = 1166;
pub const SN_uacurve7: &[u8; 9usize] = b"uacurve7\0";
pub const LN_uacurve7: &[u8; 13usize] = b"DSTU curve 7\0";
pub const NID_uacurve7: u32 = 1167;
pub const SN_uacurve8: &[u8; 9usize] = b"uacurve8\0";
pub const LN_uacurve8: &[u8; 13usize] = b"DSTU curve 8\0";
pub const NID_uacurve8: u32 = 1168;
pub const SN_uacurve9: &[u8; 9usize] = b"uacurve9\0";
pub const LN_uacurve9: &[u8; 13usize] = b"DSTU curve 9\0";
pub const NID_uacurve9: u32 = 1169;
pub const ASN1_F_A2D_ASN1_OBJECT: u32 = 100;
pub const ASN1_F_A2I_ASN1_INTEGER: u32 = 102;
pub const ASN1_F_A2I_ASN1_STRING: u32 = 103;
pub const ASN1_F_APPEND_EXP: u32 = 176;
pub const ASN1_F_ASN1_BIO_INIT: u32 = 113;
pub const ASN1_F_ASN1_BIT_STRING_SET_BIT: u32 = 183;
pub const ASN1_F_ASN1_CB: u32 = 177;
pub const ASN1_F_ASN1_CHECK_TLEN: u32 = 104;
pub const ASN1_F_ASN1_COLLECT: u32 = 106;
pub const ASN1_F_ASN1_D2I_EX_PRIMITIVE: u32 = 108;
pub const ASN1_F_ASN1_D2I_FP: u32 = 109;
pub const ASN1_F_ASN1_D2I_READ_BIO: u32 = 107;
pub const ASN1_F_ASN1_DIGEST: u32 = 184;
pub const ASN1_F_ASN1_DO_ADB: u32 = 110;
pub const ASN1_F_ASN1_DO_LOCK: u32 = 233;
pub const ASN1_F_ASN1_DUP: u32 = 111;
pub const ASN1_F_ASN1_ENC_SAVE: u32 = 115;
pub const ASN1_F_ASN1_EX_C2I: u32 = 204;
pub const ASN1_F_ASN1_FIND_END: u32 = 190;
pub const ASN1_F_ASN1_GENERALIZEDTIME_ADJ: u32 = 216;
pub const ASN1_F_ASN1_GENERATE_V3: u32 = 178;
pub const ASN1_F_ASN1_GET_INT64: u32 = 224;
pub const ASN1_F_ASN1_GET_OBJECT: u32 = 114;
pub const ASN1_F_ASN1_GET_UINT64: u32 = 225;
pub const ASN1_F_ASN1_I2D_BIO: u32 = 116;
pub const ASN1_F_ASN1_I2D_FP: u32 = 117;
pub const ASN1_F_ASN1_ITEM_D2I_FP: u32 = 206;
pub const ASN1_F_ASN1_ITEM_DUP: u32 = 191;
pub const ASN1_F_ASN1_ITEM_EMBED_D2I: u32 = 120;
pub const ASN1_F_ASN1_ITEM_EMBED_NEW: u32 = 121;
pub const ASN1_F_ASN1_ITEM_EX_I2D: u32 = 144;
pub const ASN1_F_ASN1_ITEM_FLAGS_I2D: u32 = 118;
pub const ASN1_F_ASN1_ITEM_I2D_BIO: u32 = 192;
pub const ASN1_F_ASN1_ITEM_I2D_FP: u32 = 193;
pub const ASN1_F_ASN1_ITEM_PACK: u32 = 198;
pub const ASN1_F_ASN1_ITEM_SIGN: u32 = 195;
pub const ASN1_F_ASN1_ITEM_SIGN_CTX: u32 = 220;
pub const ASN1_F_ASN1_ITEM_UNPACK: u32 = 199;
pub const ASN1_F_ASN1_ITEM_VERIFY: u32 = 197;
pub const ASN1_F_ASN1_MBSTRING_NCOPY: u32 = 122;
pub const ASN1_F_ASN1_OBJECT_NEW: u32 = 123;
pub const ASN1_F_ASN1_OUTPUT_DATA: u32 = 214;
pub const ASN1_F_ASN1_PCTX_NEW: u32 = 205;
pub const ASN1_F_ASN1_PRIMITIVE_NEW: u32 = 119;
pub const ASN1_F_ASN1_SCTX_NEW: u32 = 221;
pub const ASN1_F_ASN1_SIGN: u32 = 128;
pub const ASN1_F_ASN1_STR2TYPE: u32 = 179;
pub const ASN1_F_ASN1_STRING_GET_INT64: u32 = 227;
pub const ASN1_F_ASN1_STRING_GET_UINT64: u32 = 230;
pub const ASN1_F_ASN1_STRING_SET: u32 = 186;
pub const ASN1_F_ASN1_STRING_TABLE_ADD: u32 = 129;
pub const ASN1_F_ASN1_STRING_TO_BN: u32 = 228;
pub const ASN1_F_ASN1_STRING_TYPE_NEW: u32 = 130;
pub const ASN1_F_ASN1_TEMPLATE_EX_D2I: u32 = 132;
pub const ASN1_F_ASN1_TEMPLATE_NEW: u32 = 133;
pub const ASN1_F_ASN1_TEMPLATE_NOEXP_D2I: u32 = 131;
pub const ASN1_F_ASN1_TIME_ADJ: u32 = 217;
pub const ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING: u32 = 134;
pub const ASN1_F_ASN1_TYPE_GET_OCTETSTRING: u32 = 135;
pub const ASN1_F_ASN1_UTCTIME_ADJ: u32 = 218;
pub const ASN1_F_ASN1_VERIFY: u32 = 137;
pub const ASN1_F_B64_READ_ASN1: u32 = 209;
pub const ASN1_F_B64_WRITE_ASN1: u32 = 210;
pub const ASN1_F_BIO_NEW_NDEF: u32 = 208;
pub const ASN1_F_BITSTR_CB: u32 = 180;
pub const ASN1_F_BN_TO_ASN1_STRING: u32 = 229;
pub const ASN1_F_C2I_ASN1_BIT_STRING: u32 = 189;
pub const ASN1_F_C2I_ASN1_INTEGER: u32 = 194;
pub const ASN1_F_C2I_ASN1_OBJECT: u32 = 196;
pub const ASN1_F_C2I_IBUF: u32 = 226;
pub const ASN1_F_C2I_UINT64_INT: u32 = 101;
pub const ASN1_F_COLLECT_DATA: u32 = 140;
pub const ASN1_F_D2I_ASN1_OBJECT: u32 = 147;
pub const ASN1_F_D2I_ASN1_UINTEGER: u32 = 150;
pub const ASN1_F_D2I_AUTOPRIVATEKEY: u32 = 207;
pub const ASN1_F_D2I_PRIVATEKEY: u32 = 154;
pub const ASN1_F_D2I_PUBLICKEY: u32 = 155;
pub const ASN1_F_DO_BUF: u32 = 142;
pub const ASN1_F_DO_CREATE: u32 = 124;
pub const ASN1_F_DO_DUMP: u32 = 125;
pub const ASN1_F_DO_TCREATE: u32 = 222;
pub const ASN1_F_I2A_ASN1_OBJECT: u32 = 126;
pub const ASN1_F_I2D_ASN1_BIO_STREAM: u32 = 211;
pub const ASN1_F_I2D_ASN1_OBJECT: u32 = 143;
pub const ASN1_F_I2D_DSA_PUBKEY: u32 = 161;
pub const ASN1_F_I2D_EC_PUBKEY: u32 = 181;
pub const ASN1_F_I2D_PRIVATEKEY: u32 = 163;
pub const ASN1_F_I2D_PUBLICKEY: u32 = 164;
pub const ASN1_F_I2D_RSA_PUBKEY: u32 = 165;
pub const ASN1_F_LONG_C2I: u32 = 166;
pub const ASN1_F_NDEF_PREFIX: u32 = 127;
pub const ASN1_F_NDEF_SUFFIX: u32 = 136;
pub const ASN1_F_OID_MODULE_INIT: u32 = 174;
pub const ASN1_F_PARSE_TAGGING: u32 = 182;
pub const ASN1_F_PKCS5_PBE2_SET_IV: u32 = 167;
pub const ASN1_F_PKCS5_PBE2_SET_SCRYPT: u32 = 231;
pub const ASN1_F_PKCS5_PBE_SET: u32 = 202;
pub const ASN1_F_PKCS5_PBE_SET0_ALGOR: u32 = 215;
pub const ASN1_F_PKCS5_PBKDF2_SET: u32 = 219;
pub const ASN1_F_PKCS5_SCRYPT_SET: u32 = 232;
pub const ASN1_F_SMIME_READ_ASN1: u32 = 212;
pub const ASN1_F_SMIME_TEXT: u32 = 213;
pub const ASN1_F_STABLE_GET: u32 = 138;
pub const ASN1_F_STBL_MODULE_INIT: u32 = 223;
pub const ASN1_F_UINT32_C2I: u32 = 105;
pub const ASN1_F_UINT32_NEW: u32 = 139;
pub const ASN1_F_UINT64_C2I: u32 = 112;
pub const ASN1_F_UINT64_NEW: u32 = 141;
pub const ASN1_F_X509_CRL_ADD0_REVOKED: u32 = 169;
pub const ASN1_F_X509_INFO_NEW: u32 = 170;
pub const ASN1_F_X509_NAME_ENCODE: u32 = 203;
pub const ASN1_F_X509_NAME_EX_D2I: u32 = 158;
pub const ASN1_F_X509_NAME_EX_NEW: u32 = 171;
pub const ASN1_F_X509_PKEY_NEW: u32 = 173;
pub const ASN1_R_ADDING_OBJECT: u32 = 171;
pub const ASN1_R_ASN1_PARSE_ERROR: u32 = 203;
pub const ASN1_R_ASN1_SIG_PARSE_ERROR: u32 = 204;
pub const ASN1_R_AUX_ERROR: u32 = 100;
pub const ASN1_R_BAD_OBJECT_HEADER: u32 = 102;
pub const ASN1_R_BAD_TEMPLATE: u32 = 230;
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH: u32 = 214;
pub const ASN1_R_BN_LIB: u32 = 105;
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH: u32 = 106;
pub const ASN1_R_BUFFER_TOO_SMALL: u32 = 107;
pub const ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 108;
pub const ASN1_R_CONTEXT_NOT_INITIALISED: u32 = 217;
pub const ASN1_R_DATA_IS_WRONG: u32 = 109;
pub const ASN1_R_DECODE_ERROR: u32 = 110;
pub const ASN1_R_DEPTH_EXCEEDED: u32 = 174;
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED: u32 = 198;
pub const ASN1_R_ENCODE_ERROR: u32 = 112;
pub const ASN1_R_ERROR_GETTING_TIME: u32 = 173;
pub const ASN1_R_ERROR_LOADING_SECTION: u32 = 172;
pub const ASN1_R_ERROR_SETTING_CIPHER_PARAMS: u32 = 114;
pub const ASN1_R_EXPECTING_AN_INTEGER: u32 = 115;
pub const ASN1_R_EXPECTING_AN_OBJECT: u32 = 116;
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH: u32 = 119;
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED: u32 = 120;
pub const ASN1_R_FIELD_MISSING: u32 = 121;
pub const ASN1_R_FIRST_NUM_TOO_LARGE: u32 = 122;
pub const ASN1_R_HEADER_TOO_LONG: u32 = 123;
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT: u32 = 175;
pub const ASN1_R_ILLEGAL_BOOLEAN: u32 = 176;
pub const ASN1_R_ILLEGAL_CHARACTERS: u32 = 124;
pub const ASN1_R_ILLEGAL_FORMAT: u32 = 177;
pub const ASN1_R_ILLEGAL_HEX: u32 = 178;
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG: u32 = 179;
pub const ASN1_R_ILLEGAL_INTEGER: u32 = 180;
pub const ASN1_R_ILLEGAL_NEGATIVE_VALUE: u32 = 226;
pub const ASN1_R_ILLEGAL_NESTED_TAGGING: u32 = 181;
pub const ASN1_R_ILLEGAL_NULL: u32 = 125;
pub const ASN1_R_ILLEGAL_NULL_VALUE: u32 = 182;
pub const ASN1_R_ILLEGAL_OBJECT: u32 = 183;
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY: u32 = 126;
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE: u32 = 170;
pub const ASN1_R_ILLEGAL_PADDING: u32 = 221;
pub const ASN1_R_ILLEGAL_TAGGED_ANY: u32 = 127;
pub const ASN1_R_ILLEGAL_TIME_VALUE: u32 = 184;
pub const ASN1_R_ILLEGAL_ZERO_CONTENT: u32 = 222;
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT: u32 = 185;
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG: u32 = 128;
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT: u32 = 220;
pub const ASN1_R_INVALID_BMPSTRING_LENGTH: u32 = 129;
pub const ASN1_R_INVALID_DIGIT: u32 = 130;
pub const ASN1_R_INVALID_MIME_TYPE: u32 = 205;
pub const ASN1_R_INVALID_MODIFIER: u32 = 186;
pub const ASN1_R_INVALID_NUMBER: u32 = 187;
pub const ASN1_R_INVALID_OBJECT_ENCODING: u32 = 216;
pub const ASN1_R_INVALID_SCRYPT_PARAMETERS: u32 = 227;
pub const ASN1_R_INVALID_SEPARATOR: u32 = 131;
pub const ASN1_R_INVALID_STRING_TABLE_VALUE: u32 = 218;
pub const ASN1_R_INVALID_UNIVERSALSTRING_LENGTH: u32 = 133;
pub const ASN1_R_INVALID_UTF8STRING: u32 = 134;
pub const ASN1_R_INVALID_VALUE: u32 = 219;
pub const ASN1_R_LIST_ERROR: u32 = 188;
pub const ASN1_R_MIME_NO_CONTENT_TYPE: u32 = 206;
pub const ASN1_R_MIME_PARSE_ERROR: u32 = 207;
pub const ASN1_R_MIME_SIG_PARSE_ERROR: u32 = 208;
pub const ASN1_R_MISSING_EOC: u32 = 137;
pub const ASN1_R_MISSING_SECOND_NUMBER: u32 = 138;
pub const ASN1_R_MISSING_VALUE: u32 = 189;
pub const ASN1_R_MSTRING_NOT_UNIVERSAL: u32 = 139;
pub const ASN1_R_MSTRING_WRONG_TAG: u32 = 140;
pub const ASN1_R_NESTED_ASN1_STRING: u32 = 197;
pub const ASN1_R_NESTED_TOO_DEEP: u32 = 201;
pub const ASN1_R_NON_HEX_CHARACTERS: u32 = 141;
pub const ASN1_R_NOT_ASCII_FORMAT: u32 = 190;
pub const ASN1_R_NOT_ENOUGH_DATA: u32 = 142;
pub const ASN1_R_NO_CONTENT_TYPE: u32 = 209;
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE: u32 = 143;
pub const ASN1_R_NO_MULTIPART_BODY_FAILURE: u32 = 210;
pub const ASN1_R_NO_MULTIPART_BOUNDARY: u32 = 211;
pub const ASN1_R_NO_SIG_CONTENT_TYPE: u32 = 212;
pub const ASN1_R_NULL_IS_WRONG_LENGTH: u32 = 144;
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT: u32 = 191;
pub const ASN1_R_ODD_NUMBER_OF_CHARS: u32 = 145;
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE: u32 = 147;
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH: u32 = 148;
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED: u32 = 149;
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG: u32 = 192;
pub const ASN1_R_SHORT_LINE: u32 = 150;
pub const ASN1_R_SIG_INVALID_MIME_TYPE: u32 = 213;
pub const ASN1_R_STREAMING_NOT_SUPPORTED: u32 = 202;
pub const ASN1_R_STRING_TOO_LONG: u32 = 151;
pub const ASN1_R_STRING_TOO_SHORT: u32 = 152;
pub const ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD: u32 = 154;
pub const ASN1_R_TIME_NOT_ASCII_FORMAT: u32 = 193;
pub const ASN1_R_TOO_LARGE: u32 = 223;
pub const ASN1_R_TOO_LONG: u32 = 155;
pub const ASN1_R_TOO_SMALL: u32 = 224;
pub const ASN1_R_TYPE_NOT_CONSTRUCTED: u32 = 156;
pub const ASN1_R_TYPE_NOT_PRIMITIVE: u32 = 195;
pub const ASN1_R_UNEXPECTED_EOC: u32 = 159;
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH: u32 = 215;
pub const ASN1_R_UNKNOWN_FORMAT: u32 = 160;
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM: u32 = 161;
pub const ASN1_R_UNKNOWN_OBJECT_TYPE: u32 = 162;
pub const ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE: u32 = 163;
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM: u32 = 199;
pub const ASN1_R_UNKNOWN_TAG: u32 = 194;
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE: u32 = 164;
pub const ASN1_R_UNSUPPORTED_CIPHER: u32 = 228;
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 167;
pub const ASN1_R_UNSUPPORTED_TYPE: u32 = 196;
pub const ASN1_R_WRONG_INTEGER_TYPE: u32 = 225;
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE: u32 = 200;
pub const ASN1_R_WRONG_TAG: u32 = 168;
pub const V_ASN1_UNIVERSAL: u32 = 0;
pub const V_ASN1_APPLICATION: u32 = 64;
pub const V_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const V_ASN1_PRIVATE: u32 = 192;
pub const V_ASN1_CONSTRUCTED: u32 = 32;
pub const V_ASN1_PRIMITIVE_TAG: u32 = 31;
pub const V_ASN1_PRIMATIVE_TAG: u32 = 31;
pub const V_ASN1_APP_CHOOSE: i32 = -2;
pub const V_ASN1_OTHER: i32 = -3;
pub const V_ASN1_ANY: i32 = -4;
pub const V_ASN1_UNDEF: i32 = -1;
pub const V_ASN1_EOC: u32 = 0;
pub const V_ASN1_BOOLEAN: u32 = 1;
pub const V_ASN1_INTEGER: u32 = 2;
pub const V_ASN1_BIT_STRING: u32 = 3;
pub const V_ASN1_OCTET_STRING: u32 = 4;
pub const V_ASN1_NULL: u32 = 5;
pub const V_ASN1_OBJECT: u32 = 6;
pub const V_ASN1_OBJECT_DESCRIPTOR: u32 = 7;
pub const V_ASN1_EXTERNAL: u32 = 8;
pub const V_ASN1_REAL: u32 = 9;
pub const V_ASN1_ENUMERATED: u32 = 10;
pub const V_ASN1_UTF8STRING: u32 = 12;
pub const V_ASN1_SEQUENCE: u32 = 16;
pub const V_ASN1_SET: u32 = 17;
pub const V_ASN1_NUMERICSTRING: u32 = 18;
pub const V_ASN1_PRINTABLESTRING: u32 = 19;
pub const V_ASN1_T61STRING: u32 = 20;
pub const V_ASN1_TELETEXSTRING: u32 = 20;
pub const V_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const V_ASN1_IA5STRING: u32 = 22;
pub const V_ASN1_UTCTIME: u32 = 23;
pub const V_ASN1_GENERALIZEDTIME: u32 = 24;
pub const V_ASN1_GRAPHICSTRING: u32 = 25;
pub const V_ASN1_ISO64STRING: u32 = 26;
pub const V_ASN1_VISIBLESTRING: u32 = 26;
pub const V_ASN1_GENERALSTRING: u32 = 27;
pub const V_ASN1_UNIVERSALSTRING: u32 = 28;
pub const V_ASN1_BMPSTRING: u32 = 30;
pub const V_ASN1_NEG: u32 = 256;
pub const V_ASN1_NEG_INTEGER: u32 = 258;
pub const V_ASN1_NEG_ENUMERATED: u32 = 266;
pub const B_ASN1_NUMERICSTRING: u32 = 1;
pub const B_ASN1_PRINTABLESTRING: u32 = 2;
pub const B_ASN1_T61STRING: u32 = 4;
pub const B_ASN1_TELETEXSTRING: u32 = 4;
pub const B_ASN1_VIDEOTEXSTRING: u32 = 8;
pub const B_ASN1_IA5STRING: u32 = 16;
pub const B_ASN1_GRAPHICSTRING: u32 = 32;
pub const B_ASN1_ISO64STRING: u32 = 64;
pub const B_ASN1_VISIBLESTRING: u32 = 64;
pub const B_ASN1_GENERALSTRING: u32 = 128;
pub const B_ASN1_UNIVERSALSTRING: u32 = 256;
pub const B_ASN1_OCTET_STRING: u32 = 512;
pub const B_ASN1_BIT_STRING: u32 = 1024;
pub const B_ASN1_BMPSTRING: u32 = 2048;
pub const B_ASN1_UNKNOWN: u32 = 4096;
pub const B_ASN1_UTF8STRING: u32 = 8192;
pub const B_ASN1_UTCTIME: u32 = 16384;
pub const B_ASN1_GENERALIZEDTIME: u32 = 32768;
pub const B_ASN1_SEQUENCE: u32 = 65536;
pub const MBSTRING_FLAG: u32 = 4096;
pub const MBSTRING_UTF8: u32 = 4096;
pub const MBSTRING_ASC: u32 = 4097;
pub const MBSTRING_BMP: u32 = 4098;
pub const MBSTRING_UNIV: u32 = 4100;
pub const SMIME_OLDMIME: u32 = 1024;
pub const SMIME_CRLFEOL: u32 = 2048;
pub const SMIME_STREAM: u32 = 4096;
pub const ASN1_STRING_FLAG_BITS_LEFT: u32 = 8;
pub const ASN1_STRING_FLAG_NDEF: u32 = 16;
pub const ASN1_STRING_FLAG_CONT: u32 = 32;
pub const ASN1_STRING_FLAG_MSTRING: u32 = 64;
pub const ASN1_STRING_FLAG_EMBED: u32 = 128;
pub const ASN1_STRING_FLAG_X509_TIME: u32 = 256;
pub const ASN1_LONG_UNDEF: u32 = 2147483647;
pub const STABLE_FLAGS_MALLOC: u32 = 1;
pub const STABLE_FLAGS_CLEAR: u32 = 1;
pub const STABLE_NO_MASK: u32 = 2;
pub const DIRSTRING_TYPE: u32 = 10246;
pub const PKCS9STRING_TYPE: u32 = 10262;
pub const ub_name: u32 = 32768;
pub const ub_common_name: u32 = 64;
pub const ub_locality_name: u32 = 128;
pub const ub_state_name: u32 = 128;
pub const ub_organization_name: u32 = 64;
pub const ub_organization_unit_name: u32 = 64;
pub const ub_title: u32 = 64;
pub const ub_email_address: u32 = 128;
pub const ASN1_STRFLGS_ESC_2253: u32 = 1;
pub const ASN1_STRFLGS_ESC_CTRL: u32 = 2;
pub const ASN1_STRFLGS_ESC_MSB: u32 = 4;
pub const ASN1_STRFLGS_ESC_QUOTE: u32 = 8;
pub const CHARTYPE_PRINTABLESTRING: u32 = 16;
pub const CHARTYPE_FIRST_ESC_2253: u32 = 32;
pub const CHARTYPE_LAST_ESC_2253: u32 = 64;
pub const ASN1_STRFLGS_UTF8_CONVERT: u32 = 16;
pub const ASN1_STRFLGS_IGNORE_TYPE: u32 = 32;
pub const ASN1_STRFLGS_SHOW_TYPE: u32 = 64;
pub const ASN1_STRFLGS_DUMP_ALL: u32 = 128;
pub const ASN1_STRFLGS_DUMP_UNKNOWN: u32 = 256;
pub const ASN1_STRFLGS_DUMP_DER: u32 = 512;
pub const ASN1_STRFLGS_ESC_2254: u32 = 1024;
pub const ASN1_STRFLGS_RFC2253: u32 = 791;
pub const B_ASN1_TIME: u32 = 49152;
pub const B_ASN1_PRINTABLE: u32 = 81175;
pub const B_ASN1_DIRECTORYSTRING: u32 = 10502;
pub const B_ASN1_DISPLAYTEXT: u32 = 10320;
pub const ASN1_PCTX_FLAGS_SHOW_ABSENT: u32 = 1;
pub const ASN1_PCTX_FLAGS_SHOW_SEQUENCE: u32 = 2;
pub const ASN1_PCTX_FLAGS_SHOW_SSOF: u32 = 4;
pub const ASN1_PCTX_FLAGS_SHOW_TYPE: u32 = 8;
pub const ASN1_PCTX_FLAGS_NO_ANY_TYPE: u32 = 16;
pub const ASN1_PCTX_FLAGS_NO_MSTRING_TYPE: u32 = 32;
pub const ASN1_PCTX_FLAGS_NO_FIELD_NAME: u32 = 64;
pub const ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME: u32 = 128;
pub const ASN1_PCTX_FLAGS_NO_STRUCT_NAME: u32 = 256;
pub const OBJ_F_OBJ_ADD_OBJECT: u32 = 105;
pub const OBJ_F_OBJ_ADD_SIGID: u32 = 107;
pub const OBJ_F_OBJ_CREATE: u32 = 100;
pub const OBJ_F_OBJ_DUP: u32 = 101;
pub const OBJ_F_OBJ_NAME_NEW_INDEX: u32 = 106;
pub const OBJ_F_OBJ_NID2LN: u32 = 102;
pub const OBJ_F_OBJ_NID2OBJ: u32 = 103;
pub const OBJ_F_OBJ_NID2SN: u32 = 104;
pub const OBJ_F_OBJ_TXT2OBJ: u32 = 108;
pub const OBJ_R_OID_EXISTS: u32 = 102;
pub const OBJ_R_UNKNOWN_NID: u32 = 101;
pub const OBJ_NAME_TYPE_UNDEF: u32 = 0;
pub const OBJ_NAME_TYPE_MD_METH: u32 = 1;
pub const OBJ_NAME_TYPE_CIPHER_METH: u32 = 2;
pub const OBJ_NAME_TYPE_PKEY_METH: u32 = 3;
pub const OBJ_NAME_TYPE_COMP_METH: u32 = 4;
pub const OBJ_NAME_TYPE_NUM: u32 = 5;
pub const OBJ_NAME_ALIAS: u32 = 32768;
pub const OBJ_BSEARCH_VALUE_ON_NOMATCH: u32 = 1;
pub const OBJ_BSEARCH_FIRST_VALUE_ON_MATCH: u32 = 2;
pub const EVP_PK_RSA: u32 = 1;
pub const EVP_PK_DSA: u32 = 2;
pub const EVP_PK_DH: u32 = 4;
pub const EVP_PK_EC: u32 = 8;
pub const EVP_PKT_SIGN: u32 = 16;
pub const EVP_PKT_ENC: u32 = 32;
pub const EVP_PKT_EXCH: u32 = 64;
pub const EVP_PKS_RSA: u32 = 256;
pub const EVP_PKS_DSA: u32 = 512;
pub const EVP_PKS_EC: u32 = 1024;
pub const EVP_PKEY_NONE: u32 = 0;
pub const EVP_PKEY_RSA: u32 = 6;
pub const EVP_PKEY_RSA2: u32 = 19;
pub const EVP_PKEY_RSA_PSS: u32 = 912;
pub const EVP_PKEY_DSA: u32 = 116;
pub const EVP_PKEY_DSA1: u32 = 67;
pub const EVP_PKEY_DSA2: u32 = 66;
pub const EVP_PKEY_DSA3: u32 = 113;
pub const EVP_PKEY_DSA4: u32 = 70;
pub const EVP_PKEY_DH: u32 = 28;
pub const EVP_PKEY_DHX: u32 = 920;
pub const EVP_PKEY_EC: u32 = 408;
pub const EVP_PKEY_SM2: u32 = 1172;
pub const EVP_PKEY_HMAC: u32 = 855;
pub const EVP_PKEY_CMAC: u32 = 894;
pub const EVP_PKEY_SCRYPT: u32 = 973;
pub const EVP_PKEY_TLS1_PRF: u32 = 1021;
pub const EVP_PKEY_HKDF: u32 = 1036;
pub const EVP_PKEY_POLY1305: u32 = 1061;
pub const EVP_PKEY_SIPHASH: u32 = 1062;
pub const EVP_PKEY_X25519: u32 = 1034;
pub const EVP_PKEY_ED25519: u32 = 1087;
pub const EVP_PKEY_X448: u32 = 1035;
pub const EVP_PKEY_ED448: u32 = 1088;
pub const EVP_PKEY_MO_SIGN: u32 = 1;
pub const EVP_PKEY_MO_VERIFY: u32 = 2;
pub const EVP_PKEY_MO_ENCRYPT: u32 = 4;
pub const EVP_PKEY_MO_DECRYPT: u32 = 8;
pub const EVP_MD_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_FLAG_XOF: u32 = 2;
pub const EVP_MD_FLAG_DIGALGID_MASK: u32 = 24;
pub const EVP_MD_FLAG_DIGALGID_NULL: u32 = 0;
pub const EVP_MD_FLAG_DIGALGID_ABSENT: u32 = 8;
pub const EVP_MD_FLAG_DIGALGID_CUSTOM: u32 = 24;
pub const EVP_MD_FLAG_FIPS: u32 = 1024;
pub const EVP_MD_CTRL_DIGALGID: u32 = 1;
pub const EVP_MD_CTRL_MICALG: u32 = 2;
pub const EVP_MD_CTRL_XOF_LEN: u32 = 3;
pub const EVP_MD_CTRL_ALG_CTRL: u32 = 4096;
pub const EVP_MD_CTX_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_CTX_FLAG_CLEANED: u32 = 2;
pub const EVP_MD_CTX_FLAG_REUSE: u32 = 4;
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW: u32 = 8;
pub const EVP_MD_CTX_FLAG_PAD_MASK: u32 = 240;
pub const EVP_MD_CTX_FLAG_PAD_PKCS1: u32 = 0;
pub const EVP_MD_CTX_FLAG_PAD_X931: u32 = 16;
pub const EVP_MD_CTX_FLAG_PAD_PSS: u32 = 32;
pub const EVP_MD_CTX_FLAG_NO_INIT: u32 = 256;
pub const EVP_MD_CTX_FLAG_FINALISE: u32 = 512;
pub const EVP_CIPH_STREAM_CIPHER: u32 = 0;
pub const EVP_CIPH_ECB_MODE: u32 = 1;
pub const EVP_CIPH_CBC_MODE: u32 = 2;
pub const EVP_CIPH_CFB_MODE: u32 = 3;
pub const EVP_CIPH_OFB_MODE: u32 = 4;
pub const EVP_CIPH_CTR_MODE: u32 = 5;
pub const EVP_CIPH_GCM_MODE: u32 = 6;
pub const EVP_CIPH_CCM_MODE: u32 = 7;
pub const EVP_CIPH_XTS_MODE: u32 = 65537;
pub const EVP_CIPH_WRAP_MODE: u32 = 65538;
pub const EVP_CIPH_OCB_MODE: u32 = 65539;
pub const EVP_CIPH_MODE: u32 = 983047;
pub const EVP_CIPH_VARIABLE_LENGTH: u32 = 8;
pub const EVP_CIPH_CUSTOM_IV: u32 = 16;
pub const EVP_CIPH_ALWAYS_CALL_INIT: u32 = 32;
pub const EVP_CIPH_CTRL_INIT: u32 = 64;
pub const EVP_CIPH_CUSTOM_KEY_LENGTH: u32 = 128;
pub const EVP_CIPH_NO_PADDING: u32 = 256;
pub const EVP_CIPH_RAND_KEY: u32 = 512;
pub const EVP_CIPH_CUSTOM_COPY: u32 = 1024;
pub const EVP_CIPH_FLAG_DEFAULT_ASN1: u32 = 4096;
pub const EVP_CIPH_FLAG_LENGTH_BITS: u32 = 8192;
pub const EVP_CIPH_FLAG_FIPS: u32 = 16384;
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW: u32 = 32768;
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER: u32 = 1048576;
pub const EVP_CIPH_FLAG_AEAD_CIPHER: u32 = 2097152;
pub const EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK: u32 = 4194304;
pub const EVP_CIPH_FLAG_PIPELINE: u32 = 8388608;
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW: u32 = 1;
pub const EVP_CTRL_INIT: u32 = 0;
pub const EVP_CTRL_SET_KEY_LENGTH: u32 = 1;
pub const EVP_CTRL_GET_RC2_KEY_BITS: u32 = 2;
pub const EVP_CTRL_SET_RC2_KEY_BITS: u32 = 3;
pub const EVP_CTRL_GET_RC5_ROUNDS: u32 = 4;
pub const EVP_CTRL_SET_RC5_ROUNDS: u32 = 5;
pub const EVP_CTRL_RAND_KEY: u32 = 6;
pub const EVP_CTRL_PBE_PRF_NID: u32 = 7;
pub const EVP_CTRL_COPY: u32 = 8;
pub const EVP_CTRL_AEAD_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_AEAD_GET_TAG: u32 = 16;
pub const EVP_CTRL_AEAD_SET_TAG: u32 = 17;
pub const EVP_CTRL_AEAD_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_GCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_GCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_GCM_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_IV_GEN: u32 = 19;
pub const EVP_CTRL_CCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_CCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_CCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_CCM_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_CCM_SET_L: u32 = 20;
pub const EVP_CTRL_CCM_SET_MSGLEN: u32 = 21;
pub const EVP_CTRL_AEAD_TLS1_AAD: u32 = 22;
pub const EVP_CTRL_AEAD_SET_MAC_KEY: u32 = 23;
pub const EVP_CTRL_GCM_SET_IV_INV: u32 = 24;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_AAD: u32 = 25;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT: u32 = 26;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT: u32 = 27;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE: u32 = 28;
pub const EVP_CTRL_SSL3_MASTER_SECRET: u32 = 29;
pub const EVP_CTRL_SET_SBOX: u32 = 30;
pub const EVP_CTRL_SBOX_USED: u32 = 31;
pub const EVP_CTRL_KEY_MESH: u32 = 32;
pub const EVP_CTRL_BLOCK_PADDING_MODE: u32 = 33;
pub const EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS: u32 = 34;
pub const EVP_CTRL_SET_PIPELINE_INPUT_BUFS: u32 = 35;
pub const EVP_CTRL_SET_PIPELINE_INPUT_LENS: u32 = 36;
pub const EVP_PADDING_PKCS7: u32 = 1;
pub const EVP_PADDING_ISO7816_4: u32 = 2;
pub const EVP_PADDING_ANSI923: u32 = 3;
pub const EVP_PADDING_ISO10126: u32 = 4;
pub const EVP_PADDING_ZERO: u32 = 5;
pub const EVP_AEAD_TLS1_AAD_LEN: u32 = 13;
pub const EVP_GCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_GCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_CCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_CCM_TLS_IV_LEN: u32 = 12;
pub const EVP_CCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CCM8_TLS_TAG_LEN: u32 = 8;
pub const EVP_CHACHAPOLY_TLS_TAG_LEN: u32 = 16;
pub const EVP_PBE_TYPE_OUTER: u32 = 0;
pub const EVP_PBE_TYPE_PRF: u32 = 1;
pub const EVP_PBE_TYPE_KDF: u32 = 2;
pub const ASN1_PKEY_ALIAS: u32 = 1;
pub const ASN1_PKEY_DYNAMIC: u32 = 2;
pub const ASN1_PKEY_SIGPARAM_NULL: u32 = 4;
pub const ASN1_PKEY_CTRL_PKCS7_SIGN: u32 = 1;
pub const ASN1_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 2;
pub const ASN1_PKEY_CTRL_DEFAULT_MD_NID: u32 = 3;
pub const ASN1_PKEY_CTRL_CMS_SIGN: u32 = 5;
pub const ASN1_PKEY_CTRL_CMS_ENVELOPE: u32 = 7;
pub const ASN1_PKEY_CTRL_CMS_RI_TYPE: u32 = 8;
pub const ASN1_PKEY_CTRL_SET1_TLS_ENCPT: u32 = 9;
pub const ASN1_PKEY_CTRL_GET1_TLS_ENCPT: u32 = 10;
pub const EVP_PKEY_OP_UNDEFINED: u32 = 0;
pub const EVP_PKEY_OP_PARAMGEN: u32 = 2;
pub const EVP_PKEY_OP_KEYGEN: u32 = 4;
pub const EVP_PKEY_OP_SIGN: u32 = 8;
pub const EVP_PKEY_OP_VERIFY: u32 = 16;
pub const EVP_PKEY_OP_VERIFYRECOVER: u32 = 32;
pub const EVP_PKEY_OP_SIGNCTX: u32 = 64;
pub const EVP_PKEY_OP_VERIFYCTX: u32 = 128;
pub const EVP_PKEY_OP_ENCRYPT: u32 = 256;
pub const EVP_PKEY_OP_DECRYPT: u32 = 512;
pub const EVP_PKEY_OP_DERIVE: u32 = 1024;
pub const EVP_PKEY_OP_TYPE_SIG: u32 = 248;
pub const EVP_PKEY_OP_TYPE_CRYPT: u32 = 768;
pub const EVP_PKEY_OP_TYPE_NOGEN: u32 = 2040;
pub const EVP_PKEY_OP_TYPE_GEN: u32 = 6;
pub const EVP_PKEY_CTRL_MD: u32 = 1;
pub const EVP_PKEY_CTRL_PEER_KEY: u32 = 2;
pub const EVP_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 3;
pub const EVP_PKEY_CTRL_PKCS7_DECRYPT: u32 = 4;
pub const EVP_PKEY_CTRL_PKCS7_SIGN: u32 = 5;
pub const EVP_PKEY_CTRL_SET_MAC_KEY: u32 = 6;
pub const EVP_PKEY_CTRL_DIGESTINIT: u32 = 7;
pub const EVP_PKEY_CTRL_SET_IV: u32 = 8;
pub const EVP_PKEY_CTRL_CMS_ENCRYPT: u32 = 9;
pub const EVP_PKEY_CTRL_CMS_DECRYPT: u32 = 10;
pub const EVP_PKEY_CTRL_CMS_SIGN: u32 = 11;
pub const EVP_PKEY_CTRL_CIPHER: u32 = 12;
pub const EVP_PKEY_CTRL_GET_MD: u32 = 13;
pub const EVP_PKEY_CTRL_SET_DIGEST_SIZE: u32 = 14;
pub const EVP_PKEY_ALG_CTRL: u32 = 4096;
pub const EVP_PKEY_FLAG_AUTOARGLEN: u32 = 2;
pub const EVP_PKEY_FLAG_SIGCTX_CUSTOM: u32 = 4;
pub const SHA_LBLOCK: u32 = 16;
pub const SHA_CBLOCK: u32 = 64;
pub const SHA_LAST_BLOCK: u32 = 56;
pub const SHA_DIGEST_LENGTH: u32 = 20;
pub const SHA256_CBLOCK: u32 = 64;
pub const SHA224_DIGEST_LENGTH: u32 = 28;
pub const SHA256_DIGEST_LENGTH: u32 = 32;
pub const SHA384_DIGEST_LENGTH: u32 = 48;
pub const SHA512_DIGEST_LENGTH: u32 = 64;
pub const SHA512_CBLOCK: u32 = 128;
pub const MANUFACTURER: &[u8; 5usize] = b"MSFT\0";
pub const VENDOR_STRING_1: &[u8; 5usize] = b"xCG \0";
pub const VENDOR_STRING_2: &[u8; 5usize] = b"fTPM\0";
pub const FIRMWARE_V1: u32 = 538379801;
pub const FIRMWARE_V2: u32 = 1455670;
pub const PCR_SELECT_MIN: u32 = 3;
pub const PCR_SELECT_MAX: u32 = 3;
pub const MAX_ORDERLY_COUNT: u32 = 255;
pub const RSA_MAX_PRIME: u32 = 128;
pub const RSA_PRIVATE_SIZE: u32 = 640;
pub const _STRING_H: u32 = 1;
pub const ALG_ERROR_VALUE: u32 = 0;
pub const ALG_RSA_VALUE: u32 = 1;
pub const ALG_TDES_VALUE: u32 = 3;
pub const ALG_SHA_VALUE: u32 = 4;
pub const ALG_SHA1_VALUE: u32 = 4;
pub const ALG_HMAC_VALUE: u32 = 5;
pub const ALG_AES_VALUE: u32 = 6;
pub const ALG_MGF1_VALUE: u32 = 7;
pub const ALG_KEYEDHASH_VALUE: u32 = 8;
pub const ALG_XOR_VALUE: u32 = 10;
pub const ALG_SHA256_VALUE: u32 = 11;
pub const ALG_SHA384_VALUE: u32 = 12;
pub const ALG_SHA512_VALUE: u32 = 13;
pub const ALG_NULL_VALUE: u32 = 16;
pub const ALG_SM3_256_VALUE: u32 = 18;
pub const ALG_SM4_VALUE: u32 = 19;
pub const ALG_RSASSA_VALUE: u32 = 20;
pub const ALG_RSAES_VALUE: u32 = 21;
pub const ALG_RSAPSS_VALUE: u32 = 22;
pub const ALG_OAEP_VALUE: u32 = 23;
pub const ALG_ECDSA_VALUE: u32 = 24;
pub const ALG_ECDH_VALUE: u32 = 25;
pub const ALG_ECDAA_VALUE: u32 = 26;
pub const ALG_SM2_VALUE: u32 = 27;
pub const ALG_ECSCHNORR_VALUE: u32 = 28;
pub const ALG_ECMQV_VALUE: u32 = 29;
pub const ALG_KDF1_SP800_56A_VALUE: u32 = 32;
pub const ALG_KDF2_VALUE: u32 = 33;
pub const ALG_KDF1_SP800_108_VALUE: u32 = 34;
pub const ALG_ECC_VALUE: u32 = 35;
pub const ALG_SYMCIPHER_VALUE: u32 = 37;
pub const ALG_CAMELLIA_VALUE: u32 = 38;
pub const ALG_SHA3_256_VALUE: u32 = 39;
pub const ALG_SHA3_384_VALUE: u32 = 40;
pub const ALG_SHA3_512_VALUE: u32 = 41;
pub const ALG_CMAC_VALUE: u32 = 63;
pub const ALG_CTR_VALUE: u32 = 64;
pub const ALG_OFB_VALUE: u32 = 65;
pub const ALG_CBC_VALUE: u32 = 66;
pub const ALG_CFB_VALUE: u32 = 67;
pub const ALG_ECB_VALUE: u32 = 68;
pub const ALG_FIRST_VALUE: u32 = 1;
pub const ALG_LAST_VALUE: u32 = 68;
pub const CC_VEND: u32 = 536870912;
pub const SPEC_FAMILY: u32 = 841887744;
pub const SPEC_LEVEL: u32 = 0;
pub const SPEC_VERSION: u32 = 162;
pub const SPEC_YEAR: u32 = 2020;
pub const SPEC_DAY_OF_YEAR: u32 = 53;
pub const TPMA_LOCALITY_Extended_SHIFT: u32 = 5;
pub const TPMA_CC_commandIndex_SHIFT: u32 = 0;
pub const TPMA_CC_cHandles_SHIFT: u32 = 25;
pub const TPM_NV_INDEX_index_SHIFT: u32 = 0;
pub const TPM_NV_INDEX_RH_NV_SHIFT: u32 = 24;
pub const TPMA_NV_TPM_NT_SHIFT: u32 = 4;
pub const RADIX_LOG2: u32 = 6;
pub const RADIX_BYTES: u32 = 8;
pub const EC_F_BN_TO_FELEM: u32 = 224;
pub const EC_F_D2I_ECPARAMETERS: u32 = 144;
pub const EC_F_D2I_ECPKPARAMETERS: u32 = 145;
pub const EC_F_D2I_ECPRIVATEKEY: u32 = 146;
pub const EC_F_DO_EC_KEY_PRINT: u32 = 221;
pub const EC_F_ECDH_CMS_DECRYPT: u32 = 238;
pub const EC_F_ECDH_CMS_SET_SHARED_INFO: u32 = 239;
pub const EC_F_ECDH_COMPUTE_KEY: u32 = 246;
pub const EC_F_ECDH_SIMPLE_COMPUTE_KEY: u32 = 257;
pub const EC_F_ECDSA_DO_SIGN_EX: u32 = 251;
pub const EC_F_ECDSA_DO_VERIFY: u32 = 252;
pub const EC_F_ECDSA_SIGN_EX: u32 = 254;
pub const EC_F_ECDSA_SIGN_SETUP: u32 = 248;
pub const EC_F_ECDSA_SIG_NEW: u32 = 265;
pub const EC_F_ECDSA_VERIFY: u32 = 253;
pub const EC_F_ECD_ITEM_VERIFY: u32 = 270;
pub const EC_F_ECKEY_PARAM2TYPE: u32 = 223;
pub const EC_F_ECKEY_PARAM_DECODE: u32 = 212;
pub const EC_F_ECKEY_PRIV_DECODE: u32 = 213;
pub const EC_F_ECKEY_PRIV_ENCODE: u32 = 214;
pub const EC_F_ECKEY_PUB_DECODE: u32 = 215;
pub const EC_F_ECKEY_PUB_ENCODE: u32 = 216;
pub const EC_F_ECKEY_TYPE2PARAM: u32 = 220;
pub const EC_F_ECPARAMETERS_PRINT: u32 = 147;
pub const EC_F_ECPARAMETERS_PRINT_FP: u32 = 148;
pub const EC_F_ECPKPARAMETERS_PRINT: u32 = 149;
pub const EC_F_ECPKPARAMETERS_PRINT_FP: u32 = 150;
pub const EC_F_ECP_NISTZ256_GET_AFFINE: u32 = 240;
pub const EC_F_ECP_NISTZ256_INV_MOD_ORD: u32 = 275;
pub const EC_F_ECP_NISTZ256_MULT_PRECOMPUTE: u32 = 243;
pub const EC_F_ECP_NISTZ256_POINTS_MUL: u32 = 241;
pub const EC_F_ECP_NISTZ256_PRE_COMP_NEW: u32 = 244;
pub const EC_F_ECP_NISTZ256_WINDOWED_MUL: u32 = 242;
pub const EC_F_ECX_KEY_OP: u32 = 266;
pub const EC_F_ECX_PRIV_ENCODE: u32 = 267;
pub const EC_F_ECX_PUB_ENCODE: u32 = 268;
pub const EC_F_EC_ASN1_GROUP2CURVE: u32 = 153;
pub const EC_F_EC_ASN1_GROUP2FIELDID: u32 = 154;
pub const EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY: u32 = 208;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 159;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE: u32 = 195;
pub const EC_F_EC_GF2M_SIMPLE_LADDER_POST: u32 = 285;
pub const EC_F_EC_GF2M_SIMPLE_LADDER_PRE: u32 = 288;
pub const EC_F_EC_GF2M_SIMPLE_OCT2POINT: u32 = 160;
pub const EC_F_EC_GF2M_SIMPLE_POINT2OCT: u32 = 161;
pub const EC_F_EC_GF2M_SIMPLE_POINTS_MUL: u32 = 289;
pub const EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 162;
pub const EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 163;
pub const EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 164;
pub const EC_F_EC_GFP_MONT_FIELD_DECODE: u32 = 133;
pub const EC_F_EC_GFP_MONT_FIELD_ENCODE: u32 = 134;
pub const EC_F_EC_GFP_MONT_FIELD_MUL: u32 = 131;
pub const EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE: u32 = 209;
pub const EC_F_EC_GFP_MONT_FIELD_SQR: u32 = 132;
pub const EC_F_EC_GFP_MONT_GROUP_SET_CURVE: u32 = 189;
pub const EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE: u32 = 225;
pub const EC_F_EC_GFP_NISTP224_POINTS_MUL: u32 = 228;
pub const EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES: u32 = 226;
pub const EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE: u32 = 230;
pub const EC_F_EC_GFP_NISTP256_POINTS_MUL: u32 = 231;
pub const EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES: u32 = 232;
pub const EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE: u32 = 233;
pub const EC_F_EC_GFP_NISTP521_POINTS_MUL: u32 = 234;
pub const EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES: u32 = 235;
pub const EC_F_EC_GFP_NIST_FIELD_MUL: u32 = 200;
pub const EC_F_EC_GFP_NIST_FIELD_SQR: u32 = 201;
pub const EC_F_EC_GFP_NIST_GROUP_SET_CURVE: u32 = 202;
pub const EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES: u32 = 287;
pub const EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 165;
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE: u32 = 166;
pub const EC_F_EC_GFP_SIMPLE_MAKE_AFFINE: u32 = 102;
pub const EC_F_EC_GFP_SIMPLE_OCT2POINT: u32 = 103;
pub const EC_F_EC_GFP_SIMPLE_POINT2OCT: u32 = 104;
pub const EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE: u32 = 137;
pub const EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 167;
pub const EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 168;
pub const EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 169;
pub const EC_F_EC_GROUP_CHECK: u32 = 170;
pub const EC_F_EC_GROUP_CHECK_DISCRIMINANT: u32 = 171;
pub const EC_F_EC_GROUP_COPY: u32 = 106;
pub const EC_F_EC_GROUP_GET_CURVE: u32 = 291;
pub const EC_F_EC_GROUP_GET_CURVE_GF2M: u32 = 172;
pub const EC_F_EC_GROUP_GET_CURVE_GFP: u32 = 130;
pub const EC_F_EC_GROUP_GET_DEGREE: u32 = 173;
pub const EC_F_EC_GROUP_GET_ECPARAMETERS: u32 = 261;
pub const EC_F_EC_GROUP_GET_ECPKPARAMETERS: u32 = 262;
pub const EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS: u32 = 193;
pub const EC_F_EC_GROUP_GET_TRINOMIAL_BASIS: u32 = 194;
pub const EC_F_EC_GROUP_NEW: u32 = 108;
pub const EC_F_EC_GROUP_NEW_BY_CURVE_NAME: u32 = 174;
pub const EC_F_EC_GROUP_NEW_FROM_DATA: u32 = 175;
pub const EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS: u32 = 263;
pub const EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS: u32 = 264;
pub const EC_F_EC_GROUP_SET_CURVE: u32 = 292;
pub const EC_F_EC_GROUP_SET_CURVE_GF2M: u32 = 176;
pub const EC_F_EC_GROUP_SET_CURVE_GFP: u32 = 109;
pub const EC_F_EC_GROUP_SET_GENERATOR: u32 = 111;
pub const EC_F_EC_GROUP_SET_SEED: u32 = 286;
pub const EC_F_EC_KEY_CHECK_KEY: u32 = 177;
pub const EC_F_EC_KEY_COPY: u32 = 178;
pub const EC_F_EC_KEY_GENERATE_KEY: u32 = 179;
pub const EC_F_EC_KEY_NEW: u32 = 182;
pub const EC_F_EC_KEY_NEW_METHOD: u32 = 245;
pub const EC_F_EC_KEY_OCT2PRIV: u32 = 255;
pub const EC_F_EC_KEY_PRINT: u32 = 180;
pub const EC_F_EC_KEY_PRINT_FP: u32 = 181;
pub const EC_F_EC_KEY_PRIV2BUF: u32 = 279;
pub const EC_F_EC_KEY_PRIV2OCT: u32 = 256;
pub const EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES: u32 = 229;
pub const EC_F_EC_KEY_SIMPLE_CHECK_KEY: u32 = 258;
pub const EC_F_EC_KEY_SIMPLE_OCT2PRIV: u32 = 259;
pub const EC_F_EC_KEY_SIMPLE_PRIV2OCT: u32 = 260;
pub const EC_F_EC_PKEY_CHECK: u32 = 273;
pub const EC_F_EC_PKEY_PARAM_CHECK: u32 = 274;
pub const EC_F_EC_POINTS_MAKE_AFFINE: u32 = 136;
pub const EC_F_EC_POINTS_MUL: u32 = 290;
pub const EC_F_EC_POINT_ADD: u32 = 112;
pub const EC_F_EC_POINT_BN2POINT: u32 = 280;
pub const EC_F_EC_POINT_CMP: u32 = 113;
pub const EC_F_EC_POINT_COPY: u32 = 114;
pub const EC_F_EC_POINT_DBL: u32 = 115;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES: u32 = 293;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M: u32 = 183;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP: u32 = 116;
pub const EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP: u32 = 117;
pub const EC_F_EC_POINT_INVERT: u32 = 210;
pub const EC_F_EC_POINT_IS_AT_INFINITY: u32 = 118;
pub const EC_F_EC_POINT_IS_ON_CURVE: u32 = 119;
pub const EC_F_EC_POINT_MAKE_AFFINE: u32 = 120;
pub const EC_F_EC_POINT_NEW: u32 = 121;
pub const EC_F_EC_POINT_OCT2POINT: u32 = 122;
pub const EC_F_EC_POINT_POINT2BUF: u32 = 281;
pub const EC_F_EC_POINT_POINT2OCT: u32 = 123;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES: u32 = 294;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M: u32 = 185;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP: u32 = 124;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES: u32 = 295;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M: u32 = 186;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP: u32 = 125;
pub const EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP: u32 = 126;
pub const EC_F_EC_POINT_SET_TO_INFINITY: u32 = 127;
pub const EC_F_EC_PRE_COMP_NEW: u32 = 196;
pub const EC_F_EC_SCALAR_MUL_LADDER: u32 = 284;
pub const EC_F_EC_WNAF_MUL: u32 = 187;
pub const EC_F_EC_WNAF_PRECOMPUTE_MULT: u32 = 188;
pub const EC_F_I2D_ECPARAMETERS: u32 = 190;
pub const EC_F_I2D_ECPKPARAMETERS: u32 = 191;
pub const EC_F_I2D_ECPRIVATEKEY: u32 = 192;
pub const EC_F_I2O_ECPUBLICKEY: u32 = 151;
pub const EC_F_NISTP224_PRE_COMP_NEW: u32 = 227;
pub const EC_F_NISTP256_PRE_COMP_NEW: u32 = 236;
pub const EC_F_NISTP521_PRE_COMP_NEW: u32 = 237;
pub const EC_F_O2I_ECPUBLICKEY: u32 = 152;
pub const EC_F_OLD_EC_PRIV_DECODE: u32 = 222;
pub const EC_F_OSSL_ECDH_COMPUTE_KEY: u32 = 247;
pub const EC_F_OSSL_ECDSA_SIGN_SIG: u32 = 249;
pub const EC_F_OSSL_ECDSA_VERIFY_SIG: u32 = 250;
pub const EC_F_PKEY_ECD_CTRL: u32 = 271;
pub const EC_F_PKEY_ECD_DIGESTSIGN: u32 = 272;
pub const EC_F_PKEY_ECD_DIGESTSIGN25519: u32 = 276;
pub const EC_F_PKEY_ECD_DIGESTSIGN448: u32 = 277;
pub const EC_F_PKEY_ECX_DERIVE: u32 = 269;
pub const EC_F_PKEY_EC_CTRL: u32 = 197;
pub const EC_F_PKEY_EC_CTRL_STR: u32 = 198;
pub const EC_F_PKEY_EC_DERIVE: u32 = 217;
pub const EC_F_PKEY_EC_INIT: u32 = 282;
pub const EC_F_PKEY_EC_KDF_DERIVE: u32 = 283;
pub const EC_F_PKEY_EC_KEYGEN: u32 = 199;
pub const EC_F_PKEY_EC_PARAMGEN: u32 = 219;
pub const EC_F_PKEY_EC_SIGN: u32 = 218;
pub const EC_F_VALIDATE_ECX_DERIVE: u32 = 278;
pub const EC_R_ASN1_ERROR: u32 = 115;
pub const EC_R_BAD_SIGNATURE: u32 = 156;
pub const EC_R_BIGNUM_OUT_OF_RANGE: u32 = 144;
pub const EC_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EC_R_COORDINATES_OUT_OF_RANGE: u32 = 146;
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDH: u32 = 160;
pub const EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING: u32 = 159;
pub const EC_R_D2I_ECPKPARAMETERS_FAILURE: u32 = 117;
pub const EC_R_DECODE_ERROR: u32 = 142;
pub const EC_R_DISCRIMINANT_IS_ZERO: u32 = 118;
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE: u32 = 119;
pub const EC_R_FIELD_TOO_LARGE: u32 = 143;
pub const EC_R_GF2M_NOT_SUPPORTED: u32 = 147;
pub const EC_R_GROUP2PKPARAMETERS_FAILURE: u32 = 120;
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE: u32 = 121;
pub const EC_R_INCOMPATIBLE_OBJECTS: u32 = 101;
pub const EC_R_INVALID_ARGUMENT: u32 = 112;
pub const EC_R_INVALID_COMPRESSED_POINT: u32 = 110;
pub const EC_R_INVALID_COMPRESSION_BIT: u32 = 109;
pub const EC_R_INVALID_CURVE: u32 = 141;
pub const EC_R_INVALID_DIGEST: u32 = 151;
pub const EC_R_INVALID_DIGEST_TYPE: u32 = 138;
pub const EC_R_INVALID_ENCODING: u32 = 102;
pub const EC_R_INVALID_FIELD: u32 = 103;
pub const EC_R_INVALID_FORM: u32 = 104;
pub const EC_R_INVALID_GROUP_ORDER: u32 = 122;
pub const EC_R_INVALID_KEY: u32 = 116;
pub const EC_R_INVALID_OUTPUT_LENGTH: u32 = 161;
pub const EC_R_INVALID_PEER_KEY: u32 = 133;
pub const EC_R_INVALID_PENTANOMIAL_BASIS: u32 = 132;
pub const EC_R_INVALID_PRIVATE_KEY: u32 = 123;
pub const EC_R_INVALID_TRINOMIAL_BASIS: u32 = 137;
pub const EC_R_KDF_PARAMETER_ERROR: u32 = 148;
pub const EC_R_KEYS_NOT_SET: u32 = 140;
pub const EC_R_LADDER_POST_FAILURE: u32 = 136;
pub const EC_R_LADDER_PRE_FAILURE: u32 = 153;
pub const EC_R_LADDER_STEP_FAILURE: u32 = 162;
pub const EC_R_MISSING_PARAMETERS: u32 = 124;
pub const EC_R_MISSING_PRIVATE_KEY: u32 = 125;
pub const EC_R_NEED_NEW_SETUP_VALUES: u32 = 157;
pub const EC_R_NOT_A_NIST_PRIME: u32 = 135;
pub const EC_R_NOT_IMPLEMENTED: u32 = 126;
pub const EC_R_NOT_INITIALIZED: u32 = 111;
pub const EC_R_NO_PARAMETERS_SET: u32 = 139;
pub const EC_R_NO_PRIVATE_VALUE: u32 = 154;
pub const EC_R_OPERATION_NOT_SUPPORTED: u32 = 152;
pub const EC_R_PASSED_NULL_PARAMETER: u32 = 134;
pub const EC_R_PEER_KEY_ERROR: u32 = 149;
pub const EC_R_PKPARAMETERS2GROUP_FAILURE: u32 = 127;
pub const EC_R_POINT_ARITHMETIC_FAILURE: u32 = 155;
pub const EC_R_POINT_AT_INFINITY: u32 = 106;
pub const EC_R_POINT_COORDINATES_BLIND_FAILURE: u32 = 163;
pub const EC_R_POINT_IS_NOT_ON_CURVE: u32 = 107;
pub const EC_R_RANDOM_NUMBER_GENERATION_FAILED: u32 = 158;
pub const EC_R_SHARED_INFO_ERROR: u32 = 150;
pub const EC_R_SLOT_FULL: u32 = 108;
pub const EC_R_UNDEFINED_GENERATOR: u32 = 113;
pub const EC_R_UNDEFINED_ORDER: u32 = 128;
pub const EC_R_UNKNOWN_COFACTOR: u32 = 164;
pub const EC_R_UNKNOWN_GROUP: u32 = 129;
pub const EC_R_UNKNOWN_ORDER: u32 = 114;
pub const EC_R_UNSUPPORTED_FIELD: u32 = 131;
pub const EC_R_WRONG_CURVE_PARAMETERS: u32 = 145;
pub const EC_R_WRONG_ORDER: u32 = 130;
pub const OPENSSL_ECC_MAX_FIELD_BITS: u32 = 661;
pub const OPENSSL_EC_EXPLICIT_CURVE: u32 = 0;
pub const OPENSSL_EC_NAMED_CURVE: u32 = 1;
pub const EC_PKEY_NO_PARAMETERS: u32 = 1;
pub const EC_PKEY_NO_PUBKEY: u32 = 2;
pub const EC_FLAG_NON_FIPS_ALLOW: u32 = 1;
pub const EC_FLAG_FIPS_CHECKED: u32 = 2;
pub const EC_FLAG_COFACTOR_ECDH: u32 = 4096;
pub const EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID: u32 = 4097;
pub const EVP_PKEY_CTRL_EC_PARAM_ENC: u32 = 4098;
pub const EVP_PKEY_CTRL_EC_ECDH_COFACTOR: u32 = 4099;
pub const EVP_PKEY_CTRL_EC_KDF_TYPE: u32 = 4100;
pub const EVP_PKEY_CTRL_EC_KDF_MD: u32 = 4101;
pub const EVP_PKEY_CTRL_GET_EC_KDF_MD: u32 = 4102;
pub const EVP_PKEY_CTRL_EC_KDF_OUTLEN: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN: u32 = 4104;
pub const EVP_PKEY_CTRL_EC_KDF_UKM: u32 = 4105;
pub const EVP_PKEY_CTRL_GET_EC_KDF_UKM: u32 = 4106;
pub const EVP_PKEY_CTRL_SET1_ID: u32 = 4107;
pub const EVP_PKEY_CTRL_GET1_ID: u32 = 4108;
pub const EVP_PKEY_CTRL_GET1_ID_LEN: u32 = 4109;
pub const EVP_PKEY_ECDH_KDF_NONE: u32 = 1;
pub const EVP_PKEY_ECDH_KDF_X9_62: u32 = 2;
pub const SYMMETRIC_ALIGNMENT: u32 = 8;
pub const DRBG_KEY_SIZE_BITS: u32 = 256;
pub const DRBG_IV_SIZE_BITS: u32 = 128;
pub const DRBG_MAX_REQUESTS_PER_RESEED: u64 = 281474976710656;
pub const DRBG_MAX_REQEST_SIZE: u64 = 4294967296;
pub const CTR_DRBG_MAX_BYTES_PER_REQUEST: u32 = 65536;
pub const TESTING: u32 = 1;
pub const ENTROPY: u32 = 2;
pub const TESTED: u32 = 4;
pub const FATAL_ERROR_ALLOCATION: u32 = 1;
pub const FATAL_ERROR_DIVIDE_ZERO: u32 = 2;
pub const FATAL_ERROR_INTERNAL: u32 = 3;
pub const FATAL_ERROR_PARAMETER: u32 = 4;
pub const FATAL_ERROR_ENTROPY: u32 = 5;
pub const FATAL_ERROR_SELF_TEST: u32 = 6;
pub const FATAL_ERROR_CRYPTO: u32 = 7;
pub const FATAL_ERROR_NV_UNRECOVERABLE: u32 = 8;
pub const FATAL_ERROR_REMANUFACTURED: u32 = 9;
pub const FATAL_ERROR_DRBG: u32 = 10;
pub const FATAL_ERROR_MOVE_SIZE: u32 = 11;
pub const FATAL_ERROR_COUNTER_OVERFLOW: u32 = 12;
pub const FATAL_ERROR_SUBTRACT: u32 = 13;
pub const FATAL_ERROR_MATHLIBRARY: u32 = 14;
pub const FATAL_ERROR_FORCED: u32 = 666;
pub const NV_RAM_REF_INIT: u32 = 0;
pub const RH_ACT_2: u32 = 0;
pub const RH_ACT_3: u32 = 0;
pub const RH_ACT_4: u32 = 0;
pub const RH_ACT_5: u32 = 0;
pub const RH_ACT_6: u32 = 0;
pub const RH_ACT_7: u32 = 0;
pub const RH_ACT_8: u32 = 0;
pub const RH_ACT_9: u32 = 0;
pub const RH_ACT_B: u32 = 0;
pub const RH_ACT_C: u32 = 0;
pub const RH_ACT_D: u32 = 0;
pub const RH_ACT_E: u32 = 0;
pub const RH_ACT_F: u32 = 0;
pub const RSA_prime_flag: u32 = 32768;
pub const EXPIRES_ON_RESET: i32 = -2147483648;
pub const EXPIRES_ON_RESTART: i32 = -2147483647;
pub const SU_NONE_VALUE: u32 = 65535;
pub const SU_DA_USED_VALUE: u32 = 65534;
pub const PRE_STARTUP_FLAG: u32 = 32768;
pub const STARTUP_LOCALITY_3: u32 = 16384;
pub const NV_PERSISTENT_DATA: u32 = 0;
pub const NV_USER_DYNAMIC_END: u32 = 16384;
pub type __u_char = crate::cty::c_uchar;
pub type __u_short = crate::cty::c_ushort;
pub type __u_int = crate::cty::c_uint;
pub type __u_long = crate::cty::c_ulong;
pub type __int8_t = crate::cty::c_schar;
pub type __uint8_t = crate::cty::c_uchar;
pub type __int16_t = crate::cty::c_short;
pub type __uint16_t = crate::cty::c_ushort;
pub type __int32_t = crate::cty::c_int;
pub type __uint32_t = crate::cty::c_uint;
pub type __int64_t = crate::cty::c_long;
pub type __uint64_t = crate::cty::c_ulong;
pub type __quad_t = crate::cty::c_long;
pub type __u_quad_t = crate::cty::c_ulong;
pub type __intmax_t = crate::cty::c_long;
pub type __uintmax_t = crate::cty::c_ulong;
pub type __dev_t = crate::cty::c_ulong;
pub type __uid_t = crate::cty::c_uint;
pub type __gid_t = crate::cty::c_uint;
pub type __ino_t = crate::cty::c_ulong;
pub type __ino64_t = crate::cty::c_ulong;
pub type __mode_t = crate::cty::c_uint;
pub type __nlink_t = crate::cty::c_ulong;
pub type __off_t = crate::cty::c_long;
pub type __off64_t = crate::cty::c_long;
pub type __pid_t = crate::cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [crate::cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = crate::cty::c_long;
pub type __rlim_t = crate::cty::c_ulong;
pub type __rlim64_t = crate::cty::c_ulong;
pub type __id_t = crate::cty::c_uint;
pub type __time_t = crate::cty::c_long;
pub type __useconds_t = crate::cty::c_uint;
pub type __suseconds_t = crate::cty::c_long;
pub type __daddr_t = crate::cty::c_int;
pub type __key_t = crate::cty::c_int;
pub type __clockid_t = crate::cty::c_int;
pub type __timer_t = *mut crate::cty::c_void;
pub type __blksize_t = crate::cty::c_long;
pub type __blkcnt_t = crate::cty::c_long;
pub type __blkcnt64_t = crate::cty::c_long;
pub type __fsblkcnt_t = crate::cty::c_ulong;
pub type __fsblkcnt64_t = crate::cty::c_ulong;
pub type __fsfilcnt_t = crate::cty::c_ulong;
pub type __fsfilcnt64_t = crate::cty::c_ulong;
pub type __fsword_t = crate::cty::c_long;
pub type __ssize_t = crate::cty::c_long;
pub type __syscall_slong_t = crate::cty::c_long;
pub type __syscall_ulong_t = crate::cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut crate::cty::c_char;
pub type __intptr_t = crate::cty::c_long;
pub type __socklen_t = crate::cty::c_uint;
pub type __sig_atomic_t = crate::cty::c_int;
pub type int_least8_t = crate::cty::c_schar;
pub type int_least16_t = crate::cty::c_short;
pub type int_least32_t = crate::cty::c_int;
pub type int_least64_t = crate::cty::c_long;
pub type uint_least8_t = crate::cty::c_uchar;
pub type uint_least16_t = crate::cty::c_ushort;
pub type uint_least32_t = crate::cty::c_uint;
pub type uint_least64_t = crate::cty::c_ulong;
pub type int_fast8_t = crate::cty::c_schar;
pub type int_fast16_t = crate::cty::c_long;
pub type int_fast32_t = crate::cty::c_long;
pub type int_fast64_t = crate::cty::c_long;
pub type uint_fast8_t = crate::cty::c_uchar;
pub type uint_fast16_t = crate::cty::c_ulong;
pub type uint_fast32_t = crate::cty::c_ulong;
pub type uint_fast64_t = crate::cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type UINT8 = u8;
pub type BYTE = u8;
pub type INT8 = i8;
pub type BOOL = crate::cty::c_int;
pub type UINT16 = u16;
pub type INT16 = i16;
pub type UINT32 = u32;
pub type INT32 = i32;
pub type UINT64 = u64;
pub type INT64 = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B {
    pub size: UINT16,
    pub buffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_TPM2B() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B>(),
        4usize,
        concat!("Size of: ", stringify!(TPM2B))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B>())).buffer as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B),
            "::",
            stringify!(buffer)
        )
    );
}
pub type P2B = *mut TPM2B;
pub type PC2B = *const TPM2B;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_MAX_HASH_BLOCK {
    pub t: TPM2B_MAX_HASH_BLOCK__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 128usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_HASH_BLOCK__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_MAX_HASH_BLOCK__bindgen_ty_1>(),
        130usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_HASH_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_MAX_HASH_BLOCK__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_MAX_HASH_BLOCK__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_MAX_HASH_BLOCK__bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_HASH_BLOCK__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_MAX_HASH_BLOCK__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_HASH_BLOCK__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_HASH_BLOCK() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_MAX_HASH_BLOCK>(),
        130usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_HASH_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_MAX_HASH_BLOCK>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_MAX_HASH_BLOCK))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_MAX_HASH_BLOCK>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_HASH_BLOCK),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_MAX_HASH_BLOCK>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_HASH_BLOCK),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_HASH_BLOCK = TPM2B_MAX_HASH_BLOCK;
pub type size_t = crate::cty::c_ulong;
pub type wchar_t = crate::cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aes_key_st {
    pub rd_key: [crate::cty::c_uint; 60usize],
    pub rounds: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_aes_key_st() {
    assert_eq!(
        ::core::mem::size_of::<aes_key_st>(),
        244usize,
        concat!("Size of: ", stringify!(aes_key_st))
    );
    assert_eq!(
        ::core::mem::align_of::<aes_key_st>(),
        4usize,
        concat!("Alignment of ", stringify!(aes_key_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_key_st>())).rd_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_key_st),
            "::",
            stringify!(rd_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_key_st>())).rounds as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_key_st),
            "::",
            stringify!(rounds)
        )
    );
}
pub type AES_KEY = aes_key_st;
extern "C" {
    pub fn AES_options() -> *const crate::cty::c_char;
}
extern "C" {
    pub fn AES_set_encrypt_key(
        userKey: *const crate::cty::c_uchar,
        bits: crate::cty::c_int,
        key: *mut AES_KEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn AES_set_decrypt_key(
        userKey: *const crate::cty::c_uchar,
        bits: crate::cty::c_int,
        key: *mut AES_KEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn AES_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        key: *const AES_KEY,
    );
}
extern "C" {
    pub fn AES_decrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        key: *const AES_KEY,
    );
}
extern "C" {
    pub fn AES_ecb_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        key: *const AES_KEY,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_cbc_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        ivec: *mut crate::cty::c_uchar,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_cfb128_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_cfb1_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_cfb8_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_ofb128_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_ige_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        ivec: *mut crate::cty::c_uchar,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_bi_ige_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        key2: *const AES_KEY,
        ivec: *const crate::cty::c_uchar,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn AES_wrap_key(
        key: *mut AES_KEY,
        iv: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        in_: *const crate::cty::c_uchar,
        inlen: crate::cty::c_uint,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn AES_unwrap_key(
        key: *mut AES_KEY,
        iv: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        in_: *const crate::cty::c_uchar,
        inlen: crate::cty::c_uint,
    ) -> crate::cty::c_int;
}
pub type KEY_TABLE_TYPE = [crate::cty::c_uint; 68usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct camellia_key_st {
    pub u: camellia_key_st__bindgen_ty_1,
    pub grand_rounds: crate::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union camellia_key_st__bindgen_ty_1 {
    pub d: f64,
    pub rd_key: KEY_TABLE_TYPE,
}
#[test]
fn bindgen_test_layout_camellia_key_st__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<camellia_key_st__bindgen_ty_1>(),
        272usize,
        concat!("Size of: ", stringify!(camellia_key_st__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<camellia_key_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(camellia_key_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<camellia_key_st__bindgen_ty_1>())).d as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_key_st__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<camellia_key_st__bindgen_ty_1>())).rd_key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_key_st__bindgen_ty_1),
            "::",
            stringify!(rd_key)
        )
    );
}
#[test]
fn bindgen_test_layout_camellia_key_st() {
    assert_eq!(
        ::core::mem::size_of::<camellia_key_st>(),
        280usize,
        concat!("Size of: ", stringify!(camellia_key_st))
    );
    assert_eq!(
        ::core::mem::align_of::<camellia_key_st>(),
        8usize,
        concat!("Alignment of ", stringify!(camellia_key_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<camellia_key_st>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_key_st),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<camellia_key_st>())).grand_rounds as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_key_st),
            "::",
            stringify!(grand_rounds)
        )
    );
}
pub type CAMELLIA_KEY = camellia_key_st;
extern "C" {
    pub fn Camellia_set_key(
        userKey: *const crate::cty::c_uchar,
        bits: crate::cty::c_int,
        key: *mut CAMELLIA_KEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn Camellia_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        key: *const CAMELLIA_KEY,
    );
}
extern "C" {
    pub fn Camellia_decrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        key: *const CAMELLIA_KEY,
    );
}
extern "C" {
    pub fn Camellia_ecb_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        key: *const CAMELLIA_KEY,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn Camellia_cbc_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const CAMELLIA_KEY,
        ivec: *mut crate::cty::c_uchar,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn Camellia_cfb128_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const CAMELLIA_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn Camellia_cfb1_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const CAMELLIA_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn Camellia_cfb8_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const CAMELLIA_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
        enc: crate::cty::c_int,
    );
}
extern "C" {
    pub fn Camellia_ofb128_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const CAMELLIA_KEY,
        ivec: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_int,
    );
}
extern "C" {
    pub fn Camellia_ctr128_encrypt(
        in_: *const crate::cty::c_uchar,
        out: *mut crate::cty::c_uchar,
        length: size_t,
        key: *const CAMELLIA_KEY,
        ivec: *mut crate::cty::c_uchar,
        ecount_buf: *mut crate::cty::c_uchar,
        num: *mut crate::cty::c_uint,
    );
}
pub type __gwchar_t = crate::cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: crate::cty::c_long,
    pub rem: crate::cty::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const crate::cty::c_char,
        __endptr: *mut *mut crate::cty::c_char,
        __base: crate::cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const crate::cty::c_char,
        __endptr: *mut *mut crate::cty::c_char,
        __base: crate::cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: crate::cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: crate::cty::c_int,
    ) -> uintmax_t;
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: crate::cty::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: crate::cty::c_uint,
    pub __wchb: [crate::cty::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = crate::cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::core::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = crate::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: crate::cty::c_int,
    pub _IO_read_ptr: *mut crate::cty::c_char,
    pub _IO_read_end: *mut crate::cty::c_char,
    pub _IO_read_base: *mut crate::cty::c_char,
    pub _IO_write_base: *mut crate::cty::c_char,
    pub _IO_write_ptr: *mut crate::cty::c_char,
    pub _IO_write_end: *mut crate::cty::c_char,
    pub _IO_buf_base: *mut crate::cty::c_char,
    pub _IO_buf_end: *mut crate::cty::c_char,
    pub _IO_save_base: *mut crate::cty::c_char,
    pub _IO_backup_base: *mut crate::cty::c_char,
    pub _IO_save_end: *mut crate::cty::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: crate::cty::c_int,
    pub _flags2: crate::cty::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: crate::cty::c_ushort,
    pub _vtable_offset: crate::cty::c_schar,
    pub _shortbuf: [crate::cty::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut crate::cty::c_void,
    pub __pad2: *mut crate::cty::c_void,
    pub __pad3: *mut crate::cty::c_void,
    pub __pad4: *mut crate::cty::c_void,
    pub __pad5: size_t,
    pub _mode: crate::cty::c_int,
    pub _unused2: [crate::cty::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut crate::cty::c_void,
        __buf: *mut crate::cty::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut crate::cty::c_void,
        __buf: *const crate::cty::c_char,
        __n: size_t,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut crate::cty::c_void,
        __pos: *mut __off64_t,
        __w: crate::cty::c_int,
    ) -> crate::cty::c_int,
>;
pub type __io_close_fn = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut crate::cty::c_void) -> crate::cty::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: crate::cty::c_int, __fp: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const crate::cty::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const crate::cty::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: crate::cty::c_int, arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut crate::cty::c_void, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: crate::cty::c_int,
        arg4: crate::cty::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: crate::cty::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const crate::cty::c_char,
        __new: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut crate::cty::c_char) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const crate::cty::c_char,
        __modes: *const crate::cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const crate::cty::c_char,
        __modes: *const crate::cty::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut crate::cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut crate::cty::c_char,
        __modes: crate::cty::c_int,
        __n: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn printf(__format: *const crate::cty::c_char, ...) -> crate::cty::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut crate::cty::c_char,
        __format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut crate::cty::c_char,
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut crate::cty::c_char,
        __maxlen: crate::cty::c_ulong,
        __format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut crate::cty::c_char,
        __maxlen: crate::cty::c_ulong,
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn scanf(__format: *const crate::cty::c_char, ...) -> crate::cty::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const crate::cty::c_char,
        __format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const crate::cty::c_char, ...) -> crate::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const crate::cty::c_char,
        __format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const crate::cty::c_char,
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const crate::cty::c_char,
        __format: *const crate::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn getchar() -> crate::cty::c_int;
}
extern "C" {
    pub fn fputc(__c: crate::cty::c_int, __stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn putc(__c: crate::cty::c_int, __stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn putchar(__c: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut crate::cty::c_char,
        __n: crate::cty::c_int,
        __stream: *mut FILE,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn fputs(__s: *const crate::cty::c_char, __stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn puts(__s: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn ungetc(__c: crate::cty::c_int, __stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut crate::cty::c_void,
        __size: crate::cty::c_ulong,
        __n: crate::cty::c_ulong,
        __stream: *mut FILE,
    ) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const crate::cty::c_void,
        __size: crate::cty::c_ulong,
        __n: crate::cty::c_ulong,
        __s: *mut FILE,
    ) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: crate::cty::c_long,
        __whence: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> crate::cty::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> crate::cty::c_int;
}
extern "C" {
    pub fn perror(__s: *const crate::cty::c_char);
}
pub type ASN1_INTEGER = asn1_string_st;
pub type ASN1_ENUMERATED = asn1_string_st;
pub type ASN1_BIT_STRING = asn1_string_st;
pub type ASN1_OCTET_STRING = asn1_string_st;
pub type ASN1_PRINTABLESTRING = asn1_string_st;
pub type ASN1_T61STRING = asn1_string_st;
pub type ASN1_IA5STRING = asn1_string_st;
pub type ASN1_GENERALSTRING = asn1_string_st;
pub type ASN1_UNIVERSALSTRING = asn1_string_st;
pub type ASN1_BMPSTRING = asn1_string_st;
pub type ASN1_UTCTIME = asn1_string_st;
pub type ASN1_TIME = asn1_string_st;
pub type ASN1_GENERALIZEDTIME = asn1_string_st;
pub type ASN1_VISIBLESTRING = asn1_string_st;
pub type ASN1_UTF8STRING = asn1_string_st;
pub type ASN1_STRING = asn1_string_st;
pub type ASN1_BOOLEAN = crate::cty::c_int;
pub type ASN1_NULL = crate::cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_object_st {
    _unused: [u8; 0],
}
pub type ASN1_OBJECT = asn1_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ITEM_st {
    _unused: [u8; 0],
}
pub type ASN1_ITEM = ASN1_ITEM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_pctx_st {
    _unused: [u8; 0],
}
pub type ASN1_PCTX = asn1_pctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_sctx_st {
    _unused: [u8; 0],
}
pub type ASN1_SCTX = asn1_sctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dane_st {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_st {
    _unused: [u8; 0],
}
pub type BIO = bio_st;
pub type BIGNUM = bignum_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_ctx {
    _unused: [u8; 0],
}
pub type BN_CTX = bignum_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_blinding_st {
    _unused: [u8; 0],
}
pub type BN_BLINDING = bn_blinding_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_mont_ctx_st {
    _unused: [u8; 0],
}
pub type BN_MONT_CTX = bn_mont_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_recp_ctx_st {
    _unused: [u8; 0],
}
pub type BN_RECP_CTX = bn_recp_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_gencb_st {
    _unused: [u8; 0],
}
pub type BN_GENCB = bn_gencb_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_mem_st {
    _unused: [u8; 0],
}
pub type BUF_MEM = buf_mem_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER = evp_cipher_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER_CTX = evp_cipher_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_st {
    _unused: [u8; 0],
}
pub type EVP_MD = evp_md_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_MD_CTX = evp_md_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY = evp_pkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_asn1_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_ASN1_METHOD = evp_pkey_asn1_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_METHOD = evp_pkey_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_Encode_Ctx_st {
    _unused: [u8; 0],
}
pub type EVP_ENCODE_CTX = evp_Encode_Ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_ctx_st {
    _unused: [u8; 0],
}
pub type HMAC_CTX = hmac_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_st {
    _unused: [u8; 0],
}
pub type DH = dh_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_method {
    _unused: [u8; 0],
}
pub type DH_METHOD = dh_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_st {
    _unused: [u8; 0],
}
pub type DSA = dsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_method {
    _unused: [u8; 0],
}
pub type DSA_METHOD = dsa_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_st {
    _unused: [u8; 0],
}
pub type RSA = rsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_meth_st {
    _unused: [u8; 0],
}
pub type RSA_METHOD = rsa_meth_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
pub type EC_KEY = ec_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_method_st {
    _unused: [u8; 0],
}
pub type EC_KEY_METHOD = ec_key_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_meth_st {
    _unused: [u8; 0],
}
pub type RAND_METHOD = rand_meth_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_drbg_st {
    _unused: [u8; 0],
}
pub type RAND_DRBG = rand_drbg_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_dane_st {
    _unused: [u8; 0],
}
pub type SSL_DANE = ssl_dane_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_st {
    _unused: [u8; 0],
}
pub type X509 = x509_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_algor_st {
    _unused: [u8; 0],
}
pub type X509_ALGOR = X509_algor_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_st {
    _unused: [u8; 0],
}
pub type X509_CRL = X509_crl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crl_method_st {
    _unused: [u8; 0],
}
pub type X509_CRL_METHOD = x509_crl_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_revoked_st {
    _unused: [u8; 0],
}
pub type X509_REVOKED = x509_revoked_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_st {
    _unused: [u8; 0],
}
pub type X509_NAME = X509_name_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_pubkey_st {
    _unused: [u8; 0],
}
pub type X509_PUBKEY = X509_pubkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_st {
    _unused: [u8; 0],
}
pub type X509_STORE = x509_store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_ctx_st {
    _unused: [u8; 0],
}
pub type X509_STORE_CTX = x509_store_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_object_st {
    _unused: [u8; 0],
}
pub type X509_OBJECT = x509_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP = x509_lookup_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_method_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP_METHOD = x509_lookup_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_VERIFY_PARAM_st {
    _unused: [u8; 0],
}
pub type X509_VERIFY_PARAM = X509_VERIFY_PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_sig_info_st {
    _unused: [u8; 0],
}
pub type X509_SIG_INFO = x509_sig_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs8_priv_key_info_st {
    _unused: [u8; 0],
}
pub type PKCS8_PRIV_KEY_INFO = pkcs8_priv_key_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v3_ext_ctx {
    _unused: [u8; 0],
}
pub type X509V3_CTX = v3_ext_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_st {
    _unused: [u8; 0],
}
pub type CONF = conf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_init_settings_st {
    _unused: [u8; 0],
}
pub type OPENSSL_INIT_SETTINGS = ossl_init_settings_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_st {
    _unused: [u8; 0],
}
pub type UI = ui_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_method_st {
    _unused: [u8; 0],
}
pub type UI_METHOD = ui_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine_st {
    _unused: [u8; 0],
}
pub type ENGINE = engine_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    _unused: [u8; 0],
}
pub type SSL = ssl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CTX = ssl_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_ctx_st {
    _unused: [u8; 0],
}
pub type COMP_CTX = comp_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_method_st {
    _unused: [u8; 0],
}
pub type COMP_METHOD = comp_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_NODE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_NODE = X509_POLICY_NODE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_LEVEL_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_LEVEL = X509_POLICY_LEVEL_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_TREE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_TREE = X509_POLICY_TREE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_CACHE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_CACHE = X509_POLICY_CACHE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUTHORITY_KEYID_st {
    _unused: [u8; 0],
}
pub type AUTHORITY_KEYID = AUTHORITY_KEYID_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIST_POINT_st {
    _unused: [u8; 0],
}
pub type DIST_POINT = DIST_POINT_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISSUING_DIST_POINT_st {
    _unused: [u8; 0],
}
pub type ISSUING_DIST_POINT = ISSUING_DIST_POINT_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAME_CONSTRAINTS_st {
    _unused: [u8; 0],
}
pub type NAME_CONSTRAINTS = NAME_CONSTRAINTS_st;
pub type CRYPTO_EX_DATA = crypto_ex_data_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_req_ctx_st {
    _unused: [u8; 0],
}
pub type OCSP_REQ_CTX = ocsp_req_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_response_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPONSE = ocsp_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_responder_id_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPID = ocsp_responder_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sct_st {
    _unused: [u8; 0],
}
pub type SCT = sct_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sct_ctx_st {
    _unused: [u8; 0],
}
pub type SCT_CTX = sct_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlog_st {
    _unused: [u8; 0],
}
pub type CTLOG = ctlog_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlog_store_st {
    _unused: [u8; 0],
}
pub type CTLOG_STORE = ctlog_store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_policy_eval_ctx_st {
    _unused: [u8; 0],
}
pub type CT_POLICY_EVAL_CTX = ct_policy_eval_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_store_info_st {
    _unused: [u8; 0],
}
pub type OSSL_STORE_INFO = ossl_store_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_store_search_st {
    _unused: [u8; 0],
}
pub type OSSL_STORE_SEARCH = ossl_store_search_st;
pub type ossl_intmax_t = intmax_t;
pub type ossl_uintmax_t = uintmax_t;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: crate::cty::c_int,
    pub rem: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: crate::cty::c_long,
    pub rem: crate::cty::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: crate::cty::c_longlong,
    pub rem: crate::cty::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const crate::cty::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const crate::cty::c_char) -> crate::cty::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const crate::cty::c_char) -> crate::cty::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const crate::cty::c_char, __endptr: *mut *mut crate::cty::c_char)
        -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const crate::cty::c_char, __endptr: *mut *mut crate::cty::c_char)
        -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const crate::cty::c_char,
        __endptr: *mut *mut crate::cty::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const crate::cty::c_char,
        __endptr: *mut *mut crate::cty::c_char,
        __base: crate::cty::c_int,
    ) -> crate::cty::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const crate::cty::c_char,
        __endptr: *mut *mut crate::cty::c_char,
        __base: crate::cty::c_int,
    ) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const crate::cty::c_char,
        __endptr: *mut *mut crate::cty::c_char,
        __base: crate::cty::c_int,
    ) -> crate::cty::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const crate::cty::c_char,
        __endptr: *mut *mut crate::cty::c_char,
        __base: crate::cty::c_int,
    ) -> crate::cty::c_ulonglong;
}
extern "C" {
    pub fn rand() -> crate::cty::c_int;
}
extern "C" {
    pub fn srand(__seed: crate::cty::c_uint);
}
extern "C" {
    pub fn malloc(__size: crate::cty::c_ulong) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: crate::cty::c_ulong,
        __size: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut crate::cty::c_void,
        __size: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut crate::cty::c_void);
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> crate::cty::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn exit(__status: crate::cty::c_int);
}
extern "C" {
    pub fn quick_exit(__status: crate::cty::c_int);
}
extern "C" {
    pub fn _Exit(__status: crate::cty::c_int);
}
extern "C" {
    pub fn getenv(__name: *const crate::cty::c_char) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn system(__command: *const crate::cty::c_char) -> crate::cty::c_int;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::cty::c_void,
        arg2: *const crate::cty::c_void,
    ) -> crate::cty::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const crate::cty::c_void,
        __base: *const crate::cty::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut crate::cty::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn labs(__x: crate::cty::c_long) -> crate::cty::c_long;
}
extern "C" {
    pub fn llabs(__x: crate::cty::c_longlong) -> crate::cty::c_longlong;
}
extern "C" {
    pub fn div(__numer: crate::cty::c_int, __denom: crate::cty::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: crate::cty::c_long, __denom: crate::cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: crate::cty::c_longlong, __denom: crate::cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const crate::cty::c_char, __n: size_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const crate::cty::c_char,
        __n: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut crate::cty::c_char, __wchar: wchar_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const crate::cty::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcstombs(__s: *mut crate::cty::c_char, __pwcs: *const wchar_t, __n: size_t) -> size_t;
}
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: crate::cty::c_int,
    pub tm_min: crate::cty::c_int,
    pub tm_hour: crate::cty::c_int,
    pub tm_mday: crate::cty::c_int,
    pub tm_mon: crate::cty::c_int,
    pub tm_year: crate::cty::c_int,
    pub tm_wday: crate::cty::c_int,
    pub tm_yday: crate::cty::c_int,
    pub tm_isdst: crate::cty::c_int,
    pub __tm_gmtoff: crate::cty::c_long,
    pub __tm_zone: *const crate::cty::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).__tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(__tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).__tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(__tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut crate::cty::c_char,
        __maxsize: size_t,
        __format: *const crate::cty::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut crate::cty::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut crate::cty::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: crate::cty::c_int;
}
extern "C" {
    pub static mut __timezone: crate::cty::c_long;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: crate::cty::c_int) -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st {
    _unused: [u8; 0],
}
pub type OPENSSL_STACK = stack_st;
pub type OPENSSL_sk_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::cty::c_void,
        arg2: *const crate::cty::c_void,
    ) -> crate::cty::c_int,
>;
pub type OPENSSL_sk_freefunc =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::cty::c_void)>;
pub type OPENSSL_sk_copyfunc = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const crate::cty::c_void) -> *mut crate::cty::c_void,
>;
extern "C" {
    pub fn OPENSSL_sk_num(arg1: *const OPENSSL_STACK) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_value(
        arg1: *const OPENSSL_STACK,
        arg2: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_set(
        st: *mut OPENSSL_STACK,
        i: crate::cty::c_int,
        data: *const crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_new(cmp: OPENSSL_sk_compfunc) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_new_null() -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_new_reserve(
        c: OPENSSL_sk_compfunc,
        n: crate::cty::c_int,
    ) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_reserve(st: *mut OPENSSL_STACK, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_free(arg1: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_pop_free(
        st: *mut OPENSSL_STACK,
        func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::cty::c_void)>,
    );
}
extern "C" {
    pub fn OPENSSL_sk_deep_copy(
        arg1: *const OPENSSL_STACK,
        c: OPENSSL_sk_copyfunc,
        f: OPENSSL_sk_freefunc,
    ) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_insert(
        sk: *mut OPENSSL_STACK,
        data: *const crate::cty::c_void,
        where_: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_delete(
        st: *mut OPENSSL_STACK,
        loc: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_delete_ptr(
        st: *mut OPENSSL_STACK,
        p: *const crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_find(
        st: *mut OPENSSL_STACK,
        data: *const crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_find_ex(
        st: *mut OPENSSL_STACK,
        data: *const crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_push(
        st: *mut OPENSSL_STACK,
        data: *const crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_unshift(
        st: *mut OPENSSL_STACK,
        data: *const crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_shift(st: *mut OPENSSL_STACK) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_pop(st: *mut OPENSSL_STACK) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_zero(st: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_set_cmp_func(
        sk: *mut OPENSSL_STACK,
        cmp: OPENSSL_sk_compfunc,
    ) -> OPENSSL_sk_compfunc;
}
extern "C" {
    pub fn OPENSSL_sk_dup(st: *const OPENSSL_STACK) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_sort(st: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_is_sorted(st: *const OPENSSL_STACK) -> crate::cty::c_int;
}
pub type OPENSSL_STRING = *mut crate::cty::c_char;
pub type OPENSSL_CSTRING = *const crate::cty::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_STRING {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_STRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const crate::cty::c_char,
        b: *const *const crate::cty::c_char,
    ) -> crate::cty::c_int,
>;
pub type sk_OPENSSL_STRING_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut crate::cty::c_char)>;
pub type sk_OPENSSL_STRING_copyfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const crate::cty::c_char) -> *mut crate::cty::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_CSTRING {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_CSTRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const crate::cty::c_char,
        b: *const *const crate::cty::c_char,
    ) -> crate::cty::c_int,
>;
pub type sk_OPENSSL_CSTRING_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut crate::cty::c_char)>;
pub type sk_OPENSSL_CSTRING_copyfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const crate::cty::c_char) -> *mut crate::cty::c_char,
>;
pub type OPENSSL_BLOCK = *mut crate::cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_BLOCK {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_BLOCK_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const crate::cty::c_void,
        b: *const *const crate::cty::c_void,
    ) -> crate::cty::c_int,
>;
pub type sk_OPENSSL_BLOCK_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut crate::cty::c_void)>;
pub type sk_OPENSSL_BLOCK_copyfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const crate::cty::c_void) -> *mut crate::cty::c_void,
>;
extern "C" {
    pub fn ERR_load_CRYPTO_strings() -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock {
    pub dummy: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_CRYPTO_dynlock() {
    assert_eq!(
        ::core::mem::size_of::<CRYPTO_dynlock>(),
        4usize,
        concat!("Size of: ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYPTO_dynlock>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYPTO_dynlock>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_dynlock),
            "::",
            stringify!(dummy)
        )
    );
}
pub type CRYPTO_RWLOCK = crate::cty::c_void;
extern "C" {
    pub fn CRYPTO_THREAD_lock_new() -> *mut CRYPTO_RWLOCK;
}
extern "C" {
    pub fn CRYPTO_THREAD_read_lock(lock: *mut CRYPTO_RWLOCK) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_write_lock(lock: *mut CRYPTO_RWLOCK) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_unlock(lock: *mut CRYPTO_RWLOCK) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_lock_free(lock: *mut CRYPTO_RWLOCK);
}
extern "C" {
    pub fn CRYPTO_atomic_add(
        val: *mut crate::cty::c_int,
        amount: crate::cty::c_int,
        ret: *mut crate::cty::c_int,
        lock: *mut CRYPTO_RWLOCK,
    ) -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_ex_data_st {
    pub sk: *mut stack_st_void,
}
#[test]
fn bindgen_test_layout_crypto_ex_data_st() {
    assert_eq!(
        ::core::mem::size_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Size of: ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<crypto_ex_data_st>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_st),
            "::",
            stringify!(sk)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_void {
    _unused: [u8; 0],
}
pub type sk_void_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const crate::cty::c_void,
        b: *const *const crate::cty::c_void,
    ) -> crate::cty::c_int,
>;
pub type sk_void_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut crate::cty::c_void)>;
pub type sk_void_copyfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const crate::cty::c_void) -> *mut crate::cty::c_void,
>;
extern "C" {
    pub fn CRYPTO_mem_ctrl(mode: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_strlcpy(
        dst: *mut crate::cty::c_char,
        src: *const crate::cty::c_char,
        siz: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OPENSSL_strlcat(
        dst: *mut crate::cty::c_char,
        src: *const crate::cty::c_char,
        siz: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OPENSSL_strnlen(str_: *const crate::cty::c_char, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn OPENSSL_buf2hexstr(
        buffer: *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn OPENSSL_hexstr2buf(
        str_: *const crate::cty::c_char,
        len: *mut crate::cty::c_long,
    ) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn OPENSSL_hexchar2int(c: crate::cty::c_uchar) -> crate::cty::c_int;
}
extern "C" {
    pub fn OpenSSL_version_num() -> crate::cty::c_ulong;
}
extern "C" {
    pub fn OpenSSL_version(type_: crate::cty::c_int) -> *const crate::cty::c_char;
}
extern "C" {
    pub fn OPENSSL_issetugid() -> crate::cty::c_int;
}
pub type CRYPTO_EX_new = ::core::option::Option<
    unsafe extern "C" fn(
        parent: *mut crate::cty::c_void,
        ptr: *mut crate::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: crate::cty::c_int,
        argl: crate::cty::c_long,
        argp: *mut crate::cty::c_void,
    ),
>;
pub type CRYPTO_EX_free = ::core::option::Option<
    unsafe extern "C" fn(
        parent: *mut crate::cty::c_void,
        ptr: *mut crate::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: crate::cty::c_int,
        argl: crate::cty::c_long,
        argp: *mut crate::cty::c_void,
    ),
>;
pub type CRYPTO_EX_dup = ::core::option::Option<
    unsafe extern "C" fn(
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
        from_d: *mut crate::cty::c_void,
        idx: crate::cty::c_int,
        argl: crate::cty::c_long,
        argp: *mut crate::cty::c_void,
    ) -> crate::cty::c_int,
>;
extern "C" {
    pub fn CRYPTO_get_ex_new_index(
        class_index: crate::cty::c_int,
        argl: crate::cty::c_long,
        argp: *mut crate::cty::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_free_ex_index(
        class_index: crate::cty::c_int,
        idx: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_new_ex_data(
        class_index: crate::cty::c_int,
        obj: *mut crate::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_dup_ex_data(
        class_index: crate::cty::c_int,
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_free_ex_data(
        class_index: crate::cty::c_int,
        obj: *mut crate::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
    );
}
extern "C" {
    pub fn CRYPTO_set_ex_data(
        ad: *mut CRYPTO_EX_DATA,
        idx: crate::cty::c_int,
        val: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_get_ex_data(
        ad: *const CRYPTO_EX_DATA,
        idx: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_threadid_st {
    pub dummy: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_crypto_threadid_st() {
    assert_eq!(
        ::core::mem::size_of::<crypto_threadid_st>(),
        4usize,
        concat!("Size of: ", stringify!(crypto_threadid_st))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_threadid_st>(),
        4usize,
        concat!("Alignment of ", stringify!(crypto_threadid_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<crypto_threadid_st>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_threadid_st),
            "::",
            stringify!(dummy)
        )
    );
}
pub type CRYPTO_THREADID = crypto_threadid_st;
extern "C" {
    pub fn CRYPTO_set_mem_functions(
        m: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *const crate::cty::c_char,
                arg3: crate::cty::c_int,
            ) -> *mut crate::cty::c_void,
        >,
        r: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::cty::c_void,
                arg2: size_t,
                arg3: *const crate::cty::c_char,
                arg4: crate::cty::c_int,
            ) -> *mut crate::cty::c_void,
        >,
        f: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::cty::c_void,
                arg2: *const crate::cty::c_char,
                arg3: crate::cty::c_int,
            ),
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_set_mem_debug(flag: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_get_mem_functions(
        m: *mut ::core::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *const crate::cty::c_char,
                arg3: crate::cty::c_int,
            ) -> *mut crate::cty::c_void,
        >,
        r: *mut ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::cty::c_void,
                arg2: size_t,
                arg3: *const crate::cty::c_char,
                arg4: crate::cty::c_int,
            ) -> *mut crate::cty::c_void,
        >,
        f: *mut ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::cty::c_void,
                arg2: *const crate::cty::c_char,
                arg3: crate::cty::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_malloc(
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_zalloc(
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_memdup(
        str_: *const crate::cty::c_void,
        siz: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_strdup(
        str_: *const crate::cty::c_char,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn CRYPTO_strndup(
        str_: *const crate::cty::c_char,
        s: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn CRYPTO_free(
        ptr: *mut crate::cty::c_void,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_clear_free(
        ptr: *mut crate::cty::c_void,
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_realloc(
        addr: *mut crate::cty::c_void,
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_clear_realloc(
        addr: *mut crate::cty::c_void,
        old_num: size_t,
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_init(sz: size_t, minsize: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_done() -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc(
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_zalloc(
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_free(
        ptr: *mut crate::cty::c_void,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_secure_clear_free(
        ptr: *mut crate::cty::c_void,
        num: size_t,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_secure_allocated(ptr: *const crate::cty::c_void) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_initialized() -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_actual_size(ptr: *mut crate::cty::c_void) -> size_t;
}
extern "C" {
    pub fn CRYPTO_secure_used() -> size_t;
}
extern "C" {
    pub fn OPENSSL_cleanse(ptr: *mut crate::cty::c_void, len: size_t);
}
extern "C" {
    pub fn OPENSSL_die(
        assertion: *const crate::cty::c_char,
        file: *const crate::cty::c_char,
        line: crate::cty::c_int,
    );
}
extern "C" {
    pub fn OPENSSL_isservice() -> crate::cty::c_int;
}
extern "C" {
    pub fn FIPS_mode() -> crate::cty::c_int;
}
extern "C" {
    pub fn FIPS_mode_set(r: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_init();
}
extern "C" {
    pub fn OPENSSL_fork_prepare();
}
extern "C" {
    pub fn OPENSSL_fork_parent();
}
extern "C" {
    pub fn OPENSSL_fork_child();
}
extern "C" {
    pub fn OPENSSL_gmtime(timer: *const time_t, result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn OPENSSL_gmtime_adj(
        tm: *mut tm,
        offset_day: crate::cty::c_int,
        offset_sec: crate::cty::c_long,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_gmtime_diff(
        pday: *mut crate::cty::c_int,
        psec: *mut crate::cty::c_int,
        from: *const tm,
        to: *const tm,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_memcmp(
        in_a: *const crate::cty::c_void,
        in_b: *const crate::cty::c_void,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_cleanup();
}
extern "C" {
    pub fn OPENSSL_init_crypto(
        opts: u64,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_atexit(
        handler: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_thread_stop();
}
extern "C" {
    pub fn OPENSSL_INIT_new() -> *mut OPENSSL_INIT_SETTINGS;
}
extern "C" {
    pub fn OPENSSL_INIT_set_config_appname(
        settings: *mut OPENSSL_INIT_SETTINGS,
        config_file: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_INIT_free(settings: *mut OPENSSL_INIT_SETTINGS);
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = crate::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::core::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> crate::cty::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> crate::cty::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: crate::cty::c_int,
        __param: *const sched_param,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn sched_yield() -> crate::cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: crate::cty::c_uint,
    pub __writers: crate::cty::c_uint,
    pub __wrphase_futex: crate::cty::c_uint,
    pub __writers_futex: crate::cty::c_uint,
    pub __pad3: crate::cty::c_uint,
    pub __pad4: crate::cty::c_uint,
    pub __cur_writer: crate::cty::c_int,
    pub __shared: crate::cty::c_int,
    pub __rwelision: crate::cty::c_schar,
    pub __pad1: [crate::cty::c_uchar; 7usize],
    pub __pad2: crate::cty::c_ulong,
    pub __flags: crate::cty::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: crate::cty::c_int,
    pub __count: crate::cty::c_uint,
    pub __owner: crate::cty::c_int,
    pub __nusers: crate::cty::c_uint,
    pub __kind: crate::cty::c_int,
    pub __spins: crate::cty::c_short,
    pub __elision: crate::cty::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [crate::cty::c_uint; 2usize],
    pub __g_size: [crate::cty::c_uint; 2usize],
    pub __g1_orig_size: crate::cty::c_uint,
    pub __wrefs: crate::cty::c_uint,
    pub __g_signals: [crate::cty::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: crate::cty::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: crate::cty::c_uint,
    pub __high: crate::cty::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: crate::cty::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: crate::cty::c_uint,
    pub __high: crate::cty::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = crate::cty::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [crate::cty::c_char; 4usize],
    pub __align: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [crate::cty::c_char; 4usize],
    pub __align: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = crate::cty::c_uint;
pub type pthread_once_t = crate::cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [crate::cty::c_char; 56usize],
    pub __align: crate::cty::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [crate::cty::c_char; 40usize],
    pub __align: crate::cty::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [crate::cty::c_char; 48usize],
    pub __align: crate::cty::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type __jmp_buf = [crate::cty::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: crate::cty::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: crate::cty::c_uint = 1;
pub type _bindgen_ty_1 = crate::cty::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: crate::cty::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: crate::cty::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: crate::cty::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: crate::cty::c_uint = 3;
pub type _bindgen_ty_2 = crate::cty::c_uint;
pub const PTHREAD_INHERIT_SCHED: crate::cty::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: crate::cty::c_uint = 1;
pub type _bindgen_ty_3 = crate::cty::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: crate::cty::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: crate::cty::c_uint = 1;
pub type _bindgen_ty_4 = crate::cty::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: crate::cty::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: crate::cty::c_uint = 1;
pub type _bindgen_ty_5 = crate::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::cty::c_void)>,
    pub __arg: *mut crate::cty::c_void,
    pub __canceltype: crate::cty::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::core::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: crate::cty::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: crate::cty::c_uint = 1;
pub type _bindgen_ty_6 = crate::cty::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: crate::cty::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: crate::cty::c_uint = 1;
pub type _bindgen_ty_7 = crate::cty::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crate::cty::c_void) -> *mut crate::cty::c_void,
        >,
        __arg: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut crate::cty::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: crate::cty::c_int,
        __param: *const sched_param,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut crate::cty::c_int,
        __param: *mut sched_param,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: crate::cty::c_int,
        __oldstate: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: crate::cty::c_int,
        __oldtype: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut crate::cty::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::cty::c_void)>,
    pub __cancel_arg: *mut crate::cty::c_void,
    pub __do_it: crate::cty::c_int,
    pub __cancel_type: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: crate::cty::c_int,
        __old_ceiling: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crate::cty::c_void),
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::core::option::Option<unsafe extern "C" fn()>,
        __parent: ::core::option::Option<unsafe extern "C" fn()>,
        __child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::cty::c_int;
}
pub type CRYPTO_ONCE = pthread_once_t;
pub type CRYPTO_THREAD_LOCAL = pthread_key_t;
pub type CRYPTO_THREAD_ID = pthread_t;
extern "C" {
    pub fn CRYPTO_THREAD_run_once(
        once: *mut CRYPTO_ONCE,
        init: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_init_local(
        key: *mut CRYPTO_THREAD_LOCAL,
        cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::cty::c_void)>,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_get_local(key: *mut CRYPTO_THREAD_LOCAL) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_THREAD_set_local(
        key: *mut CRYPTO_THREAD_LOCAL,
        val: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_cleanup_local(key: *mut CRYPTO_THREAD_LOCAL) -> crate::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_get_current_id() -> CRYPTO_THREAD_ID;
}
extern "C" {
    pub fn CRYPTO_THREAD_compare_id(a: CRYPTO_THREAD_ID, b: CRYPTO_THREAD_ID) -> crate::cty::c_int;
}
extern "C" {
    pub fn ERR_load_BN_strings() -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_set_flags(b: *mut BIGNUM, n: crate::cty::c_int);
}
extern "C" {
    pub fn BN_get_flags(b: *const BIGNUM, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_with_flags(dest: *mut BIGNUM, b: *const BIGNUM, flags: crate::cty::c_int);
}
extern "C" {
    pub fn BN_GENCB_call(
        cb: *mut BN_GENCB,
        a: crate::cty::c_int,
        b: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GENCB_new() -> *mut BN_GENCB;
}
extern "C" {
    pub fn BN_GENCB_free(cb: *mut BN_GENCB);
}
extern "C" {
    pub fn BN_GENCB_set_old(
        gencb: *mut BN_GENCB,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: crate::cty::c_int,
                arg2: crate::cty::c_int,
                arg3: *mut crate::cty::c_void,
            ),
        >,
        cb_arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_set(
        gencb: *mut BN_GENCB,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: crate::cty::c_int,
                arg2: crate::cty::c_int,
                arg3: *mut BN_GENCB,
            ) -> crate::cty::c_int,
        >,
        cb_arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_get_arg(cb: *mut BN_GENCB) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn BN_abs_is_word(a: *const BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_is_zero(a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_is_one(a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_is_word(a: *const BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_is_odd(a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_zero_ex(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_value_one() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_options() -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn BN_CTX_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_secure_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_free(c: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_start(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_get(ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_CTX_end(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_rand(
        rnd: *mut BIGNUM,
        bits: crate::cty::c_int,
        top: crate::cty::c_int,
        bottom: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_priv_rand(
        rnd: *mut BIGNUM,
        bits: crate::cty::c_int,
        top: crate::cty::c_int,
        bottom: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_priv_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand(
        rnd: *mut BIGNUM,
        bits: crate::cty::c_int,
        top: crate::cty::c_int,
        bottom: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_num_bits(a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_num_bits_word(l: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_security_bits(L: crate::cty::c_int, N: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_secure_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_clear_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_copy(a: *mut BIGNUM, b: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_swap(a: *mut BIGNUM, b: *mut BIGNUM);
}
extern "C" {
    pub fn BN_bin2bn(
        s: *const crate::cty::c_uchar,
        len: crate::cty::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2bin(a: *const BIGNUM, to: *mut crate::cty::c_uchar) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_bn2binpad(
        a: *const BIGNUM,
        to: *mut crate::cty::c_uchar,
        tolen: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_lebin2bn(
        s: *const crate::cty::c_uchar,
        len: crate::cty::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2lebinpad(
        a: *const BIGNUM,
        to: *mut crate::cty::c_uchar,
        tolen: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mpi2bn(
        s: *const crate::cty::c_uchar,
        len: crate::cty::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2mpi(a: *const BIGNUM, to: *mut crate::cty::c_uchar) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_sub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_usub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_uadd(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_sqr(r: *mut BIGNUM, a: *const BIGNUM, ctx: *mut BN_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_set_negative(b: *mut BIGNUM, n: crate::cty::c_int);
}
extern "C" {
    pub fn BN_is_negative(b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_div(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        d: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_nnmod(
        r: *mut BIGNUM,
        m: *const BIGNUM,
        d: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_add(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_add_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_sub(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_sub_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: crate::cty::c_int,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: crate::cty::c_int,
        m: *const BIGNUM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_word(a: *const BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn BN_div_word(a: *mut BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn BN_mul_word(a: *mut BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_add_word(a: *mut BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_sub_word(a: *mut BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_set_word(a: *mut BIGNUM, w: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_get_word(a: *const BIGNUM) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn BN_cmp(a: *const BIGNUM, b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_is_bit_set(a: *const BIGNUM, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_lshift(r: *mut BIGNUM, a: *const BIGNUM, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_lshift1(r: *mut BIGNUM, a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_consttime(
        rr: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        in_mont: *mut BN_MONT_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_word(
        r: *mut BIGNUM,
        a: crate::cty::c_ulong,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp2_mont(
        r: *mut BIGNUM,
        a1: *const BIGNUM,
        p1: *const BIGNUM,
        a2: *const BIGNUM,
        p2: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_simple(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mask_bits(a: *mut BIGNUM, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_print_fp(fp: *mut FILE, a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_print(bio: *mut BIO, a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_reciprocal(
        r: *mut BIGNUM,
        m: *const BIGNUM,
        len: crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_rshift(r: *mut BIGNUM, a: *const BIGNUM, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_rshift1(r: *mut BIGNUM, a: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_clear(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_dup(a: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_ucmp(a: *const BIGNUM, b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_set_bit(a: *mut BIGNUM, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_clear_bit(a: *mut BIGNUM, n: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_bn2hex(a: *const BIGNUM) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn BN_bn2dec(a: *const BIGNUM) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn BN_hex2bn(a: *mut *mut BIGNUM, str_: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_dec2bn(a: *mut *mut BIGNUM, str_: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_asc2bn(a: *mut *mut BIGNUM, str_: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_gcd(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_kronecker(a: *const BIGNUM, b: *const BIGNUM, ctx: *mut BN_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_inverse(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_sqrt(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_consttime_swap(
        swap: crate::cty::c_ulong,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        nwords: crate::cty::c_int,
    );
}
extern "C" {
    pub fn BN_generate_prime(
        ret: *mut BIGNUM,
        bits: crate::cty::c_int,
        safe: crate::cty::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: crate::cty::c_int,
                arg2: crate::cty::c_int,
                arg3: *mut crate::cty::c_void,
            ),
        >,
        cb_arg: *mut crate::cty::c_void,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_is_prime(
        p: *const BIGNUM,
        nchecks: crate::cty::c_int,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: crate::cty::c_int,
                arg2: crate::cty::c_int,
                arg3: *mut crate::cty::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest(
        p: *const BIGNUM,
        nchecks: crate::cty::c_int,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: crate::cty::c_int,
                arg2: crate::cty::c_int,
                arg3: *mut crate::cty::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut crate::cty::c_void,
        do_trial_division: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_generate_prime_ex(
        ret: *mut BIGNUM,
        bits: crate::cty::c_int,
        safe: crate::cty::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_is_prime_ex(
        p: *const BIGNUM,
        nchecks: crate::cty::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest_ex(
        p: *const BIGNUM,
        nchecks: crate::cty::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: crate::cty::c_int,
        cb: *mut BN_GENCB,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_X931_generate_Xpq(
        Xp: *mut BIGNUM,
        Xq: *mut BIGNUM,
        nbits: crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_X931_derive_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp: *const BIGNUM,
        Xp1: *const BIGNUM,
        Xp2: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_X931_generate_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp1: *mut BIGNUM,
        Xp2: *mut BIGNUM,
        Xp: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new() -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_mod_mul_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_to_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_from_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_free(mont: *mut BN_MONT_CTX);
}
extern "C" {
    pub fn BN_MONT_CTX_set(
        mont: *mut BN_MONT_CTX,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_copy(to: *mut BN_MONT_CTX, from: *mut BN_MONT_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_set_locked(
        pmont: *mut *mut BN_MONT_CTX,
        lock: *mut CRYPTO_RWLOCK,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_BLINDING_new(
        A: *const BIGNUM,
        Ai: *const BIGNUM,
        mod_: *mut BIGNUM,
    ) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_BLINDING_free(b: *mut BN_BLINDING);
}
extern "C" {
    pub fn BN_BLINDING_update(b: *mut BN_BLINDING, ctx: *mut BN_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert(
        n: *mut BIGNUM,
        b: *mut BN_BLINDING,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert(
        n: *mut BIGNUM,
        b: *mut BN_BLINDING,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert_ex(
        n: *mut BIGNUM,
        r: *mut BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert_ex(
        n: *mut BIGNUM,
        r: *const BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_is_current_thread(b: *mut BN_BLINDING) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_set_current_thread(b: *mut BN_BLINDING);
}
extern "C" {
    pub fn BN_BLINDING_lock(b: *mut BN_BLINDING) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_unlock(b: *mut BN_BLINDING) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_get_flags(arg1: *const BN_BLINDING) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn BN_BLINDING_set_flags(arg1: *mut BN_BLINDING, arg2: crate::cty::c_ulong);
}
extern "C" {
    pub fn BN_BLINDING_create_param(
        b: *mut BN_BLINDING,
        e: *const BIGNUM,
        m: *mut BIGNUM,
        ctx: *mut BN_CTX,
        bn_mod_exp: ::core::option::Option<
            unsafe extern "C" fn(
                r: *mut BIGNUM,
                a: *const BIGNUM,
                p: *const BIGNUM,
                m: *const BIGNUM,
                ctx: *mut BN_CTX,
                m_ctx: *mut BN_MONT_CTX,
            ) -> crate::cty::c_int,
        >,
        m_ctx: *mut BN_MONT_CTX,
    ) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_set_params(
        mul: crate::cty::c_int,
        high: crate::cty::c_int,
        low: crate::cty::c_int,
        mont: crate::cty::c_int,
    );
}
extern "C" {
    pub fn BN_get_params(which: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_RECP_CTX_new() -> *mut BN_RECP_CTX;
}
extern "C" {
    pub fn BN_RECP_CTX_free(recp: *mut BN_RECP_CTX);
}
extern "C" {
    pub fn BN_RECP_CTX_set(
        recp: *mut BN_RECP_CTX,
        rdiv: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_mul_reciprocal(
        r: *mut BIGNUM,
        x: *const BIGNUM,
        y: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_recp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_div_recp(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod(r: *mut BIGNUM, a: *const BIGNUM, p: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv_arr(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_poly2arr(
        a: *const BIGNUM,
        p: *mut crate::cty::c_int,
        max: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_arr2poly(p: *const crate::cty::c_int, a: *mut BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_192(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_224(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_256(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_384(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_521(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_get0_nist_prime_192() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_224() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_256() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_384() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_521() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_nist_mod_func(
        p: *const BIGNUM,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            p: *mut BIGNUM,
            arg1: *const BIGNUM,
            arg2: *const BIGNUM,
            arg3: *mut BN_CTX,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn BN_generate_dsa_nonce(
        out: *mut BIGNUM,
        range: *const BIGNUM,
        priv_: *const BIGNUM,
        message: *const crate::cty::c_uchar,
        message_len: size_t,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BN_get_rfc2409_prime_768(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc2409_prime_1024(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_1536(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_2048(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_3072(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_4096(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_6144(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_8192(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bntest_rand(
        rnd: *mut BIGNUM,
        bits: crate::cty::c_int,
        top: crate::cty::c_int,
        bottom: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
pub type TpmCryptSetSymKeyCall_t = ::core::option::Option<
    unsafe extern "C" fn(in_: *const BYTE, out: *mut BYTE, keySchedule: *mut crate::cty::c_void),
>;
extern "C" {
    pub fn ERR_load_BIO_strings() -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_addr_st {
    _unused: [u8; 0],
}
pub type BIO_ADDR = bio_addr_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_addrinfo_st {
    _unused: [u8; 0],
}
pub type BIO_ADDRINFO = bio_addrinfo_st;
extern "C" {
    pub fn BIO_get_new_index() -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_set_flags(b: *mut BIO, flags: crate::cty::c_int);
}
extern "C" {
    pub fn BIO_test_flags(b: *const BIO, flags: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_clear_flags(b: *mut BIO, flags: crate::cty::c_int);
}
pub type BIO_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        oper: crate::cty::c_int,
        argp: *const crate::cty::c_char,
        argi: crate::cty::c_int,
        argl: crate::cty::c_long,
        ret: crate::cty::c_long,
    ) -> crate::cty::c_long,
>;
pub type BIO_callback_fn_ex = ::core::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        oper: crate::cty::c_int,
        argp: *const crate::cty::c_char,
        len: size_t,
        argi: crate::cty::c_int,
        argl: crate::cty::c_long,
        ret: crate::cty::c_int,
        processed: *mut size_t,
    ) -> crate::cty::c_long,
>;
extern "C" {
    pub fn BIO_get_callback(b: *const BIO) -> BIO_callback_fn;
}
extern "C" {
    pub fn BIO_set_callback(b: *mut BIO, callback: BIO_callback_fn);
}
extern "C" {
    pub fn BIO_get_callback_ex(b: *const BIO) -> BIO_callback_fn_ex;
}
extern "C" {
    pub fn BIO_set_callback_ex(b: *mut BIO, callback: BIO_callback_fn_ex);
}
extern "C" {
    pub fn BIO_get_callback_arg(b: *const BIO) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn BIO_set_callback_arg(b: *mut BIO, arg: *mut crate::cty::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_method_st {
    _unused: [u8; 0],
}
pub type BIO_METHOD = bio_method_st;
extern "C" {
    pub fn BIO_method_name(b: *const BIO) -> *const crate::cty::c_char;
}
extern "C" {
    pub fn BIO_method_type(b: *const BIO) -> crate::cty::c_int;
}
pub type BIO_info_cb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut BIO,
        arg2: crate::cty::c_int,
        arg3: crate::cty::c_int,
    ) -> crate::cty::c_int,
>;
pub type bio_info_cb = BIO_info_cb;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_BIO {
    _unused: [u8; 0],
}
pub type sk_BIO_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const BIO, b: *const *const BIO) -> crate::cty::c_int,
>;
pub type sk_BIO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut BIO)>;
pub type sk_BIO_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const BIO) -> *mut BIO>;
pub type asn1_ps_func = ::core::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        pbuf: *mut *mut crate::cty::c_uchar,
        plen: *mut crate::cty::c_int,
        parg: *mut crate::cty::c_void,
    ) -> crate::cty::c_int,
>;
extern "C" {
    pub fn BIO_ctrl_pending(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_wpending(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_get_write_guarantee(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_get_read_request(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_reset_read_request(b: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_set_ex_data(
        bio: *mut BIO,
        idx: crate::cty::c_int,
        data: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_get_ex_data(bio: *mut BIO, idx: crate::cty::c_int) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn BIO_number_read(bio: *mut BIO) -> u64;
}
extern "C" {
    pub fn BIO_number_written(bio: *mut BIO) -> u64;
}
extern "C" {
    pub fn BIO_asn1_set_prefix(
        b: *mut BIO,
        prefix: asn1_ps_func,
        prefix_free: asn1_ps_func,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_prefix(
        b: *mut BIO,
        pprefix: *mut asn1_ps_func,
        pprefix_free: *mut asn1_ps_func,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_asn1_set_suffix(
        b: *mut BIO,
        suffix: asn1_ps_func,
        suffix_free: asn1_ps_func,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_suffix(
        b: *mut BIO,
        psuffix: *mut asn1_ps_func,
        psuffix_free: *mut asn1_ps_func,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_s_file() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_file(
        filename: *const crate::cty::c_char,
        mode: *const crate::cty::c_char,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fp(stream: *mut FILE, close_flag: crate::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new(type_: *const BIO_METHOD) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free(a: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_set_data(a: *mut BIO, ptr: *mut crate::cty::c_void);
}
extern "C" {
    pub fn BIO_get_data(a: *mut BIO) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn BIO_set_init(a: *mut BIO, init: crate::cty::c_int);
}
extern "C" {
    pub fn BIO_get_init(a: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_set_shutdown(a: *mut BIO, shut: crate::cty::c_int);
}
extern "C" {
    pub fn BIO_get_shutdown(a: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_vfree(a: *mut BIO);
}
extern "C" {
    pub fn BIO_up_ref(a: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_read(
        b: *mut BIO,
        data: *mut crate::cty::c_void,
        dlen: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_read_ex(
        b: *mut BIO,
        data: *mut crate::cty::c_void,
        dlen: size_t,
        readbytes: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_gets(
        bp: *mut BIO,
        buf: *mut crate::cty::c_char,
        size: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_write(
        b: *mut BIO,
        data: *const crate::cty::c_void,
        dlen: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_write_ex(
        b: *mut BIO,
        data: *const crate::cty::c_void,
        dlen: size_t,
        written: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_puts(bp: *mut BIO, buf: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_indent(
        b: *mut BIO,
        indent: crate::cty::c_int,
        max: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ctrl(
        bp: *mut BIO,
        cmd: crate::cty::c_int,
        larg: crate::cty::c_long,
        parg: *mut crate::cty::c_void,
    ) -> crate::cty::c_long;
}
extern "C" {
    pub fn BIO_callback_ctrl(
        b: *mut BIO,
        cmd: crate::cty::c_int,
        fp: BIO_info_cb,
    ) -> crate::cty::c_long;
}
extern "C" {
    pub fn BIO_ptr_ctrl(
        bp: *mut BIO,
        cmd: crate::cty::c_int,
        larg: crate::cty::c_long,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn BIO_int_ctrl(
        bp: *mut BIO,
        cmd: crate::cty::c_int,
        larg: crate::cty::c_long,
        iarg: crate::cty::c_int,
    ) -> crate::cty::c_long;
}
extern "C" {
    pub fn BIO_push(b: *mut BIO, append: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_pop(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free_all(a: *mut BIO);
}
extern "C" {
    pub fn BIO_find_type(b: *mut BIO, bio_type: crate::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_next(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set_next(b: *mut BIO, next: *mut BIO);
}
extern "C" {
    pub fn BIO_get_retry_BIO(bio: *mut BIO, reason: *mut crate::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_get_retry_reason(bio: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_set_retry_reason(bio: *mut BIO, reason: crate::cty::c_int);
}
extern "C" {
    pub fn BIO_dup_chain(in_: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_nread0(bio: *mut BIO, buf: *mut *mut crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_nread(
        bio: *mut BIO,
        buf: *mut *mut crate::cty::c_char,
        num: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_nwrite0(bio: *mut BIO, buf: *mut *mut crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_nwrite(
        bio: *mut BIO,
        buf: *mut *mut crate::cty::c_char,
        num: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_debug_callback(
        bio: *mut BIO,
        cmd: crate::cty::c_int,
        argp: *const crate::cty::c_char,
        argi: crate::cty::c_int,
        argl: crate::cty::c_long,
        ret: crate::cty::c_long,
    ) -> crate::cty::c_long;
}
extern "C" {
    pub fn BIO_s_mem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_secmem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_mem_buf(buf: *const crate::cty::c_void, len: crate::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_s_socket() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_connect() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_accept() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_fd() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_log() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_bio() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_null() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_null() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_buffer() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_linebuffer() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_nbio_test() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_datagram() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_dgram_non_fatal_error(error: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_new_dgram(fd: crate::cty::c_int, close_flag: crate::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_sock_should_retry(i: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_sock_non_fatal_error(error: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_fd_should_retry(i: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_fd_non_fatal_error(error: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_cb(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                data: *const crate::cty::c_void,
                len: size_t,
                u: *mut crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
        u: *mut crate::cty::c_void,
        s: *const crate::cty::c_char,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_cb(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                data: *const crate::cty::c_void,
                len: size_t,
                u: *mut crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
        u: *mut crate::cty::c_void,
        s: *const crate::cty::c_char,
        len: crate::cty::c_int,
        indent: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_dump(
        b: *mut BIO,
        bytes: *const crate::cty::c_char,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_indent(
        b: *mut BIO,
        bytes: *const crate::cty::c_char,
        len: crate::cty::c_int,
        indent: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_fp(
        fp: *mut FILE,
        s: *const crate::cty::c_char,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_fp(
        fp: *mut FILE,
        s: *const crate::cty::c_char,
        len: crate::cty::c_int,
        indent: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_hex_string(
        out: *mut BIO,
        indent: crate::cty::c_int,
        width: crate::cty::c_int,
        data: *mut crate::cty::c_uchar,
        datalen: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_new() -> *mut BIO_ADDR;
}
extern "C" {
    pub fn BIO_ADDR_rawmake(
        ap: *mut BIO_ADDR,
        family: crate::cty::c_int,
        where_: *const crate::cty::c_void,
        wherelen: size_t,
        port: crate::cty::c_ushort,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_free(arg1: *mut BIO_ADDR);
}
extern "C" {
    pub fn BIO_ADDR_clear(ap: *mut BIO_ADDR);
}
extern "C" {
    pub fn BIO_ADDR_family(ap: *const BIO_ADDR) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_rawaddress(
        ap: *const BIO_ADDR,
        p: *mut crate::cty::c_void,
        l: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_rawport(ap: *const BIO_ADDR) -> crate::cty::c_ushort;
}
extern "C" {
    pub fn BIO_ADDR_hostname_string(
        ap: *const BIO_ADDR,
        numeric: crate::cty::c_int,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn BIO_ADDR_service_string(
        ap: *const BIO_ADDR,
        numeric: crate::cty::c_int,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn BIO_ADDR_path_string(ap: *const BIO_ADDR) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn BIO_ADDRINFO_next(bai: *const BIO_ADDRINFO) -> *const BIO_ADDRINFO;
}
extern "C" {
    pub fn BIO_ADDRINFO_family(bai: *const BIO_ADDRINFO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_socktype(bai: *const BIO_ADDRINFO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_protocol(bai: *const BIO_ADDRINFO) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_address(bai: *const BIO_ADDRINFO) -> *const BIO_ADDR;
}
extern "C" {
    pub fn BIO_ADDRINFO_free(bai: *mut BIO_ADDRINFO);
}
pub const BIO_hostserv_priorities_BIO_PARSE_PRIO_HOST: BIO_hostserv_priorities = 0;
pub const BIO_hostserv_priorities_BIO_PARSE_PRIO_SERV: BIO_hostserv_priorities = 1;
pub type BIO_hostserv_priorities = crate::cty::c_uint;
extern "C" {
    pub fn BIO_parse_hostserv(
        hostserv: *const crate::cty::c_char,
        host: *mut *mut crate::cty::c_char,
        service: *mut *mut crate::cty::c_char,
        hostserv_prio: BIO_hostserv_priorities,
    ) -> crate::cty::c_int;
}
pub const BIO_lookup_type_BIO_LOOKUP_CLIENT: BIO_lookup_type = 0;
pub const BIO_lookup_type_BIO_LOOKUP_SERVER: BIO_lookup_type = 1;
pub type BIO_lookup_type = crate::cty::c_uint;
extern "C" {
    pub fn BIO_lookup(
        host: *const crate::cty::c_char,
        service: *const crate::cty::c_char,
        lookup_type: BIO_lookup_type,
        family: crate::cty::c_int,
        socktype: crate::cty::c_int,
        res: *mut *mut BIO_ADDRINFO,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_lookup_ex(
        host: *const crate::cty::c_char,
        service: *const crate::cty::c_char,
        lookup_type: crate::cty::c_int,
        family: crate::cty::c_int,
        socktype: crate::cty::c_int,
        protocol: crate::cty::c_int,
        res: *mut *mut BIO_ADDRINFO,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_sock_error(sock: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_socket_ioctl(
        fd: crate::cty::c_int,
        type_: crate::cty::c_long,
        arg: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_socket_nbio(fd: crate::cty::c_int, mode: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_sock_init() -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_set_tcp_ndelay(
        sock: crate::cty::c_int,
        turn_on: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn BIO_gethostbyname(name: *const crate::cty::c_char) -> *mut hostent;
}
extern "C" {
    pub fn BIO_get_port(
        str_: *const crate::cty::c_char,
        port_ptr: *mut crate::cty::c_ushort,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_get_host_ip(
        str_: *const crate::cty::c_char,
        ip: *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_get_accept_socket(
        host_port: *mut crate::cty::c_char,
        mode: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_accept(
        sock: crate::cty::c_int,
        ip_port: *mut *mut crate::cty::c_char,
    ) -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BIO_sock_info_u {
    pub addr: *mut BIO_ADDR,
}
#[test]
fn bindgen_test_layout_BIO_sock_info_u() {
    assert_eq!(
        ::core::mem::size_of::<BIO_sock_info_u>(),
        8usize,
        concat!("Size of: ", stringify!(BIO_sock_info_u))
    );
    assert_eq!(
        ::core::mem::align_of::<BIO_sock_info_u>(),
        8usize,
        concat!("Alignment of ", stringify!(BIO_sock_info_u))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BIO_sock_info_u>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BIO_sock_info_u),
            "::",
            stringify!(addr)
        )
    );
}
pub const BIO_sock_info_type_BIO_SOCK_INFO_ADDRESS: BIO_sock_info_type = 0;
pub type BIO_sock_info_type = crate::cty::c_uint;
extern "C" {
    pub fn BIO_sock_info(
        sock: crate::cty::c_int,
        type_: BIO_sock_info_type,
        info: *mut BIO_sock_info_u,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_socket(
        domain: crate::cty::c_int,
        socktype: crate::cty::c_int,
        protocol: crate::cty::c_int,
        options: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_connect(
        sock: crate::cty::c_int,
        addr: *const BIO_ADDR,
        options: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_bind(
        sock: crate::cty::c_int,
        addr: *const BIO_ADDR,
        options: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_listen(
        sock: crate::cty::c_int,
        addr: *const BIO_ADDR,
        options: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_accept_ex(
        accept_sock: crate::cty::c_int,
        addr: *mut BIO_ADDR,
        options: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_closesocket(sock: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_new_socket(sock: crate::cty::c_int, close_flag: crate::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_connect(host_port: *const crate::cty::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_accept(host_port: *const crate::cty::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fd(fd: crate::cty::c_int, close_flag: crate::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_bio_pair(
        bio1: *mut *mut BIO,
        writebuf1: size_t,
        bio2: *mut *mut BIO,
        writebuf2: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_copy_next_retry(b: *mut BIO);
}
extern "C" {
    pub fn BIO_printf(bio: *mut BIO, format: *const crate::cty::c_char, ...) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_vprintf(
        bio: *mut BIO,
        format: *const crate::cty::c_char,
        args: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_snprintf(
        buf: *mut crate::cty::c_char,
        n: size_t,
        format: *const crate::cty::c_char,
        ...
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_vsnprintf(
        buf: *mut crate::cty::c_char,
        n: size_t,
        format: *const crate::cty::c_char,
        args: *mut __va_list_tag,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_new(
        type_: crate::cty::c_int,
        name: *const crate::cty::c_char,
    ) -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_meth_free(biom: *mut BIO_METHOD);
}
extern "C" {
    pub fn BIO_meth_get_write(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *const crate::cty::c_char,
            arg2: crate::cty::c_int,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_get_write_ex(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *const crate::cty::c_char,
            arg2: size_t,
            arg3: *mut size_t,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_write(
        biom: *mut BIO_METHOD,
        write: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const crate::cty::c_char,
                arg3: crate::cty::c_int,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_set_write_ex(
        biom: *mut BIO_METHOD,
        bwrite: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const crate::cty::c_char,
                arg3: size_t,
                arg4: *mut size_t,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_read(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut crate::cty::c_char,
            arg2: crate::cty::c_int,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_get_read_ex(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut crate::cty::c_char,
            arg2: size_t,
            arg3: *mut size_t,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_read(
        biom: *mut BIO_METHOD,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut crate::cty::c_char,
                arg3: crate::cty::c_int,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_set_read_ex(
        biom: *mut BIO_METHOD,
        bread: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut crate::cty::c_char,
                arg3: size_t,
                arg4: *mut size_t,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_puts(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(biom: *mut BIO, arg1: *const crate::cty::c_char) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_puts(
        biom: *mut BIO_METHOD,
        puts: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const crate::cty::c_char,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_gets(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut crate::cty::c_char,
            arg2: crate::cty::c_int,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_gets(
        biom: *mut BIO_METHOD,
        gets: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut crate::cty::c_char,
                arg3: crate::cty::c_int,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_ctrl(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: crate::cty::c_int,
            arg2: crate::cty::c_long,
            arg3: *mut crate::cty::c_void,
        ) -> crate::cty::c_long,
    >;
}
extern "C" {
    pub fn BIO_meth_set_ctrl(
        biom: *mut BIO_METHOD,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: crate::cty::c_int,
                arg3: crate::cty::c_long,
                arg4: *mut crate::cty::c_void,
            ) -> crate::cty::c_long,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_create(
        bion: *const BIO_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(bion: *mut BIO) -> crate::cty::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_create(
        biom: *mut BIO_METHOD,
        create: ::core::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> crate::cty::c_int>,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_destroy(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(biom: *mut BIO) -> crate::cty::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_destroy(
        biom: *mut BIO_METHOD,
        destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> crate::cty::c_int>,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_callback_ctrl(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: crate::cty::c_int,
            arg2: BIO_info_cb,
        ) -> crate::cty::c_long,
    >;
}
extern "C" {
    pub fn BIO_meth_set_callback_ctrl(
        biom: *mut BIO_METHOD,
        callback_ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: crate::cty::c_int,
                arg3: BIO_info_cb,
            ) -> crate::cty::c_long,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ERR_load_EVP_strings() -> crate::cty::c_int;
}
extern "C" {
    pub fn ERR_load_ASN1_strings() -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ALGOR {
    _unused: [u8; 0],
}
pub type sk_X509_ALGOR_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_ALGOR,
        b: *const *const X509_ALGOR,
    ) -> crate::cty::c_int,
>;
pub type sk_X509_ALGOR_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_ALGOR)>;
pub type sk_X509_ALGOR_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_ALGOR) -> *mut X509_ALGOR>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_st {
    pub length: crate::cty::c_int,
    pub type_: crate::cty::c_int,
    pub data: *mut crate::cty::c_uchar,
    pub flags: crate::cty::c_long,
}
#[test]
fn bindgen_test_layout_asn1_string_st() {
    assert_eq!(
        ::core::mem::size_of::<asn1_string_st>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_string_st))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_string_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_st>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_st>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ENCODING_st {
    pub enc: *mut crate::cty::c_uchar,
    pub len: crate::cty::c_long,
    pub modified: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_ASN1_ENCODING_st() {
    assert_eq!(
        ::core::mem::size_of::<ASN1_ENCODING_st>(),
        24usize,
        concat!("Size of: ", stringify!(ASN1_ENCODING_st))
    );
    assert_eq!(
        ::core::mem::align_of::<ASN1_ENCODING_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ENCODING_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ASN1_ENCODING_st>())).enc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ASN1_ENCODING_st>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ASN1_ENCODING_st>())).modified as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(modified)
        )
    );
}
pub type ASN1_ENCODING = ASN1_ENCODING_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_table_st {
    pub nid: crate::cty::c_int,
    pub minsize: crate::cty::c_long,
    pub maxsize: crate::cty::c_long,
    pub mask: crate::cty::c_ulong,
    pub flags: crate::cty::c_ulong,
}
#[test]
fn bindgen_test_layout_asn1_string_table_st() {
    assert_eq!(
        ::core::mem::size_of::<asn1_string_table_st>(),
        40usize,
        concat!("Size of: ", stringify!(asn1_string_table_st))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_string_table_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_table_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_table_st>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_table_st>())).minsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(minsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_table_st>())).maxsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_table_st>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_string_table_st>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type ASN1_STRING_TABLE = asn1_string_table_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_STRING_TABLE {
    _unused: [u8; 0],
}
pub type sk_ASN1_STRING_TABLE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_STRING_TABLE,
        b: *const *const ASN1_STRING_TABLE,
    ) -> crate::cty::c_int,
>;
pub type sk_ASN1_STRING_TABLE_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_STRING_TABLE)>;
pub type sk_ASN1_STRING_TABLE_copyfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const ASN1_STRING_TABLE) -> *mut ASN1_STRING_TABLE,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TEMPLATE_st {
    _unused: [u8; 0],
}
pub type ASN1_TEMPLATE = ASN1_TEMPLATE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TLC_st {
    _unused: [u8; 0],
}
pub type ASN1_TLC = ASN1_TLC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_VALUE_st {
    _unused: [u8; 0],
}
pub type ASN1_VALUE = ASN1_VALUE_st;
pub type d2i_of_void = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut *mut crate::cty::c_void,
        arg2: *mut *const crate::cty::c_uchar,
        arg3: crate::cty::c_long,
    ) -> *mut crate::cty::c_void,
>;
pub type i2d_of_void = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut crate::cty::c_void,
        arg2: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int,
>;
pub type ASN1_ITEM_EXP = ASN1_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_INTEGER {
    _unused: [u8; 0],
}
pub type sk_ASN1_INTEGER_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_INTEGER,
        b: *const *const ASN1_INTEGER,
    ) -> crate::cty::c_int,
>;
pub type sk_ASN1_INTEGER_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_INTEGER)>;
pub type sk_ASN1_INTEGER_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_INTEGER) -> *mut ASN1_INTEGER>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_GENERALSTRING {
    _unused: [u8; 0],
}
pub type sk_ASN1_GENERALSTRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_GENERALSTRING,
        b: *const *const ASN1_GENERALSTRING,
    ) -> crate::cty::c_int,
>;
pub type sk_ASN1_GENERALSTRING_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_GENERALSTRING)>;
pub type sk_ASN1_GENERALSTRING_copyfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const ASN1_GENERALSTRING) -> *mut ASN1_GENERALSTRING,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_UTF8STRING {
    _unused: [u8; 0],
}
pub type sk_ASN1_UTF8STRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_UTF8STRING,
        b: *const *const ASN1_UTF8STRING,
    ) -> crate::cty::c_int,
>;
pub type sk_ASN1_UTF8STRING_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_UTF8STRING)>;
pub type sk_ASN1_UTF8STRING_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_UTF8STRING) -> *mut ASN1_UTF8STRING>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_type_st {
    pub type_: crate::cty::c_int,
    pub value: asn1_type_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union asn1_type_st__bindgen_ty_1 {
    pub ptr: *mut crate::cty::c_char,
    pub boolean: ASN1_BOOLEAN,
    pub asn1_string: *mut ASN1_STRING,
    pub object: *mut ASN1_OBJECT,
    pub integer: *mut ASN1_INTEGER,
    pub enumerated: *mut ASN1_ENUMERATED,
    pub bit_string: *mut ASN1_BIT_STRING,
    pub octet_string: *mut ASN1_OCTET_STRING,
    pub printablestring: *mut ASN1_PRINTABLESTRING,
    pub t61string: *mut ASN1_T61STRING,
    pub ia5string: *mut ASN1_IA5STRING,
    pub generalstring: *mut ASN1_GENERALSTRING,
    pub bmpstring: *mut ASN1_BMPSTRING,
    pub universalstring: *mut ASN1_UNIVERSALSTRING,
    pub utctime: *mut ASN1_UTCTIME,
    pub generalizedtime: *mut ASN1_GENERALIZEDTIME,
    pub visiblestring: *mut ASN1_VISIBLESTRING,
    pub utf8string: *mut ASN1_UTF8STRING,
    pub set: *mut ASN1_STRING,
    pub sequence: *mut ASN1_STRING,
    pub asn1_value: *mut ASN1_VALUE,
}
#[test]
fn bindgen_test_layout_asn1_type_st__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).boolean as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).integer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).enumerated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(enumerated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).bit_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bit_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).octet_string as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(octet_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).printablestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(printablestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).t61string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(t61string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).ia5string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ia5string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).bmpstring as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bmpstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).universalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(universalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).utctime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utctime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalizedtime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalizedtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).visiblestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(visiblestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).utf8string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utf8string)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_value)
        )
    );
}
#[test]
fn bindgen_test_layout_asn1_type_st() {
    assert_eq!(
        ::core::mem::size_of::<asn1_type_st>(),
        16usize,
        concat!("Size of: ", stringify!(asn1_type_st))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_type_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_type_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_type_st>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(value)
        )
    );
}
pub type ASN1_TYPE = asn1_type_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_TYPE {
    _unused: [u8; 0],
}
pub type sk_ASN1_TYPE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_TYPE,
        b: *const *const ASN1_TYPE,
    ) -> crate::cty::c_int,
>;
pub type sk_ASN1_TYPE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_TYPE)>;
pub type sk_ASN1_TYPE_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_TYPE) -> *mut ASN1_TYPE>;
pub type ASN1_SEQUENCE_ANY = stack_st_ASN1_TYPE;
extern "C" {
    pub fn d2i_ASN1_SEQUENCE_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SEQUENCE_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_SEQUENCE_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_ASN1_SET_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SET_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_SET_ANY_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BIT_STRING_BITNAME_st {
    pub bitnum: crate::cty::c_int,
    pub lname: *const crate::cty::c_char,
    pub sname: *const crate::cty::c_char,
}
#[test]
fn bindgen_test_layout_BIT_STRING_BITNAME_st() {
    assert_eq!(
        ::core::mem::size_of::<BIT_STRING_BITNAME_st>(),
        24usize,
        concat!("Size of: ", stringify!(BIT_STRING_BITNAME_st))
    );
    assert_eq!(
        ::core::mem::align_of::<BIT_STRING_BITNAME_st>(),
        8usize,
        concat!("Alignment of ", stringify!(BIT_STRING_BITNAME_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BIT_STRING_BITNAME_st>())).bitnum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(bitnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BIT_STRING_BITNAME_st>())).lname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(lname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BIT_STRING_BITNAME_st>())).sname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(sname)
        )
    );
}
pub type BIT_STRING_BITNAME = BIT_STRING_BITNAME_st;
extern "C" {
    pub fn ASN1_TYPE_new() -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_free(a: *mut ASN1_TYPE);
}
extern "C" {
    pub fn d2i_ASN1_TYPE(
        a: *mut *mut ASN1_TYPE,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn i2d_ASN1_TYPE(
        a: *mut ASN1_TYPE,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TYPE_get(a: *const ASN1_TYPE) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set(
        a: *mut ASN1_TYPE,
        type_: crate::cty::c_int,
        value: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn ASN1_TYPE_set1(
        a: *mut ASN1_TYPE,
        type_: crate::cty::c_int,
        value: *const crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_cmp(a: *const ASN1_TYPE, b: *const ASN1_TYPE) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_pack_sequence(
        it: *const ASN1_ITEM,
        s: *mut crate::cty::c_void,
        t: *mut *mut ASN1_TYPE,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_unpack_sequence(
        it: *const ASN1_ITEM,
        t: *const ASN1_TYPE,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_OBJECT_new() -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_OBJECT_free(a: *mut ASN1_OBJECT);
}
extern "C" {
    pub fn i2d_ASN1_OBJECT(
        a: *const ASN1_OBJECT,
        pp: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn d2i_ASN1_OBJECT(
        a: *mut *mut ASN1_OBJECT,
        pp: *mut *const crate::cty::c_uchar,
        length: crate::cty::c_long,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub static ASN1_OBJECT_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_OBJECT {
    _unused: [u8; 0],
}
pub type sk_ASN1_OBJECT_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_OBJECT,
        b: *const *const ASN1_OBJECT,
    ) -> crate::cty::c_int,
>;
pub type sk_ASN1_OBJECT_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_OBJECT)>;
pub type sk_ASN1_OBJECT_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_OBJECT) -> *mut ASN1_OBJECT>;
extern "C" {
    pub fn ASN1_STRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_clear_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_copy(dst: *mut ASN1_STRING, str_: *const ASN1_STRING) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_dup(a: *const ASN1_STRING) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_type_new(type_: crate::cty::c_int) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_cmp(a: *const ASN1_STRING, b: *const ASN1_STRING) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set(
        str_: *mut ASN1_STRING,
        data: *const crate::cty::c_void,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set0(
        str_: *mut ASN1_STRING,
        data: *mut crate::cty::c_void,
        len: crate::cty::c_int,
    );
}
extern "C" {
    pub fn ASN1_STRING_length(x: *const ASN1_STRING) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_length_set(x: *mut ASN1_STRING, n: crate::cty::c_int);
}
extern "C" {
    pub fn ASN1_STRING_type(x: *const ASN1_STRING) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_data(x: *mut ASN1_STRING) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn ASN1_STRING_get0_data(x: *const ASN1_STRING) -> *const crate::cty::c_uchar;
}
extern "C" {
    pub fn ASN1_BIT_STRING_new() -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn ASN1_BIT_STRING_free(a: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub fn d2i_ASN1_BIT_STRING(
        a: *mut *mut ASN1_BIT_STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn i2d_ASN1_BIT_STRING(
        a: *mut ASN1_BIT_STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_BIT_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set(
        a: *mut ASN1_BIT_STRING,
        d: *mut crate::cty::c_uchar,
        length: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_bit(
        a: *mut ASN1_BIT_STRING,
        n: crate::cty::c_int,
        value: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_get_bit(
        a: *const ASN1_BIT_STRING,
        n: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_check(
        a: *const ASN1_BIT_STRING,
        flags: *const crate::cty::c_uchar,
        flags_len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_name_print(
        out: *mut BIO,
        bs: *mut ASN1_BIT_STRING,
        tbl: *mut BIT_STRING_BITNAME,
        indent: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_num_asc(
        name: *const crate::cty::c_char,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_asc(
        bs: *mut ASN1_BIT_STRING,
        name: *const crate::cty::c_char,
        value: crate::cty::c_int,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_new() -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_free(a: *mut ASN1_INTEGER);
}
extern "C" {
    pub fn d2i_ASN1_INTEGER(
        a: *mut *mut ASN1_INTEGER,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2d_ASN1_INTEGER(
        a: *mut ASN1_INTEGER,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_INTEGER_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_ASN1_UINTEGER(
        a: *mut *mut ASN1_INTEGER,
        pp: *mut *const crate::cty::c_uchar,
        length: crate::cty::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_dup(x: *const ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_cmp(x: *const ASN1_INTEGER, y: *const ASN1_INTEGER) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_new() -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_free(a: *mut ASN1_ENUMERATED);
}
extern "C" {
    pub fn d2i_ASN1_ENUMERATED(
        a: *mut *mut ASN1_ENUMERATED,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn i2d_ASN1_ENUMERATED(
        a: *mut ASN1_ENUMERATED,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_ENUMERATED_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_check(a: *const ASN1_UTCTIME) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_set(s: *mut ASN1_UTCTIME, t: time_t) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_adj(
        s: *mut ASN1_UTCTIME,
        t: time_t,
        offset_day: crate::cty::c_int,
        offset_sec: crate::cty::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_set_string(
        s: *mut ASN1_UTCTIME,
        str_: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_cmp_time_t(s: *const ASN1_UTCTIME, t: time_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_check(a: *const ASN1_GENERALIZEDTIME) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_adj(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
        offset_day: crate::cty::c_int,
        offset_sec: crate::cty::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set_string(
        s: *mut ASN1_GENERALIZEDTIME,
        str_: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_diff(
        pday: *mut crate::cty::c_int,
        psec: *mut crate::cty::c_int,
        from: *const ASN1_TIME,
        to: *const ASN1_TIME,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_new() -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_free(a: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn d2i_ASN1_OCTET_STRING(
        a: *mut *mut ASN1_OCTET_STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn i2d_ASN1_OCTET_STRING(
        a: *mut ASN1_OCTET_STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_OCTET_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_dup(a: *const ASN1_OCTET_STRING) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_cmp(
        a: *const ASN1_OCTET_STRING,
        b: *const ASN1_OCTET_STRING,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_set(
        str_: *mut ASN1_OCTET_STRING,
        data: *const crate::cty::c_uchar,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_new() -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_free(a: *mut ASN1_VISIBLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_VISIBLESTRING(
        a: *mut *mut ASN1_VISIBLESTRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_VISIBLESTRING(
        a: *mut ASN1_VISIBLESTRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_VISIBLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_new() -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_free(a: *mut ASN1_UNIVERSALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_UNIVERSALSTRING(
        a: *mut *mut ASN1_UNIVERSALSTRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_UNIVERSALSTRING(
        a: *mut ASN1_UNIVERSALSTRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_UNIVERSALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTF8STRING_new() -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn ASN1_UTF8STRING_free(a: *mut ASN1_UTF8STRING);
}
extern "C" {
    pub fn d2i_ASN1_UTF8STRING(
        a: *mut *mut ASN1_UTF8STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn i2d_ASN1_UTF8STRING(
        a: *mut ASN1_UTF8STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_UTF8STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_NULL_new() -> *mut ASN1_NULL;
}
extern "C" {
    pub fn ASN1_NULL_free(a: *mut ASN1_NULL);
}
extern "C" {
    pub fn d2i_ASN1_NULL(
        a: *mut *mut ASN1_NULL,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_NULL;
}
extern "C" {
    pub fn i2d_ASN1_NULL(
        a: *mut ASN1_NULL,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_NULL_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BMPSTRING_new() -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn ASN1_BMPSTRING_free(a: *mut ASN1_BMPSTRING);
}
extern "C" {
    pub fn d2i_ASN1_BMPSTRING(
        a: *mut *mut ASN1_BMPSTRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn i2d_ASN1_BMPSTRING(
        a: *mut ASN1_BMPSTRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_BMPSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn UTF8_getc(
        str_: *const crate::cty::c_uchar,
        len: crate::cty::c_int,
        val: *mut crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn UTF8_putc(
        str_: *mut crate::cty::c_uchar,
        len: crate::cty::c_int,
        value: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_PRINTABLE_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLE_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLE(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLE(
        a: *mut ASN1_STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_PRINTABLE_it: ASN1_ITEM;
}
extern "C" {
    pub fn DIRECTORYSTRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DIRECTORYSTRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DIRECTORYSTRING(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DIRECTORYSTRING(
        a: *mut ASN1_STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static DIRECTORYSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn DISPLAYTEXT_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DISPLAYTEXT_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DISPLAYTEXT(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DISPLAYTEXT(
        a: *mut ASN1_STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static DISPLAYTEXT_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_new() -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_free(a: *mut ASN1_PRINTABLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLESTRING(
        a: *mut *mut ASN1_PRINTABLESTRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLESTRING(
        a: *mut ASN1_PRINTABLESTRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_PRINTABLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_T61STRING_new() -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn ASN1_T61STRING_free(a: *mut ASN1_T61STRING);
}
extern "C" {
    pub fn d2i_ASN1_T61STRING(
        a: *mut *mut ASN1_T61STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn i2d_ASN1_T61STRING(
        a: *mut ASN1_T61STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_T61STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_IA5STRING_new() -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn ASN1_IA5STRING_free(a: *mut ASN1_IA5STRING);
}
extern "C" {
    pub fn d2i_ASN1_IA5STRING(
        a: *mut *mut ASN1_IA5STRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn i2d_ASN1_IA5STRING(
        a: *mut ASN1_IA5STRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_IA5STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_new() -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_free(a: *mut ASN1_GENERALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_GENERALSTRING(
        a: *mut *mut ASN1_GENERALSTRING,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_GENERALSTRING(
        a: *mut ASN1_GENERALSTRING,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_GENERALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_new() -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_free(a: *mut ASN1_UTCTIME);
}
extern "C" {
    pub fn d2i_ASN1_UTCTIME(
        a: *mut *mut ASN1_UTCTIME,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn i2d_ASN1_UTCTIME(
        a: *mut ASN1_UTCTIME,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_UTCTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_new() -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_free(a: *mut ASN1_GENERALIZEDTIME);
}
extern "C" {
    pub fn d2i_ASN1_GENERALIZEDTIME(
        a: *mut *mut ASN1_GENERALIZEDTIME,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn i2d_ASN1_GENERALIZEDTIME(
        a: *mut ASN1_GENERALIZEDTIME,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_GENERALIZEDTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_new() -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_free(a: *mut ASN1_TIME);
}
extern "C" {
    pub fn d2i_ASN1_TIME(
        a: *mut *mut ASN1_TIME,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn i2d_ASN1_TIME(
        a: *mut ASN1_TIME,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub static ASN1_TIME_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_OCTET_STRING_NDEF_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_set(s: *mut ASN1_TIME, t: time_t) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_adj(
        s: *mut ASN1_TIME,
        t: time_t,
        offset_day: crate::cty::c_int,
        offset_sec: crate::cty::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_check(t: *const ASN1_TIME) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_generalizedtime(
        t: *const ASN1_TIME,
        out: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_TIME_set_string(
        s: *mut ASN1_TIME,
        str_: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_set_string_X509(
        s: *mut ASN1_TIME,
        str_: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_tm(s: *const ASN1_TIME, tm: *mut tm) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_normalize(s: *mut ASN1_TIME) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_cmp_time_t(s: *const ASN1_TIME, t: time_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_compare(a: *const ASN1_TIME, b: *const ASN1_TIME) -> crate::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_INTEGER(bp: *mut BIO, a: *const ASN1_INTEGER) -> crate::cty::c_int;
}
extern "C" {
    pub fn a2i_ASN1_INTEGER(
        bp: *mut BIO,
        bs: *mut ASN1_INTEGER,
        buf: *mut crate::cty::c_char,
        size: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_ENUMERATED(bp: *mut BIO, a: *const ASN1_ENUMERATED) -> crate::cty::c_int;
}
extern "C" {
    pub fn a2i_ASN1_ENUMERATED(
        bp: *mut BIO,
        bs: *mut ASN1_ENUMERATED,
        buf: *mut crate::cty::c_char,
        size: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_OBJECT(bp: *mut BIO, a: *const ASN1_OBJECT) -> crate::cty::c_int;
}
extern "C" {
    pub fn a2i_ASN1_STRING(
        bp: *mut BIO,
        bs: *mut ASN1_STRING,
        buf: *mut crate::cty::c_char,
        size: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_STRING(
        bp: *mut BIO,
        a: *const ASN1_STRING,
        type_: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn i2t_ASN1_OBJECT(
        buf: *mut crate::cty::c_char,
        buf_len: crate::cty::c_int,
        a: *const ASN1_OBJECT,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn a2d_ASN1_OBJECT(
        out: *mut crate::cty::c_uchar,
        olen: crate::cty::c_int,
        buf: *const crate::cty::c_char,
        num: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_OBJECT_create(
        nid: crate::cty::c_int,
        data: *mut crate::cty::c_uchar,
        len: crate::cty::c_int,
        sn: *const crate::cty::c_char,
        ln: *const crate::cty::c_char,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_INTEGER_get_int64(pr: *mut i64, a: *const ASN1_INTEGER) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_int64(a: *mut ASN1_INTEGER, r: i64) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get_uint64(pr: *mut u64, a: *const ASN1_INTEGER) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_uint64(a: *mut ASN1_INTEGER, r: u64) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set(a: *mut ASN1_INTEGER, v: crate::cty::c_long) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get(a: *const ASN1_INTEGER) -> crate::cty::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_INTEGER(bn: *const BIGNUM, ai: *mut ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_to_BN(ai: *const ASN1_INTEGER, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get_int64(pr: *mut i64, a: *const ASN1_ENUMERATED) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set_int64(a: *mut ASN1_ENUMERATED, r: i64) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set(a: *mut ASN1_ENUMERATED, v: crate::cty::c_long)
        -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get(a: *const ASN1_ENUMERATED) -> crate::cty::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_ENUMERATED(
        bn: *const BIGNUM,
        ai: *mut ASN1_ENUMERATED,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_to_BN(ai: *const ASN1_ENUMERATED, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_PRINTABLE_type(
        s: *const crate::cty::c_uchar,
        max: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_tag2bit(tag: crate::cty::c_int) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_get_object(
        pp: *mut *const crate::cty::c_uchar,
        plength: *mut crate::cty::c_long,
        ptag: *mut crate::cty::c_int,
        pclass: *mut crate::cty::c_int,
        omax: crate::cty::c_long,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_check_infinite_end(
        p: *mut *mut crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_const_check_infinite_end(
        p: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_put_object(
        pp: *mut *mut crate::cty::c_uchar,
        constructed: crate::cty::c_int,
        length: crate::cty::c_int,
        tag: crate::cty::c_int,
        xclass: crate::cty::c_int,
    );
}
extern "C" {
    pub fn ASN1_put_eoc(pp: *mut *mut crate::cty::c_uchar) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_object_size(
        constructed: crate::cty::c_int,
        length: crate::cty::c_int,
        tag: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_dup(
        i2d: i2d_of_void,
        d2i: d2i_of_void,
        x: *mut crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_dup(
        it: *const ASN1_ITEM,
        x: *mut crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_d2i_fp(
        xnew: ::core::option::Option<unsafe extern "C" fn() -> *mut crate::cty::c_void>,
        d2i: d2i_of_void,
        in_: *mut FILE,
        x: *mut *mut crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_fp(
        it: *const ASN1_ITEM,
        in_: *mut FILE,
        x: *mut crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_i2d_fp(
        i2d: i2d_of_void,
        out: *mut FILE,
        x: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_fp(
        it: *const ASN1_ITEM,
        out: *mut FILE,
        x: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex_fp(
        fp: *mut FILE,
        str_: *const ASN1_STRING,
        flags: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_to_UTF8(
        out: *mut *mut crate::cty::c_uchar,
        in_: *const ASN1_STRING,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_d2i_bio(
        xnew: ::core::option::Option<unsafe extern "C" fn() -> *mut crate::cty::c_void>,
        d2i: d2i_of_void,
        in_: *mut BIO,
        x: *mut *mut crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_bio(
        it: *const ASN1_ITEM,
        in_: *mut BIO,
        x: *mut crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_i2d_bio(
        i2d: i2d_of_void,
        out: *mut BIO,
        x: *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_bio(
        it: *const ASN1_ITEM,
        out: *mut BIO,
        x: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_print(fp: *mut BIO, a: *const ASN1_UTCTIME) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_print(
        fp: *mut BIO,
        a: *const ASN1_GENERALIZEDTIME,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_print(fp: *mut BIO, a: *const ASN1_TIME) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print(bp: *mut BIO, v: *const ASN1_STRING) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex(
        out: *mut BIO,
        str_: *const ASN1_STRING,
        flags: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_buf_print(
        bp: *mut BIO,
        buf: *const crate::cty::c_uchar,
        buflen: size_t,
        off: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_bn_print(
        bp: *mut BIO,
        number: *const crate::cty::c_char,
        num: *const BIGNUM,
        buf: *mut crate::cty::c_uchar,
        off: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_parse(
        bp: *mut BIO,
        pp: *const crate::cty::c_uchar,
        len: crate::cty::c_long,
        indent: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_parse_dump(
        bp: *mut BIO,
        pp: *const crate::cty::c_uchar,
        len: crate::cty::c_long,
        indent: crate::cty::c_int,
        dump: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_tag2str(tag: crate::cty::c_int) -> *const crate::cty::c_char;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_to_string(s: *mut ASN1_UNIVERSALSTRING) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_octetstring(
        a: *mut ASN1_TYPE,
        data: *mut crate::cty::c_uchar,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_octetstring(
        a: *const ASN1_TYPE,
        data: *mut crate::cty::c_uchar,
        max_len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_int_octetstring(
        a: *mut ASN1_TYPE,
        num: crate::cty::c_long,
        data: *mut crate::cty::c_uchar,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_int_octetstring(
        a: *const ASN1_TYPE,
        num: *mut crate::cty::c_long,
        data: *mut crate::cty::c_uchar,
        max_len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_unpack(
        oct: *const ASN1_STRING,
        it: *const ASN1_ITEM,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_pack(
        obj: *mut crate::cty::c_void,
        it: *const ASN1_ITEM,
        oct: *mut *mut ASN1_OCTET_STRING,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask(mask: crate::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask_asc(p: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get_default_mask() -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_mbstring_copy(
        out: *mut *mut ASN1_STRING,
        in_: *const crate::cty::c_uchar,
        len: crate::cty::c_int,
        inform: crate::cty::c_int,
        mask: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_ncopy(
        out: *mut *mut ASN1_STRING,
        in_: *const crate::cty::c_uchar,
        len: crate::cty::c_int,
        inform: crate::cty::c_int,
        mask: crate::cty::c_ulong,
        minsize: crate::cty::c_long,
        maxsize: crate::cty::c_long,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set_by_NID(
        out: *mut *mut ASN1_STRING,
        in_: *const crate::cty::c_uchar,
        inlen: crate::cty::c_int,
        inform: crate::cty::c_int,
        nid: crate::cty::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_get(nid: crate::cty::c_int) -> *mut ASN1_STRING_TABLE;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_add(
        arg1: crate::cty::c_int,
        arg2: crate::cty::c_long,
        arg3: crate::cty::c_long,
        arg4: crate::cty::c_ulong,
        arg5: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_cleanup();
}
extern "C" {
    pub fn ASN1_item_new(it: *const ASN1_ITEM) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_free(val: *mut ASN1_VALUE, it: *const ASN1_ITEM);
}
extern "C" {
    pub fn ASN1_item_d2i(
        val: *mut *mut ASN1_VALUE,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_i2d(
        val: *mut ASN1_VALUE,
        out: *mut *mut crate::cty::c_uchar,
        it: *const ASN1_ITEM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_ndef_i2d(
        val: *mut ASN1_VALUE,
        out: *mut *mut crate::cty::c_uchar,
        it: *const ASN1_ITEM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_add_oid_module();
}
extern "C" {
    pub fn ASN1_add_stable_module();
}
extern "C" {
    pub fn ASN1_generate_nconf(str_: *const crate::cty::c_char, nconf: *mut CONF)
        -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_generate_v3(
        str_: *const crate::cty::c_char,
        cnf: *mut X509V3_CTX,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_str2mask(
        str_: *const crate::cty::c_char,
        pmask: *mut crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_print(
        out: *mut BIO,
        ifld: *mut ASN1_VALUE,
        indent: crate::cty::c_int,
        it: *const ASN1_ITEM,
        pctx: *const ASN1_PCTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_PCTX_new() -> *mut ASN1_PCTX;
}
extern "C" {
    pub fn ASN1_PCTX_free(p: *mut ASN1_PCTX);
}
extern "C" {
    pub fn ASN1_PCTX_get_flags(p: *const ASN1_PCTX) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_flags(p: *mut ASN1_PCTX, flags: crate::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_nm_flags(p: *const ASN1_PCTX) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_nm_flags(p: *mut ASN1_PCTX, flags: crate::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_cert_flags(p: *const ASN1_PCTX) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_cert_flags(p: *mut ASN1_PCTX, flags: crate::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_oid_flags(p: *const ASN1_PCTX) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_oid_flags(p: *mut ASN1_PCTX, flags: crate::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_str_flags(p: *const ASN1_PCTX) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_str_flags(p: *mut ASN1_PCTX, flags: crate::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_SCTX_new(
        scan_cb: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut ASN1_SCTX) -> crate::cty::c_int,
        >,
    ) -> *mut ASN1_SCTX;
}
extern "C" {
    pub fn ASN1_SCTX_free(p: *mut ASN1_SCTX);
}
extern "C" {
    pub fn ASN1_SCTX_get_item(p: *mut ASN1_SCTX) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_SCTX_get_template(p: *mut ASN1_SCTX) -> *const ASN1_TEMPLATE;
}
extern "C" {
    pub fn ASN1_SCTX_get_flags(p: *mut ASN1_SCTX) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_SCTX_set_app_data(p: *mut ASN1_SCTX, data: *mut crate::cty::c_void);
}
extern "C" {
    pub fn ASN1_SCTX_get_app_data(p: *mut ASN1_SCTX) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn BIO_f_asn1() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_NDEF(out: *mut BIO, val: *mut ASN1_VALUE, it: *const ASN1_ITEM) -> *mut BIO;
}
extern "C" {
    pub fn i2d_ASN1_bio_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: crate::cty::c_int,
        it: *const ASN1_ITEM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_ASN1_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: crate::cty::c_int,
        hdr: *const crate::cty::c_char,
        it: *const ASN1_ITEM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SMIME_write_ASN1(
        bio: *mut BIO,
        val: *mut ASN1_VALUE,
        data: *mut BIO,
        flags: crate::cty::c_int,
        ctype_nid: crate::cty::c_int,
        econt_nid: crate::cty::c_int,
        mdalgs: *mut stack_st_X509_ALGOR,
        it: *const ASN1_ITEM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SMIME_read_ASN1(
        bio: *mut BIO,
        bcont: *mut *mut BIO,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn SMIME_crlf_copy(
        in_: *mut BIO,
        out: *mut BIO,
        flags: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SMIME_text(in_: *mut BIO, out: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn ASN1_ITEM_lookup(name: *const crate::cty::c_char) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_ITEM_get(i: size_t) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ERR_load_OBJ_strings() -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obj_name_st {
    pub type_: crate::cty::c_int,
    pub alias: crate::cty::c_int,
    pub name: *const crate::cty::c_char,
    pub data: *const crate::cty::c_char,
}
#[test]
fn bindgen_test_layout_obj_name_st() {
    assert_eq!(
        ::core::mem::size_of::<obj_name_st>(),
        24usize,
        concat!("Size of: ", stringify!(obj_name_st))
    );
    assert_eq!(
        ::core::mem::align_of::<obj_name_st>(),
        8usize,
        concat!("Alignment of ", stringify!(obj_name_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<obj_name_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<obj_name_st>())).alias as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<obj_name_st>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<obj_name_st>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(data)
        )
    );
}
pub type OBJ_NAME = obj_name_st;
extern "C" {
    pub fn OBJ_NAME_init() -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_new_index(
        hash_func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const crate::cty::c_char) -> crate::cty::c_ulong,
        >,
        cmp_func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const crate::cty::c_char,
                arg2: *const crate::cty::c_char,
            ) -> crate::cty::c_int,
        >,
        free_func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const crate::cty::c_char,
                arg2: crate::cty::c_int,
                arg3: *const crate::cty::c_char,
            ),
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_get(
        name: *const crate::cty::c_char,
        type_: crate::cty::c_int,
    ) -> *const crate::cty::c_char;
}
extern "C" {
    pub fn OBJ_NAME_add(
        name: *const crate::cty::c_char,
        type_: crate::cty::c_int,
        data: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_remove(
        name: *const crate::cty::c_char,
        type_: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_cleanup(type_: crate::cty::c_int);
}
extern "C" {
    pub fn OBJ_NAME_do_all(
        type_: crate::cty::c_int,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut crate::cty::c_void),
        >,
        arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn OBJ_NAME_do_all_sorted(
        type_: crate::cty::c_int,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut crate::cty::c_void),
        >,
        arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn OBJ_dup(o: *const ASN1_OBJECT) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2obj(n: crate::cty::c_int) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2ln(n: crate::cty::c_int) -> *const crate::cty::c_char;
}
extern "C" {
    pub fn OBJ_nid2sn(n: crate::cty::c_int) -> *const crate::cty::c_char;
}
extern "C" {
    pub fn OBJ_obj2nid(o: *const ASN1_OBJECT) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_txt2obj(
        s: *const crate::cty::c_char,
        no_name: crate::cty::c_int,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_obj2txt(
        buf: *mut crate::cty::c_char,
        buf_len: crate::cty::c_int,
        a: *const ASN1_OBJECT,
        no_name: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_txt2nid(s: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_ln2nid(s: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_sn2nid(s: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_cmp(a: *const ASN1_OBJECT, b: *const ASN1_OBJECT) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_bsearch_(
        key: *const crate::cty::c_void,
        base: *const crate::cty::c_void,
        num: crate::cty::c_int,
        size: crate::cty::c_int,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const crate::cty::c_void,
                arg2: *const crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
    ) -> *const crate::cty::c_void;
}
extern "C" {
    pub fn OBJ_bsearch_ex_(
        key: *const crate::cty::c_void,
        base: *const crate::cty::c_void,
        num: crate::cty::c_int,
        size: crate::cty::c_int,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const crate::cty::c_void,
                arg2: *const crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
        flags: crate::cty::c_int,
    ) -> *const crate::cty::c_void;
}
extern "C" {
    pub fn OBJ_new_nid(num: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_add_object(obj: *const ASN1_OBJECT) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_create(
        oid: *const crate::cty::c_char,
        sn: *const crate::cty::c_char,
        ln: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_create_objects(in_: *mut BIO) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_length(obj: *const ASN1_OBJECT) -> size_t;
}
extern "C" {
    pub fn OBJ_get0_data(obj: *const ASN1_OBJECT) -> *const crate::cty::c_uchar;
}
extern "C" {
    pub fn OBJ_find_sigid_algs(
        signid: crate::cty::c_int,
        pdig_nid: *mut crate::cty::c_int,
        ppkey_nid: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_find_sigid_by_algs(
        psignid: *mut crate::cty::c_int,
        dig_nid: crate::cty::c_int,
        pkey_nid: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_add_sigid(
        signid: crate::cty::c_int,
        dig_id: crate::cty::c_int,
        pkey_id: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn OBJ_sigid_free();
}
extern "C" {
    pub fn EVP_MD_meth_new(md_type: crate::cty::c_int, pkey_type: crate::cty::c_int)
        -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_meth_dup(md: *const EVP_MD) -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_meth_free(md: *mut EVP_MD);
}
extern "C" {
    pub fn EVP_MD_meth_set_input_blocksize(
        md: *mut EVP_MD,
        blocksize: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_result_size(
        md: *mut EVP_MD,
        resultsize: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_app_datasize(
        md: *mut EVP_MD,
        datasize: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_flags(md: *mut EVP_MD, flags: crate::cty::c_ulong) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_init(
        md: *mut EVP_MD,
        init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_update(
        md: *mut EVP_MD,
        update: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                data: *const crate::cty::c_void,
                count: size_t,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_final(
        md: *mut EVP_MD,
        final_: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                md: *mut crate::cty::c_uchar,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_copy(
        md: *mut EVP_MD,
        copy: ::core::option::Option<
            unsafe extern "C" fn(to: *mut EVP_MD_CTX, from: *const EVP_MD_CTX) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_cleanup(
        md: *mut EVP_MD,
        cleanup: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_ctrl(
        md: *mut EVP_MD,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                cmd: crate::cty::c_int,
                p1: crate::cty::c_int,
                p2: *mut crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_input_blocksize(md: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_result_size(md: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_app_datasize(md: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_flags(md: *const EVP_MD) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn EVP_MD_meth_get_init(
        md: *const EVP_MD,
    ) -> ::core::option::Option<unsafe extern "C" fn(md: *mut EVP_MD_CTX) -> crate::cty::c_int>;
}
extern "C" {
    pub fn EVP_MD_meth_get_update(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: *const crate::cty::c_void,
            arg2: size_t,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_final(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: *mut crate::cty::c_uchar,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_copy(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(md: *mut EVP_MD_CTX, arg1: *const EVP_MD_CTX) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_cleanup(
        md: *const EVP_MD,
    ) -> ::core::option::Option<unsafe extern "C" fn(md: *mut EVP_MD_CTX) -> crate::cty::c_int>;
}
extern "C" {
    pub fn EVP_MD_meth_get_ctrl(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: crate::cty::c_int,
            arg2: crate::cty::c_int,
            arg3: *mut crate::cty::c_void,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_new(
        cipher_type: crate::cty::c_int,
        block_size: crate::cty::c_int,
        key_len: crate::cty::c_int,
    ) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_meth_dup(cipher: *const EVP_CIPHER) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_meth_free(cipher: *mut EVP_CIPHER);
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_iv_length(
        cipher: *mut EVP_CIPHER,
        iv_len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_flags(
        cipher: *mut EVP_CIPHER,
        flags: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_impl_ctx_size(
        cipher: *mut EVP_CIPHER,
        ctx_size: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_init(
        cipher: *mut EVP_CIPHER,
        init: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_CIPHER_CTX,
                key: *const crate::cty::c_uchar,
                iv: *const crate::cty::c_uchar,
                enc: crate::cty::c_int,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_do_cipher(
        cipher: *mut EVP_CIPHER,
        do_cipher: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_CIPHER_CTX,
                out: *mut crate::cty::c_uchar,
                in_: *const crate::cty::c_uchar,
                inl: size_t,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_cleanup(
        cipher: *mut EVP_CIPHER,
        cleanup: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut EVP_CIPHER_CTX) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_set_asn1_params(
        cipher: *mut EVP_CIPHER,
        set_asn1_parameters: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut EVP_CIPHER_CTX,
                arg2: *mut ASN1_TYPE,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_get_asn1_params(
        cipher: *mut EVP_CIPHER,
        get_asn1_parameters: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut EVP_CIPHER_CTX,
                arg2: *mut ASN1_TYPE,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_ctrl(
        cipher: *mut EVP_CIPHER,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut EVP_CIPHER_CTX,
                type_: crate::cty::c_int,
                arg: crate::cty::c_int,
                ptr: *mut crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_init(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *const crate::cty::c_uchar,
            arg2: *const crate::cty::c_uchar,
            arg3: crate::cty::c_int,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_do_cipher(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *mut crate::cty::c_uchar,
            arg2: *const crate::cty::c_uchar,
            arg3: size_t,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_cleanup(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(cipher: *mut EVP_CIPHER_CTX) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_set_asn1_params(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *mut ASN1_TYPE,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_get_asn1_params(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *mut ASN1_TYPE,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_ctrl(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: crate::cty::c_int,
            arg2: crate::cty::c_int,
            arg3: *mut crate::cty::c_void,
        ) -> crate::cty::c_int,
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM {
    pub out: *mut crate::cty::c_uchar,
    pub inp: *const crate::cty::c_uchar,
    pub len: size_t,
    pub interleave: crate::cty::c_uint,
}
#[test]
fn bindgen_test_layout_EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM() {
    assert_eq!(
        ::core::mem::size_of::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>(),
        32usize,
        concat!("Size of: ", stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM))
    );
    assert_eq!(
        ::core::mem::align_of::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).out as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).inp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(inp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).interleave as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(interleave)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_info_st {
    pub cipher: *const EVP_CIPHER,
    pub iv: [crate::cty::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_evp_cipher_info_st() {
    assert_eq!(
        ::core::mem::size_of::<evp_cipher_info_st>(),
        24usize,
        concat!("Size of: ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        ::core::mem::align_of::<evp_cipher_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<evp_cipher_info_st>())).cipher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<evp_cipher_info_st>())).iv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(iv)
        )
    );
}
pub type EVP_CIPHER_INFO = evp_cipher_info_st;
pub type EVP_PBE_KEYGEN = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const crate::cty::c_char,
        passlen: crate::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: crate::cty::c_int,
    ) -> crate::cty::c_int,
>;
extern "C" {
    pub fn EVP_MD_type(md: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_pkey_type(md: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_size(md: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_block_size(md: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_flags(md: *const EVP_MD) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn EVP_MD_CTX_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_update_fn(
        ctx: *mut EVP_MD_CTX,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            arg1: *const crate::cty::c_void,
            arg2: size_t,
        ) -> crate::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_CTX_set_update_fn(
        ctx: *mut EVP_MD_CTX,
        update: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                data: *const crate::cty::c_void,
                count: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_MD_CTX_pkey_ctx(ctx: *const EVP_MD_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_set_pkey_ctx(ctx: *mut EVP_MD_CTX, pctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_md_data(ctx: *const EVP_MD_CTX) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_nid(cipher: *const EVP_CIPHER) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_block_size(cipher: *const EVP_CIPHER) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_impl_ctx_size(cipher: *const EVP_CIPHER) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_key_length(cipher: *const EVP_CIPHER) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_iv_length(cipher: *const EVP_CIPHER) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_flags(cipher: *const EVP_CIPHER) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cipher(ctx: *const EVP_CIPHER_CTX) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_encrypting(ctx: *const EVP_CIPHER_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_nid(ctx: *const EVP_CIPHER_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_block_size(ctx: *const EVP_CIPHER_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_key_length(ctx: *const EVP_CIPHER_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_length(ctx: *const EVP_CIPHER_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv(ctx: *const EVP_CIPHER_CTX) -> *const crate::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_original_iv(ctx: *const EVP_CIPHER_CTX) -> *const crate::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_noconst(ctx: *mut EVP_CIPHER_CTX) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_buf_noconst(ctx: *mut EVP_CIPHER_CTX) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_num(ctx: *const EVP_CIPHER_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_num(ctx: *mut EVP_CIPHER_CTX, num: crate::cty::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_copy(
        out: *mut EVP_CIPHER_CTX,
        in_: *const EVP_CIPHER_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_app_data(ctx: *const EVP_CIPHER_CTX) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_app_data(ctx: *mut EVP_CIPHER_CTX, data: *mut crate::cty::c_void);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_cipher_data(ctx: *const EVP_CIPHER_CTX) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_cipher_data(
        ctx: *mut EVP_CIPHER_CTX,
        cipher_data: *mut crate::cty::c_void,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EVP_Cipher(
        c: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        in_: *const crate::cty::c_uchar,
        inl: crate::cty::c_uint,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_ctrl(
        ctx: *mut EVP_MD_CTX,
        cmd: crate::cty::c_int,
        p1: crate::cty::c_int,
        p2: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_new() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_reset(ctx: *mut EVP_MD_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_free(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_copy_ex(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_set_flags(ctx: *mut EVP_MD_CTX, flags: crate::cty::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_clear_flags(ctx: *mut EVP_MD_CTX, flags: crate::cty::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_test_flags(
        ctx: *const EVP_MD_CTX,
        flags: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestUpdate(
        ctx: *mut EVP_MD_CTX,
        d: *const crate::cty::c_void,
        cnt: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal_ex(
        ctx: *mut EVP_MD_CTX,
        md: *mut crate::cty::c_uchar,
        s: *mut crate::cty::c_uint,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_Digest(
        data: *const crate::cty::c_void,
        count: size_t,
        md: *mut crate::cty::c_uchar,
        size: *mut crate::cty::c_uint,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_copy(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut crate::cty::c_uchar,
        s: *mut crate::cty::c_uint,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestFinalXOF(
        ctx: *mut EVP_MD_CTX,
        md: *mut crate::cty::c_uchar,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_read_pw_string(
        buf: *mut crate::cty::c_char,
        length: crate::cty::c_int,
        prompt: *const crate::cty::c_char,
        verify: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_read_pw_string_min(
        buf: *mut crate::cty::c_char,
        minlen: crate::cty::c_int,
        maxlen: crate::cty::c_int,
        prompt: *const crate::cty::c_char,
        verify: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_set_pw_prompt(prompt: *const crate::cty::c_char);
}
extern "C" {
    pub fn EVP_get_pw_prompt() -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn EVP_BytesToKey(
        type_: *const EVP_CIPHER,
        md: *const EVP_MD,
        salt: *const crate::cty::c_uchar,
        data: *const crate::cty::c_uchar,
        datal: crate::cty::c_int,
        count: crate::cty::c_int,
        key: *mut crate::cty::c_uchar,
        iv: *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_flags(ctx: *mut EVP_CIPHER_CTX, flags: crate::cty::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_clear_flags(ctx: *mut EVP_CIPHER_CTX, flags: crate::cty::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_test_flags(
        ctx: *const EVP_CIPHER_CTX,
        flags: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const crate::cty::c_uchar,
        iv: *const crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const crate::cty::c_uchar,
        iv: *const crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
        in_: *const crate::cty::c_uchar,
        inl: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const crate::cty::c_uchar,
        iv: *const crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const crate::cty::c_uchar,
        iv: *const crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
        in_: *const crate::cty::c_uchar,
        inl: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const crate::cty::c_uchar,
        iv: *const crate::cty::c_uchar,
        enc: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const crate::cty::c_uchar,
        iv: *const crate::cty::c_uchar,
        enc: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
        in_: *const crate::cty::c_uchar,
        inl: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_SignFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut crate::cty::c_uchar,
        s: *mut crate::cty::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSign(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut crate::cty::c_uchar,
        siglen: *mut size_t,
        tbs: *const crate::cty::c_uchar,
        tbslen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_VerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sigbuf: *const crate::cty::c_uchar,
        siglen: crate::cty::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerify(
        ctx: *mut EVP_MD_CTX,
        sigret: *const crate::cty::c_uchar,
        siglen: size_t,
        tbs: *const crate::cty::c_uchar,
        tbslen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSignInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSignFinal(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut crate::cty::c_uchar,
        siglen: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const crate::cty::c_uchar,
        siglen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_OpenInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *const crate::cty::c_uchar,
        ekl: crate::cty::c_int,
        iv: *const crate::cty::c_uchar,
        priv_: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_OpenFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_SealInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *mut *mut crate::cty::c_uchar,
        ekl: *mut crate::cty::c_int,
        iv: *mut crate::cty::c_uchar,
        pubk: *mut *mut EVP_PKEY,
        npubk: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_SealFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_new() -> *mut EVP_ENCODE_CTX;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_free(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_ENCODE_CTX_copy(
        dctx: *mut EVP_ENCODE_CTX,
        sctx: *mut EVP_ENCODE_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_num(ctx: *mut EVP_ENCODE_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_EncodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
        in_: *const crate::cty::c_uchar,
        inl: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_EncodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    );
}
extern "C" {
    pub fn EVP_EncodeBlock(
        t: *mut crate::cty::c_uchar,
        f: *const crate::cty::c_uchar,
        n: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_DecodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
        in_: *const crate::cty::c_uchar,
        inl: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut crate::cty::c_uchar,
        outl: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_DecodeBlock(
        t: *mut crate::cty::c_uchar,
        f: *const crate::cty::c_uchar,
        n: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_new() -> *mut EVP_CIPHER_CTX;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_reset(c: *mut EVP_CIPHER_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_free(c: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_key_length(
        x: *mut EVP_CIPHER_CTX,
        keylen: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_padding(
        c: *mut EVP_CIPHER_CTX,
        pad: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_ctrl(
        ctx: *mut EVP_CIPHER_CTX,
        type_: crate::cty::c_int,
        arg: crate::cty::c_int,
        ptr: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_rand_key(
        ctx: *mut EVP_CIPHER_CTX,
        key: *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn BIO_f_md() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_base64() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_cipher() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_reliable() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_cipher(
        b: *mut BIO,
        c: *const EVP_CIPHER,
        k: *const crate::cty::c_uchar,
        i: *const crate::cty::c_uchar,
        enc: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_md_null() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md4() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2b512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2s256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake128() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_ripemd160() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_whirlpool() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sm3() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_enc_null() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_desx_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_40() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_hmac_md5() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_40_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_64_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_chacha20() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_chacha20_poly1305() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_add_cipher(cipher: *const EVP_CIPHER) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_add_digest(digest: *const EVP_MD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_get_cipherbyname(name: *const crate::cty::c_char) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_get_digestbyname(name: *const crate::cty::c_char) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_CIPHER_do_all(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const crate::cty::c_char,
                to: *const crate::cty::c_char,
                x: *mut crate::cty::c_void,
            ),
        >,
        arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_CIPHER_do_all_sorted(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const crate::cty::c_char,
                to: *const crate::cty::c_char,
                x: *mut crate::cty::c_void,
            ),
        >,
        arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const crate::cty::c_char,
                to: *const crate::cty::c_char,
                x: *mut crate::cty::c_void,
            ),
        >,
        arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all_sorted(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const crate::cty::c_char,
                to: *const crate::cty::c_char,
                x: *mut crate::cty::c_void,
            ),
        >,
        arg: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_PKEY_decrypt_old(
        dec_key: *mut crate::cty::c_uchar,
        enc_key: *const crate::cty::c_uchar,
        enc_key_len: crate::cty::c_int,
        private_key: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_old(
        enc_key: *mut crate::cty::c_uchar,
        key: *const crate::cty::c_uchar,
        key_len: crate::cty::c_int,
        pub_key: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_type(type_: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_id(pkey: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_base_id(pkey: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_bits(pkey: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_security_bits(pkey: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_size(pkey: *mut EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type(pkey: *mut EVP_PKEY, type_: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type_str(
        pkey: *mut EVP_PKEY,
        str_: *const crate::cty::c_char,
        len: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_alias_type(
        pkey: *mut EVP_PKEY,
        type_: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_engine(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign(
        pkey: *mut EVP_PKEY,
        type_: crate::cty::c_int,
        key: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0(pkey: *const EVP_PKEY) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EVP_PKEY_get0_hmac(
        pkey: *const EVP_PKEY,
        len: *mut size_t,
    ) -> *const crate::cty::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_get0_poly1305(
        pkey: *const EVP_PKEY,
        len: *mut size_t,
    ) -> *const crate::cty::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_get0_siphash(
        pkey: *const EVP_PKEY,
        len: *mut size_t,
    ) -> *const crate::cty::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_set1_RSA(pkey: *mut EVP_PKEY, key: *mut rsa_st) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_RSA(pkey: *mut EVP_PKEY) -> *mut rsa_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_RSA(pkey: *mut EVP_PKEY) -> *mut rsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DSA(pkey: *mut EVP_PKEY, key: *mut dsa_st) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DSA(pkey: *mut EVP_PKEY) -> *mut dsa_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_DSA(pkey: *mut EVP_PKEY) -> *mut dsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DH(pkey: *mut EVP_PKEY, key: *mut dh_st) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DH(pkey: *mut EVP_PKEY) -> *mut dh_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_DH(pkey: *mut EVP_PKEY) -> *mut dh_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_EC_KEY(pkey: *mut EVP_PKEY, key: *mut ec_key_st) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_EC_KEY(pkey: *mut EVP_PKEY) -> *mut ec_key_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_EC_KEY(pkey: *mut EVP_PKEY) -> *mut ec_key_st;
}
extern "C" {
    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_up_ref(pkey: *mut EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
}
extern "C" {
    pub fn d2i_PublicKey(
        type_: crate::cty::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const crate::cty::c_uchar,
        length: crate::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PublicKey(a: *mut EVP_PKEY, pp: *mut *mut crate::cty::c_uchar) -> crate::cty::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey(
        type_: crate::cty::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const crate::cty::c_uchar,
        length: crate::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_AutoPrivateKey(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const crate::cty::c_uchar,
        length: crate::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PrivateKey(a: *mut EVP_PKEY, pp: *mut *mut crate::cty::c_uchar)
        -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_copy_parameters(to: *mut EVP_PKEY, from: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_missing_parameters(pkey: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_save_parameters(
        pkey: *mut EVP_PKEY,
        mode: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp_parameters(a: *const EVP_PKEY, b: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp(a: *const EVP_PKEY, b: *const EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_public(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: crate::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_private(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: crate::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_params(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: crate::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_default_digest_nid(
        pkey: *mut EVP_PKEY,
        pnid: *mut crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_tls_encodedpoint(
        pkey: *mut EVP_PKEY,
        pt: *const crate::cty::c_uchar,
        ptlen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_tls_encodedpoint(
        pkey: *mut EVP_PKEY,
        ppt: *mut *mut crate::cty::c_uchar,
    ) -> size_t;
}
extern "C" {
    pub fn EVP_CIPHER_type(ctx: *const EVP_CIPHER) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_param_to_asn1(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_asn1_to_param(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_set_asn1_iv(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_asn1_iv(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const crate::cty::c_char,
        passlen: crate::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC_SHA1(
        pass: *const crate::cty::c_char,
        passlen: crate::cty::c_int,
        salt: *const crate::cty::c_uchar,
        saltlen: crate::cty::c_int,
        iter: crate::cty::c_int,
        keylen: crate::cty::c_int,
        out: *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC(
        pass: *const crate::cty::c_char,
        passlen: crate::cty::c_int,
        salt: *const crate::cty::c_uchar,
        saltlen: crate::cty::c_int,
        iter: crate::cty::c_int,
        digest: *const EVP_MD,
        keylen: crate::cty::c_int,
        out: *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn PKCS5_v2_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const crate::cty::c_char,
        passlen: crate::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_scrypt(
        pass: *const crate::cty::c_char,
        passlen: size_t,
        salt: *const crate::cty::c_uchar,
        saltlen: size_t,
        N: u64,
        r: u64,
        p: u64,
        maxmem: u64,
        key: *mut crate::cty::c_uchar,
        keylen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn PKCS5_v2_scrypt_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const crate::cty::c_char,
        passlen: crate::cty::c_int,
        param: *mut ASN1_TYPE,
        c: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_add();
}
extern "C" {
    pub fn EVP_PBE_CipherInit(
        pbe_obj: *mut ASN1_OBJECT,
        pass: *const crate::cty::c_char,
        passlen: crate::cty::c_int,
        param: *mut ASN1_TYPE,
        ctx: *mut EVP_CIPHER_CTX,
        en_de: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add_type(
        pbe_type: crate::cty::c_int,
        pbe_nid: crate::cty::c_int,
        cipher_nid: crate::cty::c_int,
        md_nid: crate::cty::c_int,
        keygen: EVP_PBE_KEYGEN,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add(
        nid: crate::cty::c_int,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        keygen: EVP_PBE_KEYGEN,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_find(
        type_: crate::cty::c_int,
        pbe_nid: crate::cty::c_int,
        pcnid: *mut crate::cty::c_int,
        pmnid: *mut crate::cty::c_int,
        pkeygen: *mut EVP_PBE_KEYGEN,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_cleanup();
}
extern "C" {
    pub fn EVP_PBE_get(
        ptype: *mut crate::cty::c_int,
        ppbe_nid: *mut crate::cty::c_int,
        num: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get_count() -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0(idx: crate::cty::c_int) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find(
        pe: *mut *mut ENGINE,
        type_: crate::cty::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find_str(
        pe: *mut *mut ENGINE,
        str_: *const crate::cty::c_char,
        len: crate::cty::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add0(ameth: *const EVP_PKEY_ASN1_METHOD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add_alias(
        to: crate::cty::c_int,
        from: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0_info(
        ppkey_id: *mut crate::cty::c_int,
        pkey_base_id: *mut crate::cty::c_int,
        ppkey_flags: *mut crate::cty::c_int,
        pinfo: *mut *const crate::cty::c_char,
        ppem_str: *mut *const crate::cty::c_char,
        ameth: *const EVP_PKEY_ASN1_METHOD,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_asn1(pkey: *const EVP_PKEY) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_new(
        id: crate::cty::c_int,
        flags: crate::cty::c_int,
        pem_str: *const crate::cty::c_char,
        info: *const crate::cty::c_char,
    ) -> *mut EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_copy(dst: *mut EVP_PKEY_ASN1_METHOD, src: *const EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_free(ameth: *mut EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_public(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pub_decode: ::core::option::Option<
            unsafe extern "C" fn(pk: *mut EVP_PKEY, pub_: *mut X509_PUBKEY) -> crate::cty::c_int,
        >,
        pub_encode: ::core::option::Option<
            unsafe extern "C" fn(pub_: *mut X509_PUBKEY, pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
        pub_cmp: ::core::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> crate::cty::c_int,
        >,
        pub_print: ::core::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: crate::cty::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> crate::cty::c_int,
        >,
        pkey_size: ::core::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
        pkey_bits: ::core::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_private(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        priv_decode: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                p8inf: *const PKCS8_PRIV_KEY_INFO,
            ) -> crate::cty::c_int,
        >,
        priv_encode: ::core::option::Option<
            unsafe extern "C" fn(
                p8: *mut PKCS8_PRIV_KEY_INFO,
                pk: *const EVP_PKEY,
            ) -> crate::cty::c_int,
        >,
        priv_print: ::core::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: crate::cty::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_param(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        param_decode: ::core::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                pder: *mut *const crate::cty::c_uchar,
                derlen: crate::cty::c_int,
            ) -> crate::cty::c_int,
        >,
        param_encode: ::core::option::Option<
            unsafe extern "C" fn(
                pkey: *const EVP_PKEY,
                pder: *mut *mut crate::cty::c_uchar,
            ) -> crate::cty::c_int,
        >,
        param_missing: ::core::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
        param_copy: ::core::option::Option<
            unsafe extern "C" fn(to: *mut EVP_PKEY, from: *const EVP_PKEY) -> crate::cty::c_int,
        >,
        param_cmp: ::core::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> crate::cty::c_int,
        >,
        param_print: ::core::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: crate::cty::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_free(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_free: ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_ctrl(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                op: crate::cty::c_int,
                arg1: crate::cty::c_long,
                arg2: *mut crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_item(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        item_verify: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                asn: *mut crate::cty::c_void,
                a: *mut X509_ALGOR,
                sig: *mut ASN1_BIT_STRING,
                pkey: *mut EVP_PKEY,
            ) -> crate::cty::c_int,
        >,
        item_sign: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                asn: *mut crate::cty::c_void,
                alg1: *mut X509_ALGOR,
                alg2: *mut X509_ALGOR,
                sig: *mut ASN1_BIT_STRING,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_siginf(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        siginf_set: ::core::option::Option<
            unsafe extern "C" fn(
                siginf: *mut X509_SIG_INFO,
                alg: *const X509_ALGOR,
                sig: *const ASN1_STRING,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_check: ::core::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_public_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_pub_check: ::core::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_param_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_param_check: ::core::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_set_priv_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        set_priv_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                priv_: *const crate::cty::c_uchar,
                len: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_set_pub_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        set_pub_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                pub_: *const crate::cty::c_uchar,
                len: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_get_priv_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        get_priv_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *const EVP_PKEY,
                priv_: *mut crate::cty::c_uchar,
                len: *mut size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_get_pub_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        get_pub_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *const EVP_PKEY,
                pub_: *mut crate::cty::c_uchar,
                len: *mut size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_security_bits(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_security_bits: ::core::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_find(type_: crate::cty::c_int) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_new(
        id: crate::cty::c_int,
        flags: crate::cty::c_int,
    ) -> *mut EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_get0_info(
        ppkey_id: *mut crate::cty::c_int,
        pflags: *mut crate::cty::c_int,
        meth: *const EVP_PKEY_METHOD,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_copy(dst: *mut EVP_PKEY_METHOD, src: *const EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_free(pmeth: *mut EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_add0(pmeth: *const EVP_PKEY_METHOD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_remove(pmeth: *const EVP_PKEY_METHOD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_get_count() -> size_t;
}
extern "C" {
    pub fn EVP_PKEY_meth_get0(idx: size_t) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_id(id: crate::cty::c_int, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_dup(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_free(ctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl(
        ctx: *mut EVP_PKEY_CTX,
        keytype: crate::cty::c_int,
        optype: crate::cty::c_int,
        cmd: crate::cty::c_int,
        p1: crate::cty::c_int,
        p2: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl_str(
        ctx: *mut EVP_PKEY_CTX,
        type_: *const crate::cty::c_char,
        value: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl_uint64(
        ctx: *mut EVP_PKEY_CTX,
        keytype: crate::cty::c_int,
        optype: crate::cty::c_int,
        cmd: crate::cty::c_int,
        value: u64,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_str2ctrl(
        ctx: *mut EVP_PKEY_CTX,
        cmd: crate::cty::c_int,
        str_: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_hex2ctrl(
        ctx: *mut EVP_PKEY_CTX,
        cmd: crate::cty::c_int,
        hex: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_md(
        ctx: *mut EVP_PKEY_CTX,
        optype: crate::cty::c_int,
        cmd: crate::cty::c_int,
        md: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_operation(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_keygen_info(
        ctx: *mut EVP_PKEY_CTX,
        dat: *mut crate::cty::c_int,
        datlen: crate::cty::c_int,
    );
}
extern "C" {
    pub fn EVP_PKEY_new_mac_key(
        type_: crate::cty::c_int,
        e: *mut ENGINE,
        key: *const crate::cty::c_uchar,
        keylen: crate::cty::c_int,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_private_key(
        type_: crate::cty::c_int,
        e: *mut ENGINE,
        priv_: *const crate::cty::c_uchar,
        len: size_t,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_public_key(
        type_: crate::cty::c_int,
        e: *mut ENGINE,
        pub_: *const crate::cty::c_uchar,
        len: size_t,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_private_key(
        pkey: *const EVP_PKEY,
        priv_: *mut crate::cty::c_uchar,
        len: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_public_key(
        pkey: *const EVP_PKEY,
        pub_: *mut crate::cty::c_uchar,
        len: *mut size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_new_CMAC_key(
        e: *mut ENGINE,
        priv_: *const crate::cty::c_uchar,
        len: size_t,
        cipher: *const EVP_CIPHER,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_data(ctx: *mut EVP_PKEY_CTX, data: *mut crate::cty::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_data(ctx: *mut EVP_PKEY_CTX) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_pkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_peerkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_app_data(ctx: *mut EVP_PKEY_CTX, data: *mut crate::cty::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_app_data(ctx: *mut EVP_PKEY_CTX) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EVP_PKEY_sign_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_sign(
        ctx: *mut EVP_PKEY_CTX,
        sig: *mut crate::cty::c_uchar,
        siglen: *mut size_t,
        tbs: *const crate::cty::c_uchar,
        tbslen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify(
        ctx: *mut EVP_PKEY_CTX,
        sig: *const crate::cty::c_uchar,
        siglen: size_t,
        tbs: *const crate::cty::c_uchar,
        tbslen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover(
        ctx: *mut EVP_PKEY_CTX,
        rout: *mut crate::cty::c_uchar,
        routlen: *mut size_t,
        sig: *const crate::cty::c_uchar,
        siglen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut crate::cty::c_uchar,
        outlen: *mut size_t,
        in_: *const crate::cty::c_uchar,
        inlen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut crate::cty::c_uchar,
        outlen: *mut size_t,
        in_: *const crate::cty::c_uchar,
        inlen: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_set_peer(
        ctx: *mut EVP_PKEY_CTX,
        peer: *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive(
        ctx: *mut EVP_PKEY_CTX,
        key: *mut crate::cty::c_uchar,
        keylen: *mut size_t,
    ) -> crate::cty::c_int;
}
pub type EVP_PKEY_gen_cb =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int>;
extern "C" {
    pub fn EVP_PKEY_paramgen_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen(
        ctx: *mut EVP_PKEY_CTX,
        ppkey: *mut *mut EVP_PKEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen_init(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen(ctx: *mut EVP_PKEY_CTX, ppkey: *mut *mut EVP_PKEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_check(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_public_check(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_param_check(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_cb(ctx: *mut EVP_PKEY_CTX, cb: EVP_PKEY_gen_cb);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_cb(ctx: *mut EVP_PKEY_CTX) -> EVP_PKEY_gen_cb;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_keygen_info(
        ctx: *mut EVP_PKEY_CTX,
        idx: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_set_init(
        pmeth: *mut EVP_PKEY_METHOD,
        init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_copy(
        pmeth: *mut EVP_PKEY_METHOD,
        copy: ::core::option::Option<
            unsafe extern "C" fn(
                dst: *mut EVP_PKEY_CTX,
                src: *mut EVP_PKEY_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_cleanup(
        pmeth: *mut EVP_PKEY_METHOD,
        cleanup: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_paramgen(
        pmeth: *mut EVP_PKEY_METHOD,
        paramgen_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        paramgen: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_keygen(
        pmeth: *mut EVP_PKEY_METHOD,
        keygen_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        keygen: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_sign(
        pmeth: *mut EVP_PKEY_METHOD,
        sign_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        sign: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut size_t,
                tbs: *const crate::cty::c_uchar,
                tbslen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        verify: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const crate::cty::c_uchar,
                siglen: size_t,
                tbs: *const crate::cty::c_uchar,
                tbslen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify_recover(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_recover_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        verify_recover: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut size_t,
                tbs: *const crate::cty::c_uchar,
                tbslen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_signctx(
        pmeth: *mut EVP_PKEY_METHOD,
        signctx_init: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
        signctx: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut size_t,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verifyctx(
        pmeth: *mut EVP_PKEY_METHOD,
        verifyctx_init: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
        verifyctx: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const crate::cty::c_uchar,
                siglen: crate::cty::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_encrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        encrypt_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        encryptfn: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut crate::cty::c_uchar,
                outlen: *mut size_t,
                in_: *const crate::cty::c_uchar,
                inlen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_decrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        decrypt_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        decrypt: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut crate::cty::c_uchar,
                outlen: *mut size_t,
                in_: *const crate::cty::c_uchar,
                inlen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_derive(
        pmeth: *mut EVP_PKEY_METHOD,
        derive_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        derive: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut crate::cty::c_uchar,
                keylen: *mut size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_ctrl(
        pmeth: *mut EVP_PKEY_METHOD,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: crate::cty::c_int,
                p1: crate::cty::c_int,
                p2: *mut crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
        ctrl_str: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const crate::cty::c_char,
                value: *const crate::cty::c_char,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::core::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_public_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::core::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_param_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::core::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_digest_custom(
        pmeth: *mut EVP_PKEY_METHOD,
        digest_custom: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_init(
        pmeth: *const EVP_PKEY_METHOD,
        pinit: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_copy(
        pmeth: *const EVP_PKEY_METHOD,
        pcopy: *mut ::core::option::Option<
            unsafe extern "C" fn(
                dst: *mut EVP_PKEY_CTX,
                src: *mut EVP_PKEY_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_cleanup(
        pmeth: *const EVP_PKEY_METHOD,
        pcleanup: *mut ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_paramgen(
        pmeth: *const EVP_PKEY_METHOD,
        pparamgen_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        pparamgen: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_keygen(
        pmeth: *const EVP_PKEY_METHOD,
        pkeygen_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        pkeygen: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_sign(
        pmeth: *const EVP_PKEY_METHOD,
        psign_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        psign: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut size_t,
                tbs: *const crate::cty::c_uchar,
                tbslen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify(
        pmeth: *const EVP_PKEY_METHOD,
        pverify_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        pverify: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const crate::cty::c_uchar,
                siglen: size_t,
                tbs: *const crate::cty::c_uchar,
                tbslen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify_recover(
        pmeth: *const EVP_PKEY_METHOD,
        pverify_recover_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        pverify_recover: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut size_t,
                tbs: *const crate::cty::c_uchar,
                tbslen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_signctx(
        pmeth: *const EVP_PKEY_METHOD,
        psignctx_init: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
        psignctx: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut size_t,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verifyctx(
        pmeth: *const EVP_PKEY_METHOD,
        pverifyctx_init: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
        pverifyctx: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const crate::cty::c_uchar,
                siglen: crate::cty::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_encrypt(
        pmeth: *const EVP_PKEY_METHOD,
        pencrypt_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        pencryptfn: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut crate::cty::c_uchar,
                outlen: *mut size_t,
                in_: *const crate::cty::c_uchar,
                inlen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_decrypt(
        pmeth: *const EVP_PKEY_METHOD,
        pdecrypt_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        pdecrypt: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut crate::cty::c_uchar,
                outlen: *mut size_t,
                in_: *const crate::cty::c_uchar,
                inlen: size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_derive(
        pmeth: *const EVP_PKEY_METHOD,
        pderive_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> crate::cty::c_int,
        >,
        pderive: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut crate::cty::c_uchar,
                keylen: *mut size_t,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_ctrl(
        pmeth: *const EVP_PKEY_METHOD,
        pctrl: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: crate::cty::c_int,
                p1: crate::cty::c_int,
                p2: *mut crate::cty::c_void,
            ) -> crate::cty::c_int,
        >,
        pctrl_str: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const crate::cty::c_char,
                value: *const crate::cty::c_char,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::core::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_public_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::core::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_param_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::core::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_digest_custom(
        pmeth: *mut EVP_PKEY_METHOD,
        pdigest_custom: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_add_alg_module();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHAstate_st {
    pub h0: crate::cty::c_uint,
    pub h1: crate::cty::c_uint,
    pub h2: crate::cty::c_uint,
    pub h3: crate::cty::c_uint,
    pub h4: crate::cty::c_uint,
    pub Nl: crate::cty::c_uint,
    pub Nh: crate::cty::c_uint,
    pub data: [crate::cty::c_uint; 16usize],
    pub num: crate::cty::c_uint,
}
#[test]
fn bindgen_test_layout_SHAstate_st() {
    assert_eq!(
        ::core::mem::size_of::<SHAstate_st>(),
        96usize,
        concat!("Size of: ", stringify!(SHAstate_st))
    );
    assert_eq!(
        ::core::mem::align_of::<SHAstate_st>(),
        4usize,
        concat!("Alignment of ", stringify!(SHAstate_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).h0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).h1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).h2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).h3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).h4 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).Nl as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).Nh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHAstate_st>())).num as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(num)
        )
    );
}
pub type SHA_CTX = SHAstate_st;
extern "C" {
    pub fn SHA1_Init(c: *mut SHA_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA1_Update(
        c: *mut SHA_CTX,
        data: *const crate::cty::c_void,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA1_Final(md: *mut crate::cty::c_uchar, c: *mut SHA_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA1(
        d: *const crate::cty::c_uchar,
        n: size_t,
        md: *mut crate::cty::c_uchar,
    ) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn SHA1_Transform(c: *mut SHA_CTX, data: *const crate::cty::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHA256state_st {
    pub h: [crate::cty::c_uint; 8usize],
    pub Nl: crate::cty::c_uint,
    pub Nh: crate::cty::c_uint,
    pub data: [crate::cty::c_uint; 16usize],
    pub num: crate::cty::c_uint,
    pub md_len: crate::cty::c_uint,
}
#[test]
fn bindgen_test_layout_SHA256state_st() {
    assert_eq!(
        ::core::mem::size_of::<SHA256state_st>(),
        112usize,
        concat!("Size of: ", stringify!(SHA256state_st))
    );
    assert_eq!(
        ::core::mem::align_of::<SHA256state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(SHA256state_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA256state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA256state_st>())).Nl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA256state_st>())).Nh as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA256state_st>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA256state_st>())).num as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA256state_st>())).md_len as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(md_len)
        )
    );
}
pub type SHA256_CTX = SHA256state_st;
extern "C" {
    pub fn SHA224_Init(c: *mut SHA256_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA224_Update(
        c: *mut SHA256_CTX,
        data: *const crate::cty::c_void,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA224_Final(md: *mut crate::cty::c_uchar, c: *mut SHA256_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA224(
        d: *const crate::cty::c_uchar,
        n: size_t,
        md: *mut crate::cty::c_uchar,
    ) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn SHA256_Init(c: *mut SHA256_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA256_Update(
        c: *mut SHA256_CTX,
        data: *const crate::cty::c_void,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA256_Final(md: *mut crate::cty::c_uchar, c: *mut SHA256_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA256(
        d: *const crate::cty::c_uchar,
        n: size_t,
        md: *mut crate::cty::c_uchar,
    ) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn SHA256_Transform(c: *mut SHA256_CTX, data: *const crate::cty::c_uchar);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHA512state_st {
    pub h: [crate::cty::c_ulonglong; 8usize],
    pub Nl: crate::cty::c_ulonglong,
    pub Nh: crate::cty::c_ulonglong,
    pub u: SHA512state_st__bindgen_ty_1,
    pub num: crate::cty::c_uint,
    pub md_len: crate::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHA512state_st__bindgen_ty_1 {
    pub d: [crate::cty::c_ulonglong; 16usize],
    pub p: [crate::cty::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_SHA512state_st__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SHA512state_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(SHA512state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SHA512state_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SHA512state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st__bindgen_ty_1>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_SHA512state_st() {
    assert_eq!(
        ::core::mem::size_of::<SHA512state_st>(),
        216usize,
        concat!("Size of: ", stringify!(SHA512state_st))
    );
    assert_eq!(
        ::core::mem::align_of::<SHA512state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(SHA512state_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st>())).Nl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st>())).Nh as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st>())).u as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st>())).num as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SHA512state_st>())).md_len as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(md_len)
        )
    );
}
pub type SHA512_CTX = SHA512state_st;
extern "C" {
    pub fn SHA384_Init(c: *mut SHA512_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA384_Update(
        c: *mut SHA512_CTX,
        data: *const crate::cty::c_void,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA384_Final(md: *mut crate::cty::c_uchar, c: *mut SHA512_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA384(
        d: *const crate::cty::c_uchar,
        n: size_t,
        md: *mut crate::cty::c_uchar,
    ) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn SHA512_Init(c: *mut SHA512_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA512_Update(
        c: *mut SHA512_CTX,
        data: *const crate::cty::c_void,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA512_Final(md: *mut crate::cty::c_uchar, c: *mut SHA512_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn SHA512(
        d: *const crate::cty::c_uchar,
        n: size_t,
        md: *mut crate::cty::c_uchar,
    ) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn SHA512_Transform(c: *mut SHA512_CTX, data: *const crate::cty::c_uchar);
}
extern "C" {
    pub fn memcpy(
        __dest: *mut crate::cty::c_void,
        __src: *const crate::cty::c_void,
        __n: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut crate::cty::c_void,
        __src: *const crate::cty::c_void,
        __n: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut crate::cty::c_void,
        __c: crate::cty::c_int,
        __n: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const crate::cty::c_void,
        __s2: *const crate::cty::c_void,
        __n: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const crate::cty::c_void,
        __c: crate::cty::c_int,
        __n: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut crate::cty::c_char,
        __src: *const crate::cty::c_char,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut crate::cty::c_char,
        __src: *const crate::cty::c_char,
        __n: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut crate::cty::c_char,
        __src: *const crate::cty::c_char,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut crate::cty::c_char,
        __src: *const crate::cty::c_char,
        __n: crate::cty::c_ulong,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const crate::cty::c_char,
        __s2: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const crate::cty::c_char,
        __s2: *const crate::cty::c_char,
        __n: crate::cty::c_ulong,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const crate::cty::c_char,
        __s2: *const crate::cty::c_char,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut crate::cty::c_char,
        __src: *const crate::cty::c_char,
        __n: crate::cty::c_ulong,
    ) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn strchr(
        __s: *const crate::cty::c_char,
        __c: crate::cty::c_int,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const crate::cty::c_char,
        __c: crate::cty::c_int,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const crate::cty::c_char,
        __reject: *const crate::cty::c_char,
    ) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const crate::cty::c_char,
        __accept: *const crate::cty::c_char,
    ) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const crate::cty::c_char,
        __accept: *const crate::cty::c_char,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const crate::cty::c_char,
        __needle: *const crate::cty::c_char,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut crate::cty::c_char,
        __delim: *const crate::cty::c_char,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut crate::cty::c_char,
        __delim: *const crate::cty::c_char,
        __save_ptr: *mut *mut crate::cty::c_char,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn strlen(__s: *const crate::cty::c_char) -> crate::cty::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: crate::cty::c_int) -> *mut crate::cty::c_char;
}
pub type TPM_ALG_ID = UINT16;
pub type TPM_ECC_CURVE = UINT16;
pub type TPM_CC = UINT32;
pub type TPM_ALGORITHM_ID = UINT32;
pub type TPM_MODIFIER_INDICATOR = UINT32;
pub type TPM_AUTHORIZATION_SIZE = UINT32;
pub type TPM_PARAMETER_SIZE = UINT32;
pub type TPM_KEY_SIZE = UINT16;
pub type TPM_KEY_BITS = UINT16;
pub type TPM_SPEC = UINT32;
pub type TPM_CONSTANTS32 = UINT32;
pub type TPM_RC = UINT32;
pub type TPM_CLOCK_ADJUST = INT8;
pub type TPM_EO = UINT16;
pub type TPM_ST = UINT16;
pub type TPM_SU = UINT16;
pub type TPM_SE = UINT8;
pub type TPM_CAP = UINT32;
pub type TPM_PT = UINT32;
pub type TPM_PT_PCR = UINT32;
pub type TPM_PS = UINT32;
pub type TPM_HANDLE = UINT32;
pub type TPM_HT = UINT8;
pub type TPM_RH = TPM_HANDLE;
pub type TPM_HC = TPM_HANDLE;
pub type TPMA_ALGORITHM = UINT32;
pub type TPMA_OBJECT = UINT32;
pub type TPMA_SESSION = UINT8;
pub type TPMA_LOCALITY = UINT8;
pub type TPMA_PERMANENT = UINT32;
pub type TPMA_STARTUP_CLEAR = UINT32;
pub type TPMA_MEMORY = UINT32;
pub type TPMA_CC = UINT32;
pub type TPMA_MODES = UINT32;
pub type TPMA_X509_KEY_USAGE = UINT32;
pub type TPMA_ACT = UINT32;
pub type TPMI_YES_NO = BYTE;
pub type TPMI_DH_OBJECT = TPM_HANDLE;
pub type TPMI_DH_PARENT = TPM_HANDLE;
pub type TPMI_DH_PERSISTENT = TPM_HANDLE;
pub type TPMI_DH_ENTITY = TPM_HANDLE;
pub type TPMI_DH_PCR = TPM_HANDLE;
pub type TPMI_SH_AUTH_SESSION = TPM_HANDLE;
pub type TPMI_SH_HMAC = TPM_HANDLE;
pub type TPMI_SH_POLICY = TPM_HANDLE;
pub type TPMI_DH_CONTEXT = TPM_HANDLE;
pub type TPMI_DH_SAVED = TPM_HANDLE;
pub type TPMI_RH_HIERARCHY = TPM_HANDLE;
pub type TPMI_RH_ENABLES = TPM_HANDLE;
pub type TPMI_RH_HIERARCHY_AUTH = TPM_HANDLE;
pub type TPMI_RH_HIERARCHY_POLICY = TPM_HANDLE;
pub type TPMI_RH_PLATFORM = TPM_HANDLE;
pub type TPMI_RH_OWNER = TPM_HANDLE;
pub type TPMI_RH_ENDORSEMENT = TPM_HANDLE;
pub type TPMI_RH_PROVISION = TPM_HANDLE;
pub type TPMI_RH_CLEAR = TPM_HANDLE;
pub type TPMI_RH_NV_AUTH = TPM_HANDLE;
pub type TPMI_RH_LOCKOUT = TPM_HANDLE;
pub type TPMI_RH_NV_INDEX = TPM_HANDLE;
pub type TPMI_RH_AC = TPM_HANDLE;
pub type TPMI_RH_ACT = TPM_HANDLE;
pub type TPMI_ALG_HASH = TPM_ALG_ID;
pub type TPMI_ALG_ASYM = TPM_ALG_ID;
pub type TPMI_ALG_SYM = TPM_ALG_ID;
pub type TPMI_ALG_SYM_OBJECT = TPM_ALG_ID;
pub type TPMI_ALG_SYM_MODE = TPM_ALG_ID;
pub type TPMI_ALG_KDF = TPM_ALG_ID;
pub type TPMI_ALG_SIG_SCHEME = TPM_ALG_ID;
pub type TPMI_ECC_KEY_EXCHANGE = TPM_ALG_ID;
pub type TPMI_ST_COMMAND_TAG = TPM_ST;
pub type TPMI_ALG_MAC_SCHEME = TPM_ALG_ID;
pub type TPMI_ALG_CIPHER_MODE = TPM_ALG_ID;
pub type TPMS_EMPTY = BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_ALGORITHM_DESCRIPTION {
    pub alg: TPM_ALG_ID,
    pub attributes: TPMA_ALGORITHM,
}
#[test]
fn bindgen_test_layout_TPMS_ALGORITHM_DESCRIPTION() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ALGORITHM_DESCRIPTION>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_ALGORITHM_DESCRIPTION))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ALGORITHM_DESCRIPTION>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_ALGORITHM_DESCRIPTION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DESCRIPTION>())).alg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DESCRIPTION),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_ALGORITHM_DESCRIPTION>())).attributes as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DESCRIPTION),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_HA {
    pub sha1: [BYTE; 20usize],
    pub sha256: [BYTE; 32usize],
    pub sha384: [BYTE; 48usize],
}
#[test]
fn bindgen_test_layout_TPMU_HA() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_HA>(),
        48usize,
        concat!("Size of: ", stringify!(TPMU_HA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_HA>(),
        1usize,
        concat!("Alignment of ", stringify!(TPMU_HA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_HA>())).sha1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sha1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_HA>())).sha256 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sha256)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_HA>())).sha384 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sha384)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_HA {
    pub hashAlg: TPMI_ALG_HASH,
    pub digest: TPMU_HA,
}
#[test]
fn bindgen_test_layout_TPMT_HA() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_HA>(),
        50usize,
        concat!("Size of: ", stringify!(TPMT_HA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_HA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_HA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_HA>())).hashAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_HA),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_HA>())).digest as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_HA),
            "::",
            stringify!(digest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_DIGEST {
    pub t: TPM2B_DIGEST__bindgen_ty_1,
    pub b: TPM2B,
}
impl core::fmt::Debug for TPM2B_DIGEST {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let t = unsafe { &self.t };
        f.debug_tuple("TPM2B_DIGEST").field(&t).finish()
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_DIGEST__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 48usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DIGEST__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_DIGEST__bindgen_ty_1>(),
        50usize,
        concat!("Size of: ", stringify!(TPM2B_DIGEST__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_DIGEST__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DIGEST__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_DIGEST__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DIGEST__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_DIGEST__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DIGEST__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_DIGEST() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_DIGEST>(),
        50usize,
        concat!("Size of: ", stringify!(TPM2B_DIGEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_DIGEST>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DIGEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_DIGEST>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DIGEST),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_DIGEST>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DIGEST),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_DATA {
    pub t: TPM2B_DATA__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_DATA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 50usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DATA__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_DATA__bindgen_ty_1>(),
        52usize,
        concat!("Size of: ", stringify!(TPM2B_DATA__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_DATA__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DATA__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_DATA__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DATA__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_DATA__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DATA__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_DATA>(),
        52usize,
        concat!("Size of: ", stringify!(TPM2B_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_DATA>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DATA),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_DATA>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DATA),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_NONCE = TPM2B_DIGEST;
pub type TPM2B_AUTH = TPM2B_DIGEST;
pub type TPM2B_OPERAND = TPM2B_DIGEST;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_EVENT {
    pub t: TPM2B_EVENT__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_EVENT__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_EVENT__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_EVENT__bindgen_ty_1>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_EVENT__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_EVENT__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_EVENT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_EVENT__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_EVENT__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_EVENT__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_EVENT__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_EVENT() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_EVENT>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_EVENT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_EVENT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_EVENT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_EVENT>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_EVENT),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_EVENT>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_EVENT),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_MAX_BUFFER {
    pub t: TPM2B_MAX_BUFFER__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_MAX_BUFFER__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_BUFFER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_MAX_BUFFER__bindgen_ty_1>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_BUFFER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_MAX_BUFFER__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_MAX_BUFFER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_MAX_BUFFER__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_BUFFER__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_MAX_BUFFER__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_BUFFER__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_BUFFER() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_MAX_BUFFER>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_BUFFER))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_MAX_BUFFER>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_MAX_BUFFER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_MAX_BUFFER>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_BUFFER),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_MAX_BUFFER>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_BUFFER),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_MAX_NV_BUFFER {
    pub t: TPM2B_MAX_NV_BUFFER__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_MAX_NV_BUFFER__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_NV_BUFFER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_MAX_NV_BUFFER__bindgen_ty_1>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_NV_BUFFER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_MAX_NV_BUFFER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_MAX_NV_BUFFER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_MAX_NV_BUFFER__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_NV_BUFFER__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_MAX_NV_BUFFER__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_NV_BUFFER__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_NV_BUFFER() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_MAX_NV_BUFFER>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_NV_BUFFER))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_MAX_NV_BUFFER>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_MAX_NV_BUFFER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_MAX_NV_BUFFER>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_NV_BUFFER),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_MAX_NV_BUFFER>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_NV_BUFFER),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_TIMEOUT {
    pub t: TPM2B_TIMEOUT__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_TIMEOUT__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 8usize],
}
#[test]
fn bindgen_test_layout_TPM2B_TIMEOUT__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_TIMEOUT__bindgen_ty_1>(),
        10usize,
        concat!("Size of: ", stringify!(TPM2B_TIMEOUT__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_TIMEOUT__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_TIMEOUT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_TIMEOUT__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TIMEOUT__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_TIMEOUT__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TIMEOUT__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_TIMEOUT() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_TIMEOUT>(),
        10usize,
        concat!("Size of: ", stringify!(TPM2B_TIMEOUT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_TIMEOUT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_TIMEOUT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_TIMEOUT>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TIMEOUT),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_TIMEOUT>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TIMEOUT),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_IV {
    pub t: TPM2B_IV__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_IV__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_TPM2B_IV__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_IV__bindgen_ty_1>(),
        18usize,
        concat!("Size of: ", stringify!(TPM2B_IV__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_IV__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_IV__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_IV__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_IV__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_IV__bindgen_ty_1>())).buffer as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_IV__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_IV() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_IV>(),
        18usize,
        concat!("Size of: ", stringify!(TPM2B_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_IV>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_IV))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_IV>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_IV),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_IV>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_IV),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_NAME {
    pub digest: TPMT_HA,
    pub handle: TPM_HANDLE,
}
#[test]
fn bindgen_test_layout_TPMU_NAME() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_NAME>(),
        52usize,
        concat!("Size of: ", stringify!(TPMU_NAME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_NAME>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMU_NAME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_NAME>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_NAME),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_NAME>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_NAME),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_NAME {
    pub t: TPM2B_NAME__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_NAME__bindgen_ty_1 {
    pub size: UINT16,
    pub name: [BYTE; 52usize],
}
#[test]
fn bindgen_test_layout_TPM2B_NAME__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_NAME__bindgen_ty_1>(),
        54usize,
        concat!("Size of: ", stringify!(TPM2B_NAME__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_NAME__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_NAME__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_NAME__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NAME__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_NAME__bindgen_ty_1>())).name as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NAME__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_NAME() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_NAME>(),
        54usize,
        concat!("Size of: ", stringify!(TPM2B_NAME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_NAME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_NAME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_NAME>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NAME),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_NAME>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NAME),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_PCR_SELECT {
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout_TPMS_PCR_SELECT() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_PCR_SELECT>(),
        4usize,
        concat!("Size of: ", stringify!(TPMS_PCR_SELECT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_PCR_SELECT>(),
        1usize,
        concat!("Alignment of ", stringify!(TPMS_PCR_SELECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_PCR_SELECT>())).sizeofSelect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECT),
            "::",
            stringify!(sizeofSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_PCR_SELECT>())).pcrSelect as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECT),
            "::",
            stringify!(pcrSelect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_PCR_SELECTION {
    pub hash: TPMI_ALG_HASH,
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout_TPMS_PCR_SELECTION() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_PCR_SELECTION>(),
        6usize,
        concat!("Size of: ", stringify!(TPMS_PCR_SELECTION))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_PCR_SELECTION>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_PCR_SELECTION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_PCR_SELECTION>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECTION),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_PCR_SELECTION>())).sizeofSelect as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECTION),
            "::",
            stringify!(sizeofSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_PCR_SELECTION>())).pcrSelect as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECTION),
            "::",
            stringify!(pcrSelect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_TK_CREATION {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_CREATION() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_TK_CREATION>(),
        60usize,
        concat!("Size of: ", stringify!(TPMT_TK_CREATION))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_TK_CREATION>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_CREATION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_CREATION>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_CREATION),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_CREATION>())).hierarchy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_CREATION),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_CREATION>())).digest as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_CREATION),
            "::",
            stringify!(digest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_TK_VERIFIED {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_VERIFIED() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_TK_VERIFIED>(),
        60usize,
        concat!("Size of: ", stringify!(TPMT_TK_VERIFIED))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_TK_VERIFIED>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_VERIFIED))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_VERIFIED>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_VERIFIED),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_VERIFIED>())).hierarchy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_VERIFIED),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_VERIFIED>())).digest as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_VERIFIED),
            "::",
            stringify!(digest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_TK_AUTH {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_AUTH() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_TK_AUTH>(),
        60usize,
        concat!("Size of: ", stringify!(TPMT_TK_AUTH))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_TK_AUTH>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_AUTH))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_AUTH>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_AUTH),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_AUTH>())).hierarchy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_AUTH),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_AUTH>())).digest as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_AUTH),
            "::",
            stringify!(digest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_TK_HASHCHECK {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_HASHCHECK() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_TK_HASHCHECK>(),
        60usize,
        concat!("Size of: ", stringify!(TPMT_TK_HASHCHECK))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_TK_HASHCHECK>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_HASHCHECK))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_HASHCHECK>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_HASHCHECK),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_HASHCHECK>())).hierarchy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_HASHCHECK),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_TK_HASHCHECK>())).digest as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_HASHCHECK),
            "::",
            stringify!(digest)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_ALG_PROPERTY {
    pub alg: TPM_ALG_ID,
    pub algProperties: TPMA_ALGORITHM,
}
#[test]
fn bindgen_test_layout_TPMS_ALG_PROPERTY() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ALG_PROPERTY>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_ALG_PROPERTY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ALG_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_ALG_PROPERTY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALG_PROPERTY>())).alg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALG_PROPERTY),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_ALG_PROPERTY>())).algProperties as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALG_PROPERTY),
            "::",
            stringify!(algProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_TAGGED_PROPERTY {
    pub property: TPM_PT,
    pub value: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_PROPERTY() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_TAGGED_PROPERTY>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_TAGGED_PROPERTY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_TAGGED_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_TAGGED_PROPERTY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TAGGED_PROPERTY>())).property as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PROPERTY),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TAGGED_PROPERTY>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PROPERTY),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_TAGGED_PCR_SELECT {
    pub tag: TPM_PT_PCR,
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_PCR_SELECT() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_TAGGED_PCR_SELECT>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_TAGGED_PCR_SELECT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_TAGGED_PCR_SELECT>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_TAGGED_PCR_SELECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TAGGED_PCR_SELECT>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PCR_SELECT),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_TAGGED_PCR_SELECT>())).sizeofSelect as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PCR_SELECT),
            "::",
            stringify!(sizeofSelect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_TAGGED_PCR_SELECT>())).pcrSelect as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PCR_SELECT),
            "::",
            stringify!(pcrSelect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_TAGGED_POLICY {
    pub handle: TPM_HANDLE,
    pub policyHash: TPMT_HA,
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_POLICY() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_TAGGED_POLICY>(),
        56usize,
        concat!("Size of: ", stringify!(TPMS_TAGGED_POLICY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_TAGGED_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_TAGGED_POLICY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TAGGED_POLICY>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_POLICY),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TAGGED_POLICY>())).policyHash as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_POLICY),
            "::",
            stringify!(policyHash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_ACT_DATA {
    pub handle: TPM_HANDLE,
    pub timeout: UINT32,
    pub attributes: TPMA_ACT,
}
#[test]
fn bindgen_test_layout_TPMS_ACT_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ACT_DATA>(),
        12usize,
        concat!("Size of: ", stringify!(TPMS_ACT_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ACT_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_ACT_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ACT_DATA>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ACT_DATA),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ACT_DATA>())).timeout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ACT_DATA),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ACT_DATA>())).attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ACT_DATA),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_CC {
    pub count: UINT32,
    pub commandCodes: [TPM_CC; 254usize],
}
#[test]
fn bindgen_test_layout_TPML_CC() {
    assert_eq!(
        ::core::mem::size_of::<TPML_CC>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_CC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_CC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_CC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_CC>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CC),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_CC>())).commandCodes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CC),
            "::",
            stringify!(commandCodes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_CCA {
    pub count: UINT32,
    pub commandAttributes: [TPMA_CC; 254usize],
}
#[test]
fn bindgen_test_layout_TPML_CCA() {
    assert_eq!(
        ::core::mem::size_of::<TPML_CCA>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_CCA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_CCA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_CCA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_CCA>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CCA),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_CCA>())).commandAttributes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CCA),
            "::",
            stringify!(commandAttributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ALG {
    pub count: UINT32,
    pub algorithms: [TPM_ALG_ID; 64usize],
}
#[test]
fn bindgen_test_layout_TPML_ALG() {
    assert_eq!(
        ::core::mem::size_of::<TPML_ALG>(),
        132usize,
        concat!("Size of: ", stringify!(TPML_ALG))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_ALG>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ALG))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_ALG>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_ALG>())).algorithms as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG),
            "::",
            stringify!(algorithms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_HANDLE {
    pub count: UINT32,
    pub handle: [TPM_HANDLE; 254usize],
}
#[test]
fn bindgen_test_layout_TPML_HANDLE() {
    assert_eq!(
        ::core::mem::size_of::<TPML_HANDLE>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_HANDLE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_HANDLE>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_HANDLE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_HANDLE>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_HANDLE),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_HANDLE>())).handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_HANDLE),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct TPML_DIGEST {
    pub count: UINT32,
    pub digests: [TPM2B_DIGEST; 8usize],
}

#[test]
fn bindgen_test_layout_TPML_DIGEST() {
    assert_eq!(
        ::core::mem::size_of::<TPML_DIGEST>(),
        404usize,
        concat!("Size of: ", stringify!(TPML_DIGEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_DIGEST>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_DIGEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_DIGEST>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_DIGEST>())).digests as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST),
            "::",
            stringify!(digests)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPML_DIGEST_VALUES {
    pub count: UINT32,
    pub digests: [TPMT_HA; 3usize],
}
#[test]
fn bindgen_test_layout_TPML_DIGEST_VALUES() {
    assert_eq!(
        ::core::mem::size_of::<TPML_DIGEST_VALUES>(),
        156usize,
        concat!("Size of: ", stringify!(TPML_DIGEST_VALUES))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_DIGEST_VALUES>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_DIGEST_VALUES))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_DIGEST_VALUES>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST_VALUES),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_DIGEST_VALUES>())).digests as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST_VALUES),
            "::",
            stringify!(digests)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_PCR_SELECTION {
    pub count: UINT32,
    pub pcrSelections: [TPMS_PCR_SELECTION; 3usize],
}
#[test]
fn bindgen_test_layout_TPML_PCR_SELECTION() {
    assert_eq!(
        ::core::mem::size_of::<TPML_PCR_SELECTION>(),
        24usize,
        concat!("Size of: ", stringify!(TPML_PCR_SELECTION))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_PCR_SELECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_PCR_SELECTION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_PCR_SELECTION>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_PCR_SELECTION),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPML_PCR_SELECTION>())).pcrSelections as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_PCR_SELECTION),
            "::",
            stringify!(pcrSelections)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ALG_PROPERTY {
    pub count: UINT32,
    pub algProperties: [TPMS_ALG_PROPERTY; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_ALG_PROPERTY() {
    assert_eq!(
        ::core::mem::size_of::<TPML_ALG_PROPERTY>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_ALG_PROPERTY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_ALG_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ALG_PROPERTY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_ALG_PROPERTY>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG_PROPERTY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPML_ALG_PROPERTY>())).algProperties as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG_PROPERTY),
            "::",
            stringify!(algProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_TAGGED_TPM_PROPERTY {
    pub count: UINT32,
    pub tpmProperty: [TPMS_TAGGED_PROPERTY; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_TPM_PROPERTY() {
    assert_eq!(
        ::core::mem::size_of::<TPML_TAGGED_TPM_PROPERTY>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_TAGGED_TPM_PROPERTY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_TAGGED_TPM_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_TAGGED_TPM_PROPERTY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_TAGGED_TPM_PROPERTY>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_TPM_PROPERTY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPML_TAGGED_TPM_PROPERTY>())).tpmProperty as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_TPM_PROPERTY),
            "::",
            stringify!(tpmProperty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_TAGGED_PCR_PROPERTY {
    pub count: UINT32,
    pub pcrProperty: [TPMS_TAGGED_PCR_SELECT; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_PCR_PROPERTY() {
    assert_eq!(
        ::core::mem::size_of::<TPML_TAGGED_PCR_PROPERTY>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_TAGGED_PCR_PROPERTY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_TAGGED_PCR_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_TAGGED_PCR_PROPERTY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_TAGGED_PCR_PROPERTY>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_PCR_PROPERTY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPML_TAGGED_PCR_PROPERTY>())).pcrProperty as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_PCR_PROPERTY),
            "::",
            stringify!(pcrProperty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ECC_CURVE {
    pub count: UINT32,
    pub eccCurves: [TPM_ECC_CURVE; 508usize],
}
#[test]
fn bindgen_test_layout_TPML_ECC_CURVE() {
    assert_eq!(
        ::core::mem::size_of::<TPML_ECC_CURVE>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_ECC_CURVE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_ECC_CURVE>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ECC_CURVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_ECC_CURVE>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ECC_CURVE),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_ECC_CURVE>())).eccCurves as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ECC_CURVE),
            "::",
            stringify!(eccCurves)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPML_TAGGED_POLICY {
    pub count: UINT32,
    pub policies: [TPMS_TAGGED_POLICY; 18usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_POLICY() {
    assert_eq!(
        ::core::mem::size_of::<TPML_TAGGED_POLICY>(),
        1012usize,
        concat!("Size of: ", stringify!(TPML_TAGGED_POLICY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_TAGGED_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_TAGGED_POLICY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_TAGGED_POLICY>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_POLICY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_TAGGED_POLICY>())).policies as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_POLICY),
            "::",
            stringify!(policies)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ACT_DATA {
    pub count: UINT32,
    pub actData: [TPMS_ACT_DATA; 84usize],
}
#[test]
fn bindgen_test_layout_TPML_ACT_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPML_ACT_DATA>(),
        1012usize,
        concat!("Size of: ", stringify!(TPML_ACT_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_ACT_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ACT_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_ACT_DATA>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ACT_DATA),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_ACT_DATA>())).actData as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ACT_DATA),
            "::",
            stringify!(actData)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_CAPABILITIES {
    pub algorithms: TPML_ALG_PROPERTY,
    pub handles: TPML_HANDLE,
    pub command: TPML_CCA,
    pub ppCommands: TPML_CC,
    pub auditCommands: TPML_CC,
    pub assignedPCR: TPML_PCR_SELECTION,
    pub tpmProperties: TPML_TAGGED_TPM_PROPERTY,
    pub pcrProperties: TPML_TAGGED_PCR_PROPERTY,
    pub eccCurves: TPML_ECC_CURVE,
    pub authPolicies: TPML_TAGGED_POLICY,
    pub actData: TPML_ACT_DATA,
}
#[test]
fn bindgen_test_layout_TPMU_CAPABILITIES() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_CAPABILITIES>(),
        1020usize,
        concat!("Size of: ", stringify!(TPMU_CAPABILITIES))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMU_CAPABILITIES))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).algorithms as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(algorithms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).handles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).command as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).ppCommands as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(ppCommands)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).auditCommands as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(auditCommands)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).assignedPCR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(assignedPCR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).tpmProperties as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(tpmProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).pcrProperties as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(pcrProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).eccCurves as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(eccCurves)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).authPolicies as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(authPolicies)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_CAPABILITIES>())).actData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(actData)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_CAPABILITY_DATA {
    pub capability: TPM_CAP,
    pub data: TPMU_CAPABILITIES,
}
#[test]
fn bindgen_test_layout_TPMS_CAPABILITY_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_CAPABILITY_DATA>(),
        1024usize,
        concat!("Size of: ", stringify!(TPMS_CAPABILITY_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_CAPABILITY_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_CAPABILITY_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_CAPABILITY_DATA>())).capability as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CAPABILITY_DATA),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CAPABILITY_DATA>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CAPABILITY_DATA),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_CLOCK_INFO {
    pub clock: UINT64,
    pub resetCount: UINT32,
    pub restartCount: UINT32,
    pub safe: TPMI_YES_NO,
}
#[test]
fn bindgen_test_layout_TPMS_CLOCK_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_CLOCK_INFO>(),
        24usize,
        concat!("Size of: ", stringify!(TPMS_CLOCK_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_CLOCK_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_CLOCK_INFO))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CLOCK_INFO>())).clock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CLOCK_INFO>())).resetCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(resetCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CLOCK_INFO>())).restartCount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(restartCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CLOCK_INFO>())).safe as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(safe)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_TIME_INFO {
    pub time: UINT64,
    pub clockInfo: TPMS_CLOCK_INFO,
}
#[test]
fn bindgen_test_layout_TPMS_TIME_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_TIME_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(TPMS_TIME_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_TIME_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_TIME_INFO))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TIME_INFO>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_INFO),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TIME_INFO>())).clockInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_INFO),
            "::",
            stringify!(clockInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_TIME_ATTEST_INFO {
    pub time: TPMS_TIME_INFO,
    pub firmwareVersion: UINT64,
}
#[test]
fn bindgen_test_layout_TPMS_TIME_ATTEST_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_TIME_ATTEST_INFO>(),
        40usize,
        concat!("Size of: ", stringify!(TPMS_TIME_ATTEST_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_TIME_ATTEST_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_TIME_ATTEST_INFO))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_TIME_ATTEST_INFO>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_ATTEST_INFO),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_TIME_ATTEST_INFO>())).firmwareVersion as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_ATTEST_INFO),
            "::",
            stringify!(firmwareVersion)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_CERTIFY_INFO {
    pub name: TPM2B_NAME,
    pub qualifiedName: TPM2B_NAME,
}
#[test]
fn bindgen_test_layout_TPMS_CERTIFY_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_CERTIFY_INFO>(),
        108usize,
        concat!("Size of: ", stringify!(TPMS_CERTIFY_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_CERTIFY_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_CERTIFY_INFO))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CERTIFY_INFO>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CERTIFY_INFO),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_CERTIFY_INFO>())).qualifiedName as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CERTIFY_INFO),
            "::",
            stringify!(qualifiedName)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_QUOTE_INFO {
    pub pcrSelect: TPML_PCR_SELECTION,
    pub pcrDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_QUOTE_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_QUOTE_INFO>(),
        76usize,
        concat!("Size of: ", stringify!(TPMS_QUOTE_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_QUOTE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_QUOTE_INFO))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_QUOTE_INFO>())).pcrSelect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_QUOTE_INFO),
            "::",
            stringify!(pcrSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_QUOTE_INFO>())).pcrDigest as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_QUOTE_INFO),
            "::",
            stringify!(pcrDigest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_COMMAND_AUDIT_INFO {
    pub auditCounter: UINT64,
    pub digestAlg: TPM_ALG_ID,
    pub auditDigest: TPM2B_DIGEST,
    pub commandDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_COMMAND_AUDIT_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_COMMAND_AUDIT_INFO>(),
        112usize,
        concat!("Size of: ", stringify!(TPMS_COMMAND_AUDIT_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_COMMAND_AUDIT_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_COMMAND_AUDIT_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_COMMAND_AUDIT_INFO>())).auditCounter as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(auditCounter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_COMMAND_AUDIT_INFO>())).digestAlg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(digestAlg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_COMMAND_AUDIT_INFO>())).auditDigest as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(auditDigest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_COMMAND_AUDIT_INFO>())).commandDigest as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(commandDigest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_SESSION_AUDIT_INFO {
    pub exclusiveSession: TPMI_YES_NO,
    pub sessionDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_SESSION_AUDIT_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SESSION_AUDIT_INFO>(),
        52usize,
        concat!("Size of: ", stringify!(TPMS_SESSION_AUDIT_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SESSION_AUDIT_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SESSION_AUDIT_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_SESSION_AUDIT_INFO>())).exclusiveSession as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SESSION_AUDIT_INFO),
            "::",
            stringify!(exclusiveSession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_SESSION_AUDIT_INFO>())).sessionDigest as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SESSION_AUDIT_INFO),
            "::",
            stringify!(sessionDigest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_CREATION_INFO {
    pub objectName: TPM2B_NAME,
    pub creationHash: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_CREATION_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_CREATION_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(TPMS_CREATION_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_CREATION_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_CREATION_INFO))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CREATION_INFO>())).objectName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_INFO),
            "::",
            stringify!(objectName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_CREATION_INFO>())).creationHash as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_INFO),
            "::",
            stringify!(creationHash)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_NV_CERTIFY_INFO {
    pub indexName: TPM2B_NAME,
    pub offset: UINT16,
    pub nvContents: TPM2B_MAX_NV_BUFFER,
}
#[test]
fn bindgen_test_layout_TPMS_NV_CERTIFY_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_NV_CERTIFY_INFO>(),
        1082usize,
        concat!("Size of: ", stringify!(TPMS_NV_CERTIFY_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_NV_CERTIFY_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_NV_CERTIFY_INFO))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_NV_CERTIFY_INFO>())).indexName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_CERTIFY_INFO),
            "::",
            stringify!(indexName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_NV_CERTIFY_INFO>())).offset as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_CERTIFY_INFO),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_NV_CERTIFY_INFO>())).nvContents as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_CERTIFY_INFO),
            "::",
            stringify!(nvContents)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_NV_DIGEST_CERTIFY_INFO {
    pub indexName: TPM2B_NAME,
    pub nvDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_NV_DIGEST_CERTIFY_INFO() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_NV_DIGEST_CERTIFY_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(TPMS_NV_DIGEST_CERTIFY_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_NV_DIGEST_CERTIFY_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_NV_DIGEST_CERTIFY_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_NV_DIGEST_CERTIFY_INFO>())).indexName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_DIGEST_CERTIFY_INFO),
            "::",
            stringify!(indexName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_NV_DIGEST_CERTIFY_INFO>())).nvDigest as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_DIGEST_CERTIFY_INFO),
            "::",
            stringify!(nvDigest)
        )
    );
}
pub type TPMI_ST_ATTEST = TPM_ST;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_ATTEST {
    pub certify: TPMS_CERTIFY_INFO,
    pub creation: TPMS_CREATION_INFO,
    pub quote: TPMS_QUOTE_INFO,
    pub commandAudit: TPMS_COMMAND_AUDIT_INFO,
    pub sessionAudit: TPMS_SESSION_AUDIT_INFO,
    pub time: TPMS_TIME_ATTEST_INFO,
    pub nv: TPMS_NV_CERTIFY_INFO,
    pub nvDigest: TPMS_NV_DIGEST_CERTIFY_INFO,
}
#[test]
fn bindgen_test_layout_TPMU_ATTEST() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_ATTEST>(),
        1088usize,
        concat!("Size of: ", stringify!(TPMU_ATTEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_ATTEST>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMU_ATTEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).certify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(certify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).creation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(creation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).quote as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(quote)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).commandAudit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(commandAudit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).sessionAudit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(sessionAudit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).nv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(nv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ATTEST>())).nvDigest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(nvDigest)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ATTEST {
    pub magic: TPM_CONSTANTS32,
    pub type_: TPMI_ST_ATTEST,
    pub qualifiedSigner: TPM2B_NAME,
    pub extraData: TPM2B_DATA,
    pub clockInfo: TPMS_CLOCK_INFO,
    pub firmwareVersion: UINT64,
    pub attested: TPMU_ATTEST,
}
#[test]
fn bindgen_test_layout_TPMS_ATTEST() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ATTEST>(),
        1232usize,
        concat!("Size of: ", stringify!(TPMS_ATTEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ATTEST>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_ATTEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ATTEST>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ATTEST>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ATTEST>())).qualifiedSigner as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(qualifiedSigner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ATTEST>())).extraData as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(extraData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ATTEST>())).clockInfo as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(clockInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ATTEST>())).firmwareVersion as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(firmwareVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ATTEST>())).attested as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(attested)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_ATTEST {
    pub t: TPM2B_ATTEST__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ATTEST__bindgen_ty_1 {
    pub size: UINT16,
    pub attestationData: [BYTE; 1232usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ATTEST__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ATTEST__bindgen_ty_1>(),
        1234usize,
        concat!("Size of: ", stringify!(TPM2B_ATTEST__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ATTEST__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ATTEST__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ATTEST__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ATTEST__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ATTEST__bindgen_ty_1>())).attestationData as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ATTEST__bindgen_ty_1),
            "::",
            stringify!(attestationData)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_ATTEST() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ATTEST>(),
        1234usize,
        concat!("Size of: ", stringify!(TPM2B_ATTEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ATTEST>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ATTEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ATTEST>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ATTEST),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ATTEST>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ATTEST),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_AUTH_COMMAND {
    pub sessionHandle: TPMI_SH_AUTH_SESSION,
    pub nonce: TPM2B_NONCE,
    pub sessionAttributes: TPMA_SESSION,
    pub hmac: TPM2B_AUTH,
}
#[test]
fn bindgen_test_layout_TPMS_AUTH_COMMAND() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_AUTH_COMMAND>(),
        108usize,
        concat!("Size of: ", stringify!(TPMS_AUTH_COMMAND))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_AUTH_COMMAND>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_AUTH_COMMAND))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_AUTH_COMMAND>())).sessionHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(sessionHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_AUTH_COMMAND>())).nonce as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_AUTH_COMMAND>())).sessionAttributes as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(sessionAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_AUTH_COMMAND>())).hmac as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(hmac)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_AUTH_RESPONSE {
    pub nonce: TPM2B_NONCE,
    pub sessionAttributes: TPMA_SESSION,
    pub hmac: TPM2B_AUTH,
}
#[test]
fn bindgen_test_layout_TPMS_AUTH_RESPONSE() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_AUTH_RESPONSE>(),
        102usize,
        concat!("Size of: ", stringify!(TPMS_AUTH_RESPONSE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_AUTH_RESPONSE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_AUTH_RESPONSE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_AUTH_RESPONSE>())).nonce as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_RESPONSE),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_AUTH_RESPONSE>())).sessionAttributes as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_RESPONSE),
            "::",
            stringify!(sessionAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_AUTH_RESPONSE>())).hmac as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_RESPONSE),
            "::",
            stringify!(hmac)
        )
    );
}
pub type TPMI_TDES_KEY_BITS = TPM_KEY_BITS;
pub type TPMI_AES_KEY_BITS = TPM_KEY_BITS;
pub type TPMI_SM4_KEY_BITS = TPM_KEY_BITS;
pub type TPMI_CAMELLIA_KEY_BITS = TPM_KEY_BITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SYM_KEY_BITS {
    pub aes: TPMI_AES_KEY_BITS,
    pub camellia: TPMI_CAMELLIA_KEY_BITS,
    pub sym: TPM_KEY_BITS,
    pub xor: TPMI_ALG_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_SYM_KEY_BITS() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_SYM_KEY_BITS>(),
        2usize,
        concat!("Size of: ", stringify!(TPMU_SYM_KEY_BITS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_SYM_KEY_BITS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SYM_KEY_BITS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SYM_KEY_BITS>())).aes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(aes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SYM_KEY_BITS>())).camellia as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(camellia)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SYM_KEY_BITS>())).sym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SYM_KEY_BITS>())).xor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(xor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SYM_MODE {
    pub aes: TPMI_ALG_SYM_MODE,
    pub camellia: TPMI_ALG_SYM_MODE,
    pub sym: TPMI_ALG_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMU_SYM_MODE() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_SYM_MODE>(),
        2usize,
        concat!("Size of: ", stringify!(TPMU_SYM_MODE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_SYM_MODE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SYM_MODE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SYM_MODE>())).aes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_MODE),
            "::",
            stringify!(aes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SYM_MODE>())).camellia as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_MODE),
            "::",
            stringify!(camellia)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SYM_MODE>())).sym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_MODE),
            "::",
            stringify!(sym)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SYM_DEF {
    pub algorithm: TPMI_ALG_SYM,
    pub keyBits: TPMU_SYM_KEY_BITS,
    pub mode: TPMU_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMT_SYM_DEF() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_SYM_DEF>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_SYM_DEF))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_SYM_DEF>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SYM_DEF))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SYM_DEF>())).algorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SYM_DEF>())).keyBits as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF),
            "::",
            stringify!(keyBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SYM_DEF>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SYM_DEF_OBJECT {
    pub algorithm: TPMI_ALG_SYM_OBJECT,
    pub keyBits: TPMU_SYM_KEY_BITS,
    pub mode: TPMU_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMT_SYM_DEF_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_SYM_DEF_OBJECT>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_SYM_DEF_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_SYM_DEF_OBJECT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SYM_DEF_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SYM_DEF_OBJECT>())).algorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF_OBJECT),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SYM_DEF_OBJECT>())).keyBits as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF_OBJECT),
            "::",
            stringify!(keyBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SYM_DEF_OBJECT>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF_OBJECT),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_SYM_KEY {
    pub t: TPM2B_SYM_KEY__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SYM_KEY__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SYM_KEY__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SYM_KEY__bindgen_ty_1>(),
        34usize,
        concat!("Size of: ", stringify!(TPM2B_SYM_KEY__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SYM_KEY__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SYM_KEY__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SYM_KEY__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SYM_KEY__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SYM_KEY__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SYM_KEY__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_SYM_KEY() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SYM_KEY>(),
        34usize,
        concat!("Size of: ", stringify!(TPM2B_SYM_KEY))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SYM_KEY>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SYM_KEY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SYM_KEY>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SYM_KEY),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SYM_KEY>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SYM_KEY),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_SYMCIPHER_PARMS {
    pub sym: TPMT_SYM_DEF_OBJECT,
}
#[test]
fn bindgen_test_layout_TPMS_SYMCIPHER_PARMS() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SYMCIPHER_PARMS>(),
        6usize,
        concat!("Size of: ", stringify!(TPMS_SYMCIPHER_PARMS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SYMCIPHER_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SYMCIPHER_PARMS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SYMCIPHER_PARMS>())).sym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SYMCIPHER_PARMS),
            "::",
            stringify!(sym)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_LABEL {
    pub t: TPM2B_LABEL__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_LABEL__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_TPM2B_LABEL__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_LABEL__bindgen_ty_1>(),
        34usize,
        concat!("Size of: ", stringify!(TPM2B_LABEL__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_LABEL__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_LABEL__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_LABEL__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_LABEL__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_LABEL__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_LABEL__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_LABEL() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_LABEL>(),
        34usize,
        concat!("Size of: ", stringify!(TPM2B_LABEL))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_LABEL>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_LABEL))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_LABEL>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_LABEL),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_LABEL>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_LABEL),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_DERIVE {
    pub label: TPM2B_LABEL,
    pub context: TPM2B_LABEL,
}
#[test]
fn bindgen_test_layout_TPMS_DERIVE() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_DERIVE>(),
        68usize,
        concat!("Size of: ", stringify!(TPMS_DERIVE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_DERIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_DERIVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_DERIVE>())).label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_DERIVE),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_DERIVE>())).context as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_DERIVE),
            "::",
            stringify!(context)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_DERIVE {
    pub t: TPM2B_DERIVE__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_DERIVE__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 68usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DERIVE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_DERIVE__bindgen_ty_1>(),
        70usize,
        concat!("Size of: ", stringify!(TPM2B_DERIVE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_DERIVE__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DERIVE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_DERIVE__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DERIVE__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_DERIVE__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DERIVE__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_DERIVE() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_DERIVE>(),
        70usize,
        concat!("Size of: ", stringify!(TPM2B_DERIVE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_DERIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DERIVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_DERIVE>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DERIVE),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_DERIVE>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DERIVE),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SENSITIVE_CREATE {
    pub create: [BYTE; 128usize],
    pub derive: TPMS_DERIVE,
}
#[test]
fn bindgen_test_layout_TPMU_SENSITIVE_CREATE() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_SENSITIVE_CREATE>(),
        128usize,
        concat!("Size of: ", stringify!(TPMU_SENSITIVE_CREATE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_SENSITIVE_CREATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SENSITIVE_CREATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SENSITIVE_CREATE>())).create as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_CREATE),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SENSITIVE_CREATE>())).derive as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_CREATE),
            "::",
            stringify!(derive)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_SENSITIVE_DATA {
    pub t: TPM2B_SENSITIVE_DATA__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SENSITIVE_DATA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 128usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_DATA__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SENSITIVE_DATA__bindgen_ty_1>(),
        130usize,
        concat!("Size of: ", stringify!(TPM2B_SENSITIVE_DATA__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SENSITIVE_DATA__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_SENSITIVE_DATA__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SENSITIVE_DATA__bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_DATA__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SENSITIVE_DATA__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_DATA__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SENSITIVE_DATA>(),
        130usize,
        concat!("Size of: ", stringify!(TPM2B_SENSITIVE_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SENSITIVE_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SENSITIVE_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SENSITIVE_DATA>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_DATA),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SENSITIVE_DATA>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_DATA),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_SENSITIVE_CREATE {
    pub userAuth: TPM2B_AUTH,
    pub data: TPM2B_SENSITIVE_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_SENSITIVE_CREATE() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SENSITIVE_CREATE>(),
        180usize,
        concat!("Size of: ", stringify!(TPMS_SENSITIVE_CREATE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SENSITIVE_CREATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SENSITIVE_CREATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SENSITIVE_CREATE>())).userAuth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SENSITIVE_CREATE),
            "::",
            stringify!(userAuth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SENSITIVE_CREATE>())).data as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SENSITIVE_CREATE),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_SENSITIVE_CREATE {
    pub size: UINT16,
    pub sensitive: TPMS_SENSITIVE_CREATE,
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_CREATE() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SENSITIVE_CREATE>(),
        182usize,
        concat!("Size of: ", stringify!(TPM2B_SENSITIVE_CREATE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SENSITIVE_CREATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SENSITIVE_CREATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SENSITIVE_CREATE>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_CREATE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SENSITIVE_CREATE>())).sensitive as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_CREATE),
            "::",
            stringify!(sensitive)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_SCHEME_HASH {
    pub hashAlg: TPMI_ALG_HASH,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_HASH() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SCHEME_HASH>(),
        2usize,
        concat!("Size of: ", stringify!(TPMS_SCHEME_HASH))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SCHEME_HASH>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SCHEME_HASH))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SCHEME_HASH>())).hashAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_HASH),
            "::",
            stringify!(hashAlg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_SCHEME_ECDAA {
    pub hashAlg: TPMI_ALG_HASH,
    pub count: UINT16,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_ECDAA() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SCHEME_ECDAA>(),
        4usize,
        concat!("Size of: ", stringify!(TPMS_SCHEME_ECDAA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SCHEME_ECDAA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SCHEME_ECDAA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SCHEME_ECDAA>())).hashAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_ECDAA),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SCHEME_ECDAA>())).count as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_ECDAA),
            "::",
            stringify!(count)
        )
    );
}
pub type TPMI_ALG_KEYEDHASH_SCHEME = TPM_ALG_ID;
pub type TPMS_SCHEME_HMAC = TPMS_SCHEME_HASH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_SCHEME_XOR {
    pub hashAlg: TPMI_ALG_HASH,
    pub kdf: TPMI_ALG_KDF,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_XOR() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SCHEME_XOR>(),
        4usize,
        concat!("Size of: ", stringify!(TPMS_SCHEME_XOR))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SCHEME_XOR>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SCHEME_XOR))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SCHEME_XOR>())).hashAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_XOR),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SCHEME_XOR>())).kdf as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_XOR),
            "::",
            stringify!(kdf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SCHEME_KEYEDHASH {
    pub hmac: TPMS_SCHEME_HMAC,
    pub xor: TPMS_SCHEME_XOR,
}
#[test]
fn bindgen_test_layout_TPMU_SCHEME_KEYEDHASH() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_SCHEME_KEYEDHASH>(),
        4usize,
        concat!("Size of: ", stringify!(TPMU_SCHEME_KEYEDHASH))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_SCHEME_KEYEDHASH>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SCHEME_KEYEDHASH))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SCHEME_KEYEDHASH>())).hmac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SCHEME_KEYEDHASH),
            "::",
            stringify!(hmac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SCHEME_KEYEDHASH>())).xor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SCHEME_KEYEDHASH),
            "::",
            stringify!(xor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_KEYEDHASH_SCHEME {
    pub scheme: TPMI_ALG_KEYEDHASH_SCHEME,
    pub details: TPMU_SCHEME_KEYEDHASH,
}
#[test]
fn bindgen_test_layout_TPMT_KEYEDHASH_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_KEYEDHASH_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_KEYEDHASH_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_KEYEDHASH_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_KEYEDHASH_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_KEYEDHASH_SCHEME>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KEYEDHASH_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_KEYEDHASH_SCHEME>())).details as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KEYEDHASH_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
pub type TPMS_SIG_SCHEME_RSASSA = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_RSAPSS = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECDSA = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_SM2 = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECSCHNORR = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECDAA = TPMS_SCHEME_ECDAA;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SIG_SCHEME {
    pub ecdaa: TPMS_SIG_SCHEME_ECDAA,
    pub rsassa: TPMS_SIG_SCHEME_RSASSA,
    pub rsapss: TPMS_SIG_SCHEME_RSAPSS,
    pub ecdsa: TPMS_SIG_SCHEME_ECDSA,
    pub ecschnorr: TPMS_SIG_SCHEME_ECSCHNORR,
    pub hmac: TPMS_SCHEME_HMAC,
    pub any: TPMS_SCHEME_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_SIG_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_SIG_SCHEME>(),
        4usize,
        concat!("Size of: ", stringify!(TPMU_SIG_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_SIG_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SIG_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIG_SCHEME>())).ecdaa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(ecdaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIG_SCHEME>())).rsassa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(rsassa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIG_SCHEME>())).rsapss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(rsapss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIG_SCHEME>())).ecdsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(ecdsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIG_SCHEME>())).ecschnorr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(ecschnorr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIG_SCHEME>())).hmac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(hmac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIG_SCHEME>())).any as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(any)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SIG_SCHEME {
    pub scheme: TPMI_ALG_SIG_SCHEME,
    pub details: TPMU_SIG_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_SIG_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_SIG_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_SIG_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_SIG_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SIG_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SIG_SCHEME>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIG_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SIG_SCHEME>())).details as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIG_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
pub type TPMS_ENC_SCHEME_OAEP = TPMS_SCHEME_HASH;
pub type TPMS_ENC_SCHEME_RSAES = TPMS_EMPTY;
pub type TPMS_KEY_SCHEME_ECDH = TPMS_SCHEME_HASH;
pub type TPMS_KEY_SCHEME_ECMQV = TPMS_SCHEME_HASH;
pub type TPMS_KDF_SCHEME_MGF1 = TPMS_SCHEME_HASH;
pub type TPMS_KDF_SCHEME_KDF1_SP800_56A = TPMS_SCHEME_HASH;
pub type TPMS_KDF_SCHEME_KDF2 = TPMS_SCHEME_HASH;
pub type TPMS_KDF_SCHEME_KDF1_SP800_108 = TPMS_SCHEME_HASH;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_KDF_SCHEME {
    pub mgf1: TPMS_KDF_SCHEME_MGF1,
    pub kdf1_sp800_56a: TPMS_KDF_SCHEME_KDF1_SP800_56A,
    pub kdf2: TPMS_KDF_SCHEME_KDF2,
    pub kdf1_sp800_108: TPMS_KDF_SCHEME_KDF1_SP800_108,
    pub anyKdf: TPMS_SCHEME_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_KDF_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_KDF_SCHEME>(),
        2usize,
        concat!("Size of: ", stringify!(TPMU_KDF_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_KDF_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_KDF_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_KDF_SCHEME>())).mgf1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(mgf1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_KDF_SCHEME>())).kdf1_sp800_56a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(kdf1_sp800_56a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_KDF_SCHEME>())).kdf2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(kdf2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_KDF_SCHEME>())).kdf1_sp800_108 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(kdf1_sp800_108)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_KDF_SCHEME>())).anyKdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(anyKdf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_KDF_SCHEME {
    pub scheme: TPMI_ALG_KDF,
    pub details: TPMU_KDF_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_KDF_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_KDF_SCHEME>(),
        4usize,
        concat!("Size of: ", stringify!(TPMT_KDF_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_KDF_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_KDF_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_KDF_SCHEME>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KDF_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_KDF_SCHEME>())).details as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KDF_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
pub type TPMI_ALG_ASYM_SCHEME = TPM_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_ASYM_SCHEME {
    pub ecdh: TPMS_KEY_SCHEME_ECDH,
    pub ecdaa: TPMS_SIG_SCHEME_ECDAA,
    pub rsassa: TPMS_SIG_SCHEME_RSASSA,
    pub rsapss: TPMS_SIG_SCHEME_RSAPSS,
    pub ecdsa: TPMS_SIG_SCHEME_ECDSA,
    pub ecschnorr: TPMS_SIG_SCHEME_ECSCHNORR,
    pub rsaes: TPMS_ENC_SCHEME_RSAES,
    pub oaep: TPMS_ENC_SCHEME_OAEP,
    pub anySig: TPMS_SCHEME_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_ASYM_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_ASYM_SCHEME>(),
        4usize,
        concat!("Size of: ", stringify!(TPMU_ASYM_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_ASYM_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_ASYM_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).ecdh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecdh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).ecdaa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecdaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).rsassa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(rsassa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).rsapss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(rsapss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).ecdsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecdsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).ecschnorr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecschnorr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).rsaes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(rsaes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).oaep as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(oaep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ASYM_SCHEME>())).anySig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(anySig)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_ASYM_SCHEME {
    pub scheme: TPMI_ALG_ASYM_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_ASYM_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_ASYM_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_ASYM_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_ASYM_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_ASYM_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_ASYM_SCHEME>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ASYM_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_ASYM_SCHEME>())).details as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ASYM_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
pub type TPMI_ALG_RSA_SCHEME = TPM_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_RSA_SCHEME {
    pub scheme: TPMI_ALG_RSA_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_RSA_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_RSA_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_RSA_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_RSA_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_RSA_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_RSA_SCHEME>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_RSA_SCHEME>())).details as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
pub type TPMI_ALG_RSA_DECRYPT = TPM_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_RSA_DECRYPT {
    pub scheme: TPMI_ALG_RSA_DECRYPT,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_RSA_DECRYPT() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_RSA_DECRYPT>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_RSA_DECRYPT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_RSA_DECRYPT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_RSA_DECRYPT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_RSA_DECRYPT>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_DECRYPT),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_RSA_DECRYPT>())).details as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_DECRYPT),
            "::",
            stringify!(details)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_PUBLIC_KEY_RSA {
    pub t: TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 256usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1>(),
        258usize,
        concat!("Size of: ", stringify!(TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC_KEY_RSA() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PUBLIC_KEY_RSA>(),
        258usize,
        concat!("Size of: ", stringify!(TPM2B_PUBLIC_KEY_RSA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PUBLIC_KEY_RSA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PUBLIC_KEY_RSA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PUBLIC_KEY_RSA>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC_KEY_RSA),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PUBLIC_KEY_RSA>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC_KEY_RSA),
            "::",
            stringify!(b)
        )
    );
}
pub type TPMI_RSA_KEY_BITS = TPM_KEY_BITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_PRIVATE_KEY_RSA {
    pub t: TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 640usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1>(),
        642usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_KEY_RSA() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PRIVATE_KEY_RSA>(),
        642usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE_KEY_RSA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PRIVATE_KEY_RSA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PRIVATE_KEY_RSA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PRIVATE_KEY_RSA>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_KEY_RSA),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PRIVATE_KEY_RSA>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_KEY_RSA),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_ECC_PARAMETER {
    pub t: TPM2B_ECC_PARAMETER__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ECC_PARAMETER__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 48usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_PARAMETER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ECC_PARAMETER__bindgen_ty_1>(),
        50usize,
        concat!("Size of: ", stringify!(TPM2B_ECC_PARAMETER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ECC_PARAMETER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_ECC_PARAMETER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ECC_PARAMETER__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_PARAMETER__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ECC_PARAMETER__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_PARAMETER__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_PARAMETER() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ECC_PARAMETER>(),
        50usize,
        concat!("Size of: ", stringify!(TPM2B_ECC_PARAMETER))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ECC_PARAMETER>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ECC_PARAMETER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ECC_PARAMETER>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_PARAMETER),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ECC_PARAMETER>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_PARAMETER),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ECC_POINT {
    pub x: TPM2B_ECC_PARAMETER,
    pub y: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_ECC_POINT() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ECC_POINT>(),
        100usize,
        concat!("Size of: ", stringify!(TPMS_ECC_POINT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ECC_POINT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ECC_POINT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ECC_POINT>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_POINT),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ECC_POINT>())).y as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_POINT),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_ECC_POINT {
    pub size: UINT16,
    pub point: TPMS_ECC_POINT,
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_POINT() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ECC_POINT>(),
        102usize,
        concat!("Size of: ", stringify!(TPM2B_ECC_POINT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ECC_POINT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ECC_POINT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ECC_POINT>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_POINT),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ECC_POINT>())).point as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_POINT),
            "::",
            stringify!(point)
        )
    );
}
pub type TPMI_ALG_ECC_SCHEME = TPM_ALG_ID;
pub type TPMI_ECC_CURVE = TPM_ECC_CURVE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_ECC_SCHEME {
    pub scheme: TPMI_ALG_ECC_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_ECC_SCHEME() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_ECC_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_ECC_SCHEME))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_ECC_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_ECC_SCHEME))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_ECC_SCHEME>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ECC_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_ECC_SCHEME>())).details as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ECC_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ALGORITHM_DETAIL_ECC {
    pub curveID: TPM_ECC_CURVE,
    pub keySize: UINT16,
    pub kdf: TPMT_KDF_SCHEME,
    pub sign: TPMT_ECC_SCHEME,
    pub p: TPM2B_ECC_PARAMETER,
    pub a: TPM2B_ECC_PARAMETER,
    pub b: TPM2B_ECC_PARAMETER,
    pub gX: TPM2B_ECC_PARAMETER,
    pub gY: TPM2B_ECC_PARAMETER,
    pub n: TPM2B_ECC_PARAMETER,
    pub h: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_ALGORITHM_DETAIL_ECC() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ALGORITHM_DETAIL_ECC>(),
        364usize,
        concat!("Size of: ", stringify!(TPMS_ALGORITHM_DETAIL_ECC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ALGORITHM_DETAIL_ECC>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ALGORITHM_DETAIL_ECC))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).curveID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(curveID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).keySize as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(keySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).kdf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).sign as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).p as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).a as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).b as *const _ as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).gX as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(gX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).gY as *const _ as usize },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(gY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).n as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ALGORITHM_DETAIL_ECC>())).h as *const _ as usize },
        314usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_SIGNATURE_RSA {
    pub hash: TPMI_ALG_HASH,
    pub sig: TPM2B_PUBLIC_KEY_RSA,
}
#[test]
fn bindgen_test_layout_TPMS_SIGNATURE_RSA() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SIGNATURE_RSA>(),
        260usize,
        concat!("Size of: ", stringify!(TPMS_SIGNATURE_RSA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SIGNATURE_RSA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SIGNATURE_RSA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SIGNATURE_RSA>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_RSA),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SIGNATURE_RSA>())).sig as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_RSA),
            "::",
            stringify!(sig)
        )
    );
}
pub type TPMS_SIGNATURE_RSASSA = TPMS_SIGNATURE_RSA;
pub type TPMS_SIGNATURE_RSAPSS = TPMS_SIGNATURE_RSA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_SIGNATURE_ECC {
    pub hash: TPMI_ALG_HASH,
    pub signatureR: TPM2B_ECC_PARAMETER,
    pub signatureS: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_SIGNATURE_ECC() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_SIGNATURE_ECC>(),
        102usize,
        concat!("Size of: ", stringify!(TPMS_SIGNATURE_ECC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_SIGNATURE_ECC>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SIGNATURE_ECC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SIGNATURE_ECC>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_ECC),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SIGNATURE_ECC>())).signatureR as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_ECC),
            "::",
            stringify!(signatureR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_SIGNATURE_ECC>())).signatureS as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_ECC),
            "::",
            stringify!(signatureS)
        )
    );
}
pub type TPMS_SIGNATURE_ECDAA = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_ECDSA = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_SM2 = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_ECSCHNORR = TPMS_SIGNATURE_ECC;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SIGNATURE {
    pub ecdaa: TPMS_SIGNATURE_ECDAA,
    pub rsassa: TPMS_SIGNATURE_RSASSA,
    pub rsapss: TPMS_SIGNATURE_RSAPSS,
    pub ecdsa: TPMS_SIGNATURE_ECDSA,
    pub sm2: TPMS_SIGNATURE_SM2,
    pub ecschnorr: TPMS_SIGNATURE_ECSCHNORR,
    pub hmac: TPMT_HA,
    pub any: TPMS_SCHEME_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_SIGNATURE() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_SIGNATURE>(),
        260usize,
        concat!("Size of: ", stringify!(TPMU_SIGNATURE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_SIGNATURE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SIGNATURE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).ecdaa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(ecdaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).rsassa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(rsassa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).rsapss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(rsapss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).ecdsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(ecdsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).sm2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(sm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).ecschnorr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(ecschnorr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).hmac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(hmac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SIGNATURE>())).any as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(any)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SIGNATURE {
    pub sigAlg: TPMI_ALG_SIG_SCHEME,
    pub signature: TPMU_SIGNATURE,
}
#[test]
fn bindgen_test_layout_TPMT_SIGNATURE() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_SIGNATURE>(),
        262usize,
        concat!("Size of: ", stringify!(TPMT_SIGNATURE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_SIGNATURE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SIGNATURE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SIGNATURE>())).sigAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIGNATURE),
            "::",
            stringify!(sigAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SIGNATURE>())).signature as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIGNATURE),
            "::",
            stringify!(signature)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_ENCRYPTED_SECRET {
    pub ecc: [BYTE; 100usize],
    pub rsa: [BYTE; 256usize],
    pub symmetric: [BYTE; 50usize],
    pub keyedHash: [BYTE; 50usize],
}
#[test]
fn bindgen_test_layout_TPMU_ENCRYPTED_SECRET() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_ENCRYPTED_SECRET>(),
        256usize,
        concat!("Size of: ", stringify!(TPMU_ENCRYPTED_SECRET))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_ENCRYPTED_SECRET>(),
        1usize,
        concat!("Alignment of ", stringify!(TPMU_ENCRYPTED_SECRET))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ENCRYPTED_SECRET>())).ecc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(ecc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_ENCRYPTED_SECRET>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMU_ENCRYPTED_SECRET>())).symmetric as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMU_ENCRYPTED_SECRET>())).keyedHash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(keyedHash)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_ENCRYPTED_SECRET {
    pub t: TPM2B_ENCRYPTED_SECRET__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 {
    pub size: UINT16,
    pub secret: [BYTE; 256usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ENCRYPTED_SECRET__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ENCRYPTED_SECRET__bindgen_ty_1>(),
        258usize,
        concat!(
            "Size of: ",
            stringify!(TPM2B_ENCRYPTED_SECRET__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ENCRYPTED_SECRET__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_ENCRYPTED_SECRET__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ENCRYPTED_SECRET__bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ENCRYPTED_SECRET__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ENCRYPTED_SECRET__bindgen_ty_1>())).secret as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ENCRYPTED_SECRET__bindgen_ty_1),
            "::",
            stringify!(secret)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_ENCRYPTED_SECRET() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ENCRYPTED_SECRET>(),
        258usize,
        concat!("Size of: ", stringify!(TPM2B_ENCRYPTED_SECRET))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ENCRYPTED_SECRET>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ENCRYPTED_SECRET))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ENCRYPTED_SECRET>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ENCRYPTED_SECRET),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ENCRYPTED_SECRET>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ENCRYPTED_SECRET),
            "::",
            stringify!(b)
        )
    );
}
pub type TPMI_ALG_PUBLIC = TPM_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_PUBLIC_ID {
    pub keyedHash: TPM2B_DIGEST,
    pub sym: TPM2B_DIGEST,
    pub rsa: TPM2B_PUBLIC_KEY_RSA,
    pub ecc: TPMS_ECC_POINT,
    pub derive: TPMS_DERIVE,
}
#[test]
fn bindgen_test_layout_TPMU_PUBLIC_ID() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_PUBLIC_ID>(),
        258usize,
        concat!("Size of: ", stringify!(TPMU_PUBLIC_ID))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_PUBLIC_ID>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_PUBLIC_ID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_ID>())).keyedHash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(keyedHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_ID>())).sym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_ID>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_ID>())).ecc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(ecc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_ID>())).derive as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(derive)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_KEYEDHASH_PARMS {
    pub scheme: TPMT_KEYEDHASH_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_KEYEDHASH_PARMS() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_KEYEDHASH_PARMS>(),
        6usize,
        concat!("Size of: ", stringify!(TPMS_KEYEDHASH_PARMS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_KEYEDHASH_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_KEYEDHASH_PARMS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_KEYEDHASH_PARMS>())).scheme as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_KEYEDHASH_PARMS),
            "::",
            stringify!(scheme)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ASYM_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_ASYM_PARMS() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ASYM_PARMS>(),
        12usize,
        concat!("Size of: ", stringify!(TPMS_ASYM_PARMS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ASYM_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ASYM_PARMS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ASYM_PARMS>())).symmetric as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ASYM_PARMS),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ASYM_PARMS>())).scheme as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ASYM_PARMS),
            "::",
            stringify!(scheme)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_RSA_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_RSA_SCHEME,
    pub keyBits: TPMI_RSA_KEY_BITS,
    pub exponent: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_RSA_PARMS() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_RSA_PARMS>(),
        20usize,
        concat!("Size of: ", stringify!(TPMS_RSA_PARMS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_RSA_PARMS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_RSA_PARMS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_RSA_PARMS>())).symmetric as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_RSA_PARMS>())).scheme as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_RSA_PARMS>())).keyBits as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(keyBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_RSA_PARMS>())).exponent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ECC_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_ECC_SCHEME,
    pub curveID: TPMI_ECC_CURVE,
    pub kdf: TPMT_KDF_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_ECC_PARMS() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ECC_PARMS>(),
        18usize,
        concat!("Size of: ", stringify!(TPMS_ECC_PARMS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ECC_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ECC_PARMS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ECC_PARMS>())).symmetric as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ECC_PARMS>())).scheme as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ECC_PARMS>())).curveID as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(curveID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ECC_PARMS>())).kdf as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(kdf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_PUBLIC_PARMS {
    pub keyedHashDetail: TPMS_KEYEDHASH_PARMS,
    pub symDetail: TPMS_SYMCIPHER_PARMS,
    pub rsaDetail: TPMS_RSA_PARMS,
    pub eccDetail: TPMS_ECC_PARMS,
    pub asymDetail: TPMS_ASYM_PARMS,
}
#[test]
fn bindgen_test_layout_TPMU_PUBLIC_PARMS() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_PUBLIC_PARMS>(),
        20usize,
        concat!("Size of: ", stringify!(TPMU_PUBLIC_PARMS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_PUBLIC_PARMS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMU_PUBLIC_PARMS))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMU_PUBLIC_PARMS>())).keyedHashDetail as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(keyedHashDetail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_PARMS>())).symDetail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(symDetail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_PARMS>())).rsaDetail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(rsaDetail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_PARMS>())).eccDetail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(eccDetail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_PUBLIC_PARMS>())).asymDetail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(asymDetail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_PUBLIC_PARMS {
    pub type_: TPMI_ALG_PUBLIC,
    pub parameters: TPMU_PUBLIC_PARMS,
}
#[test]
fn bindgen_test_layout_TPMT_PUBLIC_PARMS() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_PUBLIC_PARMS>(),
        24usize,
        concat!("Size of: ", stringify!(TPMT_PUBLIC_PARMS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_PUBLIC_PARMS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_PUBLIC_PARMS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC_PARMS>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC_PARMS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC_PARMS>())).parameters as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC_PARMS),
            "::",
            stringify!(parameters)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_PUBLIC {
    pub type_: TPMI_ALG_PUBLIC,
    pub nameAlg: TPMI_ALG_HASH,
    pub objectAttributes: TPMA_OBJECT,
    pub authPolicy: TPM2B_DIGEST,
    pub parameters: TPMU_PUBLIC_PARMS,
    pub unique: TPMU_PUBLIC_ID,
}
#[test]
fn bindgen_test_layout_TPMT_PUBLIC() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_PUBLIC>(),
        340usize,
        concat!("Size of: ", stringify!(TPMT_PUBLIC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_PUBLIC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC>())).nameAlg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(nameAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC>())).objectAttributes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(objectAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC>())).authPolicy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(authPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC>())).parameters as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_PUBLIC>())).unique as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(unique)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_PUBLIC {
    pub size: UINT16,
    pub publicArea: TPMT_PUBLIC,
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PUBLIC>(),
        344usize,
        concat!("Size of: ", stringify!(TPM2B_PUBLIC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPM2B_PUBLIC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PUBLIC>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PUBLIC>())).publicArea as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC),
            "::",
            stringify!(publicArea)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_TEMPLATE {
    pub t: TPM2B_TEMPLATE__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_TEMPLATE__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 340usize],
}
#[test]
fn bindgen_test_layout_TPM2B_TEMPLATE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_TEMPLATE__bindgen_ty_1>(),
        342usize,
        concat!("Size of: ", stringify!(TPM2B_TEMPLATE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_TEMPLATE__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_TEMPLATE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_TEMPLATE__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TEMPLATE__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_TEMPLATE__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TEMPLATE__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_TEMPLATE() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_TEMPLATE>(),
        342usize,
        concat!("Size of: ", stringify!(TPM2B_TEMPLATE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_TEMPLATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_TEMPLATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_TEMPLATE>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TEMPLATE),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_TEMPLATE>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TEMPLATE),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_PRIVATE_VENDOR_SPECIFIC {
    pub t: TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 640usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1>(),
        642usize,
        concat!(
            "Size of: ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1>())).size
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1>())).buffer
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_VENDOR_SPECIFIC() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC>(),
        642usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE_VENDOR_SPECIFIC>())).t as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE_VENDOR_SPECIFIC>())).b as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SENSITIVE_COMPOSITE {
    pub rsa: TPM2B_PRIVATE_KEY_RSA,
    pub ecc: TPM2B_ECC_PARAMETER,
    pub bits: TPM2B_SENSITIVE_DATA,
    pub sym: TPM2B_SYM_KEY,
    pub any: TPM2B_PRIVATE_VENDOR_SPECIFIC,
}
#[test]
fn bindgen_test_layout_TPMU_SENSITIVE_COMPOSITE() {
    assert_eq!(
        ::core::mem::size_of::<TPMU_SENSITIVE_COMPOSITE>(),
        642usize,
        concat!("Size of: ", stringify!(TPMU_SENSITIVE_COMPOSITE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMU_SENSITIVE_COMPOSITE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SENSITIVE_COMPOSITE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SENSITIVE_COMPOSITE>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SENSITIVE_COMPOSITE>())).ecc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(ecc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SENSITIVE_COMPOSITE>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SENSITIVE_COMPOSITE>())).sym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMU_SENSITIVE_COMPOSITE>())).any as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(any)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SENSITIVE {
    pub sensitiveType: TPMI_ALG_PUBLIC,
    pub authValue: TPM2B_AUTH,
    pub seedValue: TPM2B_DIGEST,
    pub sensitive: TPMU_SENSITIVE_COMPOSITE,
}
#[test]
fn bindgen_test_layout_TPMT_SENSITIVE() {
    assert_eq!(
        ::core::mem::size_of::<TPMT_SENSITIVE>(),
        744usize,
        concat!("Size of: ", stringify!(TPMT_SENSITIVE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMT_SENSITIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SENSITIVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SENSITIVE>())).sensitiveType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(sensitiveType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SENSITIVE>())).authValue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(authValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SENSITIVE>())).seedValue as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(seedValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMT_SENSITIVE>())).sensitive as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(sensitive)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_SENSITIVE {
    pub size: UINT16,
    pub sensitiveArea: TPMT_SENSITIVE,
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SENSITIVE>(),
        746usize,
        concat!("Size of: ", stringify!(TPM2B_SENSITIVE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SENSITIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SENSITIVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SENSITIVE>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SENSITIVE>())).sensitiveArea as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE),
            "::",
            stringify!(sensitiveArea)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PRIVATE {
    pub integrityOuter: TPM2B_DIGEST,
    pub integrityInner: TPM2B_DIGEST,
    pub sensitive: TPM2B_SENSITIVE,
}
#[test]
fn bindgen_test_layout__PRIVATE() {
    assert_eq!(
        ::core::mem::size_of::<_PRIVATE>(),
        846usize,
        concat!("Size of: ", stringify!(_PRIVATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_PRIVATE>(),
        2usize,
        concat!("Alignment of ", stringify!(_PRIVATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PRIVATE>())).integrityOuter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVATE),
            "::",
            stringify!(integrityOuter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PRIVATE>())).integrityInner as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVATE),
            "::",
            stringify!(integrityInner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PRIVATE>())).sensitive as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVATE),
            "::",
            stringify!(sensitive)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_PRIVATE {
    pub t: TPM2B_PRIVATE__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PRIVATE__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 846usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PRIVATE__bindgen_ty_1>(),
        848usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PRIVATE__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PRIVATE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PRIVATE__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PRIVATE>(),
        848usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PRIVATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PRIVATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PRIVATE>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PRIVATE>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ID_OBJECT {
    pub integrityHMAC: TPM2B_DIGEST,
    pub encIdentity: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_ID_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_ID_OBJECT>(),
        100usize,
        concat!("Size of: ", stringify!(TPMS_ID_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_ID_OBJECT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ID_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ID_OBJECT>())).integrityHMAC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ID_OBJECT),
            "::",
            stringify!(integrityHMAC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_ID_OBJECT>())).encIdentity as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ID_OBJECT),
            "::",
            stringify!(encIdentity)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_ID_OBJECT {
    pub t: TPM2B_ID_OBJECT__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ID_OBJECT__bindgen_ty_1 {
    pub size: UINT16,
    pub credential: [BYTE; 100usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ID_OBJECT__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ID_OBJECT__bindgen_ty_1>(),
        102usize,
        concat!("Size of: ", stringify!(TPM2B_ID_OBJECT__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ID_OBJECT__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ID_OBJECT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ID_OBJECT__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ID_OBJECT__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_ID_OBJECT__bindgen_ty_1>())).credential as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ID_OBJECT__bindgen_ty_1),
            "::",
            stringify!(credential)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_ID_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_ID_OBJECT>(),
        102usize,
        concat!("Size of: ", stringify!(TPM2B_ID_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_ID_OBJECT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ID_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ID_OBJECT>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ID_OBJECT),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_ID_OBJECT>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ID_OBJECT),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM_NV_INDEX = UINT32;
pub type TPM_NT = UINT32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_NV_PIN_COUNTER_PARAMETERS {
    pub pinCount: UINT32,
    pub pinLimit: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_NV_PIN_COUNTER_PARAMETERS() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_NV_PIN_COUNTER_PARAMETERS>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_NV_PIN_COUNTER_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_NV_PIN_COUNTER_PARAMETERS>())).pinCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS),
            "::",
            stringify!(pinCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_NV_PIN_COUNTER_PARAMETERS>())).pinLimit as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS),
            "::",
            stringify!(pinLimit)
        )
    );
}
pub type TPMA_NV = UINT32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_NV_PUBLIC {
    pub nvIndex: TPMI_RH_NV_INDEX,
    pub nameAlg: TPMI_ALG_HASH,
    pub attributes: TPMA_NV,
    pub authPolicy: TPM2B_DIGEST,
    pub dataSize: UINT16,
}
#[test]
fn bindgen_test_layout_TPMS_NV_PUBLIC() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_NV_PUBLIC>(),
        64usize,
        concat!("Size of: ", stringify!(TPMS_NV_PUBLIC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_NV_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_NV_PUBLIC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_NV_PUBLIC>())).nvIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(nvIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_NV_PUBLIC>())).nameAlg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(nameAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_NV_PUBLIC>())).attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_NV_PUBLIC>())).authPolicy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(authPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_NV_PUBLIC>())).dataSize as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(dataSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_NV_PUBLIC {
    pub size: UINT16,
    pub nvPublic: TPMS_NV_PUBLIC,
}
#[test]
fn bindgen_test_layout_TPM2B_NV_PUBLIC() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_NV_PUBLIC>(),
        68usize,
        concat!("Size of: ", stringify!(TPM2B_NV_PUBLIC))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_NV_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPM2B_NV_PUBLIC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_NV_PUBLIC>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NV_PUBLIC),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_NV_PUBLIC>())).nvPublic as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NV_PUBLIC),
            "::",
            stringify!(nvPublic)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_CONTEXT_SENSITIVE {
    pub t: TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1344usize],
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1>(),
        1346usize,
        concat!(
            "Size of: ",
            stringify!(TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_SENSITIVE() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_CONTEXT_SENSITIVE>(),
        1346usize,
        concat!("Size of: ", stringify!(TPM2B_CONTEXT_SENSITIVE))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_CONTEXT_SENSITIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_CONTEXT_SENSITIVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_CONTEXT_SENSITIVE>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_SENSITIVE),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_CONTEXT_SENSITIVE>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_SENSITIVE),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_CONTEXT_DATA {
    pub integrity: TPM2B_DIGEST,
    pub encrypted: TPM2B_CONTEXT_SENSITIVE,
}
#[test]
fn bindgen_test_layout_TPMS_CONTEXT_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_CONTEXT_DATA>(),
        1396usize,
        concat!("Size of: ", stringify!(TPMS_CONTEXT_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_CONTEXT_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_CONTEXT_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CONTEXT_DATA>())).integrity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT_DATA),
            "::",
            stringify!(integrity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CONTEXT_DATA>())).encrypted as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT_DATA),
            "::",
            stringify!(encrypted)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_CONTEXT_DATA {
    pub t: TPM2B_CONTEXT_DATA__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_CONTEXT_DATA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1396usize],
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_DATA__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_CONTEXT_DATA__bindgen_ty_1>(),
        1398usize,
        concat!("Size of: ", stringify!(TPM2B_CONTEXT_DATA__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_CONTEXT_DATA__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_CONTEXT_DATA__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_CONTEXT_DATA__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_DATA__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_CONTEXT_DATA__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_DATA__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_CONTEXT_DATA>(),
        1398usize,
        concat!("Size of: ", stringify!(TPM2B_CONTEXT_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_CONTEXT_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_CONTEXT_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_CONTEXT_DATA>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_DATA),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_CONTEXT_DATA>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_DATA),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_CONTEXT {
    pub sequence: UINT64,
    pub savedHandle: TPMI_DH_SAVED,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub contextBlob: TPM2B_CONTEXT_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_CONTEXT() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_CONTEXT>(),
        1416usize,
        concat!("Size of: ", stringify!(TPMS_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CONTEXT>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CONTEXT>())).savedHandle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(savedHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CONTEXT>())).hierarchy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CONTEXT>())).contextBlob as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(contextBlob)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_CREATION_DATA {
    pub pcrSelect: TPML_PCR_SELECTION,
    pub pcrDigest: TPM2B_DIGEST,
    pub locality: TPMA_LOCALITY,
    pub parentNameAlg: TPM_ALG_ID,
    pub parentName: TPM2B_NAME,
    pub parentQualifiedName: TPM2B_NAME,
    pub outsideInfo: TPM2B_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_CREATION_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_CREATION_DATA>(),
        240usize,
        concat!("Size of: ", stringify!(TPMS_CREATION_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_CREATION_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_CREATION_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CREATION_DATA>())).pcrSelect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(pcrSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CREATION_DATA>())).pcrDigest as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(pcrDigest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CREATION_DATA>())).locality as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(locality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_CREATION_DATA>())).parentNameAlg as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(parentNameAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CREATION_DATA>())).parentName as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(parentName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPMS_CREATION_DATA>())).parentQualifiedName as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(parentQualifiedName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_CREATION_DATA>())).outsideInfo as *const _ as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(outsideInfo)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_CREATION_DATA {
    pub size: UINT16,
    pub creationData: TPMS_CREATION_DATA,
}
#[test]
fn bindgen_test_layout_TPM2B_CREATION_DATA() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_CREATION_DATA>(),
        244usize,
        concat!("Size of: ", stringify!(TPM2B_CREATION_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_CREATION_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPM2B_CREATION_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_CREATION_DATA>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CREATION_DATA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_CREATION_DATA>())).creationData as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CREATION_DATA),
            "::",
            stringify!(creationData)
        )
    );
}
pub type TPM_AT = UINT32;
pub type TPM_AE = UINT32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_AC_OUTPUT {
    pub tag: TPM_AT,
    pub data: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_AC_OUTPUT() {
    assert_eq!(
        ::core::mem::size_of::<TPMS_AC_OUTPUT>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_AC_OUTPUT))
    );
    assert_eq!(
        ::core::mem::align_of::<TPMS_AC_OUTPUT>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_AC_OUTPUT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_AC_OUTPUT>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AC_OUTPUT),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPMS_AC_OUTPUT>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AC_OUTPUT),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_AC_CAPABILITIES {
    pub count: UINT32,
    pub acCapabilities: [TPMS_AC_OUTPUT; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_AC_CAPABILITIES() {
    assert_eq!(
        ::core::mem::size_of::<TPML_AC_CAPABILITIES>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_AC_CAPABILITIES))
    );
    assert_eq!(
        ::core::mem::align_of::<TPML_AC_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_AC_CAPABILITIES))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPML_AC_CAPABILITIES>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_AC_CAPABILITIES),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPML_AC_CAPABILITIES>())).acCapabilities as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_AC_CAPABILITIES),
            "::",
            stringify!(acCapabilities)
        )
    );
}
pub type COMMAND_ATTRIBUTES = UINT16;
pub type ALGORITHM_VECTOR = [BYTE; 9usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_SELF_TEST_STATE {
    pub rng: UINT32,
    pub hash: UINT32,
    pub sym: UINT32,
    pub rsa: UINT32,
    pub ecc: UINT32,
}
#[test]
fn bindgen_test_layout_CRYPTO_SELF_TEST_STATE() {
    assert_eq!(
        ::core::mem::size_of::<CRYPTO_SELF_TEST_STATE>(),
        20usize,
        concat!("Size of: ", stringify!(CRYPTO_SELF_TEST_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYPTO_SELF_TEST_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYPTO_SELF_TEST_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYPTO_SELF_TEST_STATE>())).rng as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_SELF_TEST_STATE),
            "::",
            stringify!(rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYPTO_SELF_TEST_STATE>())).hash as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_SELF_TEST_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYPTO_SELF_TEST_STATE>())).sym as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_SELF_TEST_STATE),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYPTO_SELF_TEST_STATE>())).rsa as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_SELF_TEST_STATE),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYPTO_SELF_TEST_STATE>())).ecc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_SELF_TEST_STATE),
            "::",
            stringify!(ecc)
        )
    );
}
pub type crypt_uword_t = u64;
pub type crypt_word_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_t {
    pub allocated: crypt_uword_t,
    pub size: crypt_uword_t,
    pub d: [crypt_uword_t; 1usize],
}
#[test]
fn bindgen_test_layout_bignum_t() {
    assert_eq!(
        ::core::mem::size_of::<bignum_t>(),
        24usize,
        concat!("Size of: ", stringify!(bignum_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bignum_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bignum_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_t>())).allocated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_t),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_t>())).d as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_t),
            "::",
            stringify!(d)
        )
    );
}
pub type bigNum = *mut bignum_t;
pub type bigConst = *const bignum_t;
extern "C" {
    pub static BnConstZero: bignum_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bn_point_t {
    pub x: bigNum,
    pub y: bigNum,
    pub z: bigNum,
}
#[test]
fn bindgen_test_layout__bn_point_t() {
    assert_eq!(
        ::core::mem::size_of::<_bn_point_t>(),
        24usize,
        concat!("Size of: ", stringify!(_bn_point_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_bn_point_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_bn_point_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bn_point_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bn_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bn_point_t>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bn_point_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bn_point_t>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bn_point_t),
            "::",
            stringify!(z)
        )
    );
}
pub type bn_point_t = _bn_point_t;
pub type bigPoint = *mut bn_point_t;
pub type pointConst = *const bn_point_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct constant_point_t {
    pub x: bigConst,
    pub y: bigConst,
    pub z: bigConst,
}
#[test]
fn bindgen_test_layout_constant_point_t() {
    assert_eq!(
        ::core::mem::size_of::<constant_point_t>(),
        24usize,
        concat!("Size of: ", stringify!(constant_point_t))
    );
    assert_eq!(
        ::core::mem::align_of::<constant_point_t>(),
        8usize,
        concat!("Alignment of ", stringify!(constant_point_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<constant_point_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(constant_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<constant_point_t>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(constant_point_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<constant_point_t>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(constant_point_t),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_ecc_t {
    pub allocated: crypt_uword_t,
    pub size: crypt_uword_t,
    pub d: [crypt_uword_t; 7usize],
}
#[test]
fn bindgen_test_layout_bn_ecc_t() {
    assert_eq!(
        ::core::mem::size_of::<bn_ecc_t>(),
        72usize,
        concat!("Size of: ", stringify!(bn_ecc_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bn_ecc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_ecc_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_ecc_t>())).allocated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_ecc_t),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_ecc_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_ecc_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_ecc_t>())).d as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_ecc_t),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ECC_CURVE_DATA {
    pub prime: bigConst,
    pub order: bigConst,
    pub h: bigConst,
    pub a: bigConst,
    pub b: bigConst,
    pub base: constant_point_t,
}
#[test]
fn bindgen_test_layout_ECC_CURVE_DATA() {
    assert_eq!(
        ::core::mem::size_of::<ECC_CURVE_DATA>(),
        64usize,
        concat!("Size of: ", stringify!(ECC_CURVE_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<ECC_CURVE_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(ECC_CURVE_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE_DATA>())).prime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE_DATA),
            "::",
            stringify!(prime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE_DATA>())).order as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE_DATA),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE_DATA>())).h as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE_DATA),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE_DATA>())).a as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE_DATA),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE_DATA>())).b as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE_DATA),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE_DATA>())).base as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE_DATA),
            "::",
            stringify!(base)
        )
    );
}
extern "C" {
    pub fn ERR_load_EC_strings() -> crate::cty::c_int;
}
pub const point_conversion_form_t_POINT_CONVERSION_COMPRESSED: point_conversion_form_t = 2;
pub const point_conversion_form_t_POINT_CONVERSION_UNCOMPRESSED: point_conversion_form_t = 4;
pub const point_conversion_form_t_POINT_CONVERSION_HYBRID: point_conversion_form_t = 6;
pub type point_conversion_form_t = crate::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_method_st {
    _unused: [u8; 0],
}
pub type EC_METHOD = ec_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group_st {
    _unused: [u8; 0],
}
pub type EC_GROUP = ec_group_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_point_st {
    _unused: [u8; 0],
}
pub type EC_POINT = ec_point_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecpk_parameters_st {
    _unused: [u8; 0],
}
pub type ECPKPARAMETERS = ecpk_parameters_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_parameters_st {
    _unused: [u8; 0],
}
pub type ECPARAMETERS = ec_parameters_st;
extern "C" {
    pub fn EC_GFp_simple_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_mont_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nist_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nistp224_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nistp256_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nistp521_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GF2m_simple_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GROUP_new(meth: *const EC_METHOD) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_free(group: *mut EC_GROUP);
}
extern "C" {
    pub fn EC_GROUP_clear_free(group: *mut EC_GROUP);
}
extern "C" {
    pub fn EC_GROUP_copy(dst: *mut EC_GROUP, src: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_dup(src: *const EC_GROUP) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_method_of(group: *const EC_GROUP) -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_METHOD_get_field_type(meth: *const EC_METHOD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_generator(
        group: *mut EC_GROUP,
        generator: *const EC_POINT,
        order: *const BIGNUM,
        cofactor: *const BIGNUM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_generator(group: *const EC_GROUP) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_GROUP_get_mont_data(group: *const EC_GROUP) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn EC_GROUP_get_order(
        group: *const EC_GROUP,
        order: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_order(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_GROUP_order_bits(group: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_cofactor(
        group: *const EC_GROUP,
        cofactor: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_cofactor(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_GROUP_set_curve_name(group: *mut EC_GROUP, nid: crate::cty::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_asn1_flag(group: *mut EC_GROUP, flag: crate::cty::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_asn1_flag(group: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_point_conversion_form(group: *mut EC_GROUP, form: point_conversion_form_t);
}
extern "C" {
    pub fn EC_GROUP_get_point_conversion_form(arg1: *const EC_GROUP) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_GROUP_get0_seed(x: *const EC_GROUP) -> *mut crate::cty::c_uchar;
}
extern "C" {
    pub fn EC_GROUP_get_seed_len(arg1: *const EC_GROUP) -> size_t;
}
extern "C" {
    pub fn EC_GROUP_set_seed(
        arg1: *mut EC_GROUP,
        arg2: *const crate::cty::c_uchar,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn EC_GROUP_set_curve(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_curve_GFp(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GFp(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_curve_GF2m(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GF2m(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_degree(group: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_check(group: *const EC_GROUP, ctx: *mut BN_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_check_discriminant(
        group: *const EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_cmp(
        a: *const EC_GROUP,
        b: *const EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_new_curve_GFp(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_curve_GF2m(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_by_curve_name(nid: crate::cty::c_int) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_from_ecparameters(params: *const ECPARAMETERS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_get_ecparameters(
        group: *const EC_GROUP,
        params: *mut ECPARAMETERS,
    ) -> *mut ECPARAMETERS;
}
extern "C" {
    pub fn EC_GROUP_new_from_ecpkparameters(params: *const ECPKPARAMETERS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_get_ecpkparameters(
        group: *const EC_GROUP,
        params: *mut ECPKPARAMETERS,
    ) -> *mut ECPKPARAMETERS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EC_builtin_curve {
    pub nid: crate::cty::c_int,
    pub comment: *const crate::cty::c_char,
}
#[test]
fn bindgen_test_layout_EC_builtin_curve() {
    assert_eq!(
        ::core::mem::size_of::<EC_builtin_curve>(),
        16usize,
        concat!("Size of: ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        ::core::mem::align_of::<EC_builtin_curve>(),
        8usize,
        concat!("Alignment of ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EC_builtin_curve>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EC_builtin_curve>())).comment as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(comment)
        )
    );
}
extern "C" {
    pub fn EC_get_builtin_curves(r: *mut EC_builtin_curve, nitems: size_t) -> size_t;
}
extern "C" {
    pub fn EC_curve_nid2nist(nid: crate::cty::c_int) -> *const crate::cty::c_char;
}
extern "C" {
    pub fn EC_curve_nist2nid(name: *const crate::cty::c_char) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_new(group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_POINT_clear_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_POINT_copy(dst: *mut EC_POINT, src: *const EC_POINT) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_dup(src: *const EC_POINT, group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_method_of(point: *const EC_POINT) -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_POINT_set_to_infinity(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        z: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        z: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: crate::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_point2oct(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        form: point_conversion_form_t,
        buf: *mut crate::cty::c_uchar,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    pub fn EC_POINT_oct2point(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        buf: *const crate::cty::c_uchar,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_point2buf(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        pbuf: *mut *mut crate::cty::c_uchar,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    pub fn EC_POINT_point2bn(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BIGNUM,
        arg4: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn EC_POINT_bn2point(
        arg1: *const EC_GROUP,
        arg2: *const BIGNUM,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_point2hex(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BN_CTX,
    ) -> *mut crate::cty::c_char;
}
extern "C" {
    pub fn EC_POINT_hex2point(
        arg1: *const EC_GROUP,
        arg2: *const crate::cty::c_char,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_add(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_dbl(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_invert(
        group: *const EC_GROUP,
        a: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_is_at_infinity(group: *const EC_GROUP, p: *const EC_POINT)
        -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_is_on_curve(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_cmp(
        group: *const EC_GROUP,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_make_affine(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINTs_make_affine(
        group: *const EC_GROUP,
        num: size_t,
        points: *mut *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINTs_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        num: size_t,
        p: *mut *const EC_POINT,
        m: *mut *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        q: *const EC_POINT,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_precompute_mult(group: *mut EC_GROUP, ctx: *mut BN_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_have_precompute_mult(group: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub static ECPKPARAMETERS_it: ASN1_ITEM;
}
extern "C" {
    pub fn ECPKPARAMETERS_new() -> *mut ECPKPARAMETERS;
}
extern "C" {
    pub fn ECPKPARAMETERS_free(a: *mut ECPKPARAMETERS);
}
extern "C" {
    pub static ECPARAMETERS_it: ASN1_ITEM;
}
extern "C" {
    pub fn ECPARAMETERS_new() -> *mut ECPARAMETERS;
}
extern "C" {
    pub fn ECPARAMETERS_free(a: *mut ECPARAMETERS);
}
extern "C" {
    pub fn EC_GROUP_get_basis_type(arg1: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_trinomial_basis(
        arg1: *const EC_GROUP,
        k: *mut crate::cty::c_uint,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_pentanomial_basis(
        arg1: *const EC_GROUP,
        k1: *mut crate::cty::c_uint,
        k2: *mut crate::cty::c_uint,
        k3: *mut crate::cty::c_uint,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn d2i_ECPKParameters(
        arg1: *mut *mut EC_GROUP,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn i2d_ECPKParameters(
        arg1: *const EC_GROUP,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECPKParameters_print(
        bp: *mut BIO,
        x: *const EC_GROUP,
        off: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECPKParameters_print_fp(
        fp: *mut FILE,
        x: *const EC_GROUP,
        off: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_new() -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_get_flags(key: *const EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_set_flags(key: *mut EC_KEY, flags: crate::cty::c_int);
}
extern "C" {
    pub fn EC_KEY_clear_flags(key: *mut EC_KEY, flags: crate::cty::c_int);
}
extern "C" {
    pub fn EC_KEY_new_by_curve_name(nid: crate::cty::c_int) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_free(key: *mut EC_KEY);
}
extern "C" {
    pub fn EC_KEY_copy(dst: *mut EC_KEY, src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_dup(src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_engine(eckey: *const EC_KEY) -> *mut ENGINE;
}
extern "C" {
    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_private_key(key: *const EC_KEY) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_KEY_set_private_key(key: *mut EC_KEY, prv: *const BIGNUM) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_public_key(key: *const EC_KEY) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_KEY_set_public_key(key: *mut EC_KEY, pub_: *const EC_POINT) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get_enc_flags(key: *const EC_KEY) -> crate::cty::c_uint;
}
extern "C" {
    pub fn EC_KEY_set_enc_flags(eckey: *mut EC_KEY, flags: crate::cty::c_uint);
}
extern "C" {
    pub fn EC_KEY_get_conv_form(key: *const EC_KEY) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_KEY_set_conv_form(eckey: *mut EC_KEY, cform: point_conversion_form_t);
}
extern "C" {
    pub fn EC_KEY_set_ex_data(
        key: *mut EC_KEY,
        idx: crate::cty::c_int,
        arg: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get_ex_data(
        key: *const EC_KEY,
        idx: crate::cty::c_int,
    ) -> *mut crate::cty::c_void;
}
extern "C" {
    pub fn EC_KEY_set_asn1_flag(eckey: *mut EC_KEY, asn1_flag: crate::cty::c_int);
}
extern "C" {
    pub fn EC_KEY_precompute_mult(key: *mut EC_KEY, ctx: *mut BN_CTX) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_check_key(key: *const EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_can_sign(eckey: *const EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_set_public_key_affine_coordinates(
        key: *mut EC_KEY,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_key2buf(
        key: *const EC_KEY,
        form: point_conversion_form_t,
        pbuf: *mut *mut crate::cty::c_uchar,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    pub fn EC_KEY_oct2key(
        key: *mut EC_KEY,
        buf: *const crate::cty::c_uchar,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_oct2priv(
        key: *mut EC_KEY,
        buf: *const crate::cty::c_uchar,
        len: size_t,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_priv2oct(
        key: *const EC_KEY,
        buf: *mut crate::cty::c_uchar,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn EC_KEY_priv2buf(eckey: *const EC_KEY, pbuf: *mut *mut crate::cty::c_uchar) -> size_t;
}
extern "C" {
    pub fn d2i_ECPrivateKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey(
        key: *mut EC_KEY,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn d2i_ECParameters(
        key: *mut *mut EC_KEY,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECParameters(
        key: *mut EC_KEY,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn o2i_ECPublicKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2o_ECPublicKey(
        key: *const EC_KEY,
        out: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECParameters_print(bp: *mut BIO, key: *const EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_print(
        bp: *mut BIO,
        key: *const EC_KEY,
        off: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECParameters_print_fp(fp: *mut FILE, key: *const EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_print_fp(
        fp: *mut FILE,
        key: *const EC_KEY,
        off: crate::cty::c_int,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_OpenSSL() -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_get_default_method() -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_set_default_method(meth: *const EC_KEY_METHOD);
}
extern "C" {
    pub fn EC_KEY_get_method(key: *const EC_KEY) -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_set_method(key: *mut EC_KEY, meth: *const EC_KEY_METHOD) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_new_method(engine: *mut ENGINE) -> *mut EC_KEY;
}
extern "C" {
    pub fn ECDH_KDF_X9_62(
        out: *mut crate::cty::c_uchar,
        outlen: size_t,
        Z: *const crate::cty::c_uchar,
        Zlen: size_t,
        sinfo: *const crate::cty::c_uchar,
        sinfolen: size_t,
        md: *const EVP_MD,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECDH_compute_key(
        out: *mut crate::cty::c_void,
        outlen: size_t,
        pub_key: *const EC_POINT,
        ecdh: *const EC_KEY,
        KDF: ::core::option::Option<
            unsafe extern "C" fn(
                in_: *const crate::cty::c_void,
                inlen: size_t,
                out: *mut crate::cty::c_void,
                outlen: *mut size_t,
            ) -> *mut crate::cty::c_void,
        >,
    ) -> crate::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ECDSA_SIG_st {
    _unused: [u8; 0],
}
pub type ECDSA_SIG = ECDSA_SIG_st;
extern "C" {
    pub fn ECDSA_SIG_new() -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);
}
extern "C" {
    pub fn i2d_ECDSA_SIG(
        sig: *const ECDSA_SIG,
        pp: *mut *mut crate::cty::c_uchar,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn d2i_ECDSA_SIG(
        sig: *mut *mut ECDSA_SIG,
        pp: *mut *const crate::cty::c_uchar,
        len: crate::cty::c_long,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_get0(sig: *const ECDSA_SIG, pr: *mut *const BIGNUM, ps: *mut *const BIGNUM);
}
extern "C" {
    pub fn ECDSA_SIG_get0_r(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_get0_s(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_set0(sig: *mut ECDSA_SIG, r: *mut BIGNUM, s: *mut BIGNUM)
        -> crate::cty::c_int;
}
extern "C" {
    pub fn ECDSA_do_sign(
        dgst: *const crate::cty::c_uchar,
        dgst_len: crate::cty::c_int,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_do_sign_ex(
        dgst: *const crate::cty::c_uchar,
        dgstlen: crate::cty::c_int,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_do_verify(
        dgst: *const crate::cty::c_uchar,
        dgst_len: crate::cty::c_int,
        sig: *const ECDSA_SIG,
        eckey: *mut EC_KEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECDSA_sign_setup(
        eckey: *mut EC_KEY,
        ctx: *mut BN_CTX,
        kinv: *mut *mut BIGNUM,
        rp: *mut *mut BIGNUM,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECDSA_sign(
        type_: crate::cty::c_int,
        dgst: *const crate::cty::c_uchar,
        dgstlen: crate::cty::c_int,
        sig: *mut crate::cty::c_uchar,
        siglen: *mut crate::cty::c_uint,
        eckey: *mut EC_KEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECDSA_sign_ex(
        type_: crate::cty::c_int,
        dgst: *const crate::cty::c_uchar,
        dgstlen: crate::cty::c_int,
        sig: *mut crate::cty::c_uchar,
        siglen: *mut crate::cty::c_uint,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECDSA_verify(
        type_: crate::cty::c_int,
        dgst: *const crate::cty::c_uchar,
        dgstlen: crate::cty::c_int,
        sig: *const crate::cty::c_uchar,
        siglen: crate::cty::c_int,
        eckey: *mut EC_KEY,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ECDSA_size(eckey: *const EC_KEY) -> crate::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_METHOD_new(meth: *const EC_KEY_METHOD) -> *mut EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_METHOD_free(meth: *mut EC_KEY_METHOD);
}
extern "C" {
    pub fn EC_KEY_METHOD_set_init(
        meth: *mut EC_KEY_METHOD,
        init: ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> crate::cty::c_int>,
        finish: ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY)>,
        copy: ::core::option::Option<
            unsafe extern "C" fn(dest: *mut EC_KEY, src: *const EC_KEY) -> crate::cty::c_int,
        >,
        set_group: ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, grp: *const EC_GROUP) -> crate::cty::c_int,
        >,
        set_private: ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, priv_key: *const BIGNUM) -> crate::cty::c_int,
        >,
        set_public: ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, pub_key: *const EC_POINT) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_keygen(
        meth: *mut EC_KEY_METHOD,
        keygen: ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> crate::cty::c_int>,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_compute_key(
        meth: *mut EC_KEY_METHOD,
        ckey: ::core::option::Option<
            unsafe extern "C" fn(
                psec: *mut *mut crate::cty::c_uchar,
                pseclen: *mut size_t,
                pub_key: *const EC_POINT,
                ecdh: *const EC_KEY,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_sign(
        meth: *mut EC_KEY_METHOD,
        sign: ::core::option::Option<
            unsafe extern "C" fn(
                type_: crate::cty::c_int,
                dgst: *const crate::cty::c_uchar,
                dlen: crate::cty::c_int,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut crate::cty::c_uint,
                kinv: *const BIGNUM,
                r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> crate::cty::c_int,
        >,
        sign_setup: ::core::option::Option<
            unsafe extern "C" fn(
                eckey: *mut EC_KEY,
                ctx_in: *mut BN_CTX,
                kinvp: *mut *mut BIGNUM,
                rp: *mut *mut BIGNUM,
            ) -> crate::cty::c_int,
        >,
        sign_sig: ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const crate::cty::c_uchar,
                dgst_len: crate::cty::c_int,
                in_kinv: *const BIGNUM,
                in_r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> *mut ECDSA_SIG,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_verify(
        meth: *mut EC_KEY_METHOD,
        verify: ::core::option::Option<
            unsafe extern "C" fn(
                type_: crate::cty::c_int,
                dgst: *const crate::cty::c_uchar,
                dgst_len: crate::cty::c_int,
                sigbuf: *const crate::cty::c_uchar,
                sig_len: crate::cty::c_int,
                eckey: *mut EC_KEY,
            ) -> crate::cty::c_int,
        >,
        verify_sig: ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const crate::cty::c_uchar,
                dgst_len: crate::cty::c_int,
                sig: *const ECDSA_SIG,
                eckey: *mut EC_KEY,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_init(
        meth: *const EC_KEY_METHOD,
        pinit: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY) -> crate::cty::c_int,
        >,
        pfinish: *mut ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY)>,
        pcopy: *mut ::core::option::Option<
            unsafe extern "C" fn(dest: *mut EC_KEY, src: *const EC_KEY) -> crate::cty::c_int,
        >,
        pset_group: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, grp: *const EC_GROUP) -> crate::cty::c_int,
        >,
        pset_private: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, priv_key: *const BIGNUM) -> crate::cty::c_int,
        >,
        pset_public: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, pub_key: *const EC_POINT) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_keygen(
        meth: *const EC_KEY_METHOD,
        pkeygen: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_compute_key(
        meth: *const EC_KEY_METHOD,
        pck: *mut ::core::option::Option<
            unsafe extern "C" fn(
                psec: *mut *mut crate::cty::c_uchar,
                pseclen: *mut size_t,
                pub_key: *const EC_POINT,
                ecdh: *const EC_KEY,
            ) -> crate::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_sign(
        meth: *const EC_KEY_METHOD,
        psign: *mut ::core::option::Option<
            unsafe extern "C" fn(
                type_: crate::cty::c_int,
                dgst: *const crate::cty::c_uchar,
                dlen: crate::cty::c_int,
                sig: *mut crate::cty::c_uchar,
                siglen: *mut crate::cty::c_uint,
                kinv: *const BIGNUM,
                r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> crate::cty::c_int,
        >,
        psign_setup: *mut ::core::option::Option<
            unsafe extern "C" fn(
                eckey: *mut EC_KEY,
                ctx_in: *mut BN_CTX,
                kinvp: *mut *mut BIGNUM,
                rp: *mut *mut BIGNUM,
            ) -> crate::cty::c_int,
        >,
        psign_sig: *mut ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const crate::cty::c_uchar,
                dgst_len: crate::cty::c_int,
                in_kinv: *const BIGNUM,
                in_r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> *mut ECDSA_SIG,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_verify(
        meth: *const EC_KEY_METHOD,
        pverify: *mut ::core::option::Option<
            unsafe extern "C" fn(
                type_: crate::cty::c_int,
                dgst: *const crate::cty::c_uchar,
                dgst_len: crate::cty::c_int,
                sigbuf: *const crate::cty::c_uchar,
                sig_len: crate::cty::c_int,
                eckey: *mut EC_KEY,
            ) -> crate::cty::c_int,
        >,
        pverify_sig: *mut ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const crate::cty::c_uchar,
                dgst_len: crate::cty::c_int,
                sig: *const ECDSA_SIG,
                eckey: *mut EC_KEY,
            ) -> crate::cty::c_int,
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_st {
    pub d: *mut crate::cty::c_ulong,
    pub top: crate::cty::c_int,
    pub dmax: crate::cty::c_int,
    pub neg: crate::cty::c_int,
    pub flags: crate::cty::c_int,
}
#[test]
fn bindgen_test_layout_bignum_st() {
    assert_eq!(
        ::core::mem::size_of::<bignum_st>(),
        24usize,
        concat!("Size of: ", stringify!(bignum_st))
    );
    assert_eq!(
        ::core::mem::align_of::<bignum_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bignum_st))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_st>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_st>())).top as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_st>())).dmax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(dmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_st>())).neg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(neg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bignum_st>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSSL_CURVE_DATA {
    pub C: *const ECC_CURVE_DATA,
    pub G: *mut EC_GROUP,
    pub CTX: *mut BN_CTX,
}
#[test]
fn bindgen_test_layout_OSSL_CURVE_DATA() {
    assert_eq!(
        ::core::mem::size_of::<OSSL_CURVE_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(OSSL_CURVE_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<OSSL_CURVE_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(OSSL_CURVE_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSL_CURVE_DATA>())).C as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSL_CURVE_DATA),
            "::",
            stringify!(C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSL_CURVE_DATA>())).G as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSL_CURVE_DATA),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSL_CURVE_DATA>())).CTX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSL_CURVE_DATA),
            "::",
            stringify!(CTX)
        )
    );
}
pub type bigCurve = *mut OSSL_CURVE_DATA;
extern "C" {
    pub fn SupportLibInit() -> crate::cty::c_int;
}
extern "C" {
    pub fn OsslContextEnter() -> *mut BN_CTX;
}
extern "C" {
    pub fn OsslContextLeave(CTX: *mut BN_CTX);
}
extern "C" {
    pub fn OsslPushContext(CTX: *mut BN_CTX) -> *mut BN_CTX;
}
extern "C" {
    pub fn OsslPopContext(CTX: *mut BN_CTX);
}
pub type SMAC_DATA_METHOD = ::core::option::Option<
    unsafe extern "C" fn(state: *mut SMAC_STATES, size: UINT32, buffer: *const BYTE),
>;
pub type SMAC_END_METHOD = ::core::option::Option<
    unsafe extern "C" fn(state: *mut SMAC_STATES, size: UINT32, buffer: *mut BYTE) -> UINT16,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sequenceMethods {
    pub data: SMAC_DATA_METHOD,
    pub end: SMAC_END_METHOD,
}
#[test]
fn bindgen_test_layout_sequenceMethods() {
    assert_eq!(
        ::core::mem::size_of::<sequenceMethods>(),
        16usize,
        concat!("Size of: ", stringify!(sequenceMethods))
    );
    assert_eq!(
        ::core::mem::align_of::<sequenceMethods>(),
        8usize,
        concat!("Alignment of ", stringify!(sequenceMethods))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sequenceMethods>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sequenceMethods),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sequenceMethods>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sequenceMethods),
            "::",
            stringify!(end)
        )
    );
}
pub type SMAC_METHODS = sequenceMethods;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpmCmacState {
    pub symAlg: TPM_ALG_ID,
    pub keySizeBits: UINT16,
    pub bcount: INT16,
    pub iv: TPM2B_IV,
    pub symKey: TPM2B_SYM_KEY,
}
#[test]
fn bindgen_test_layout_tpmCmacState() {
    assert_eq!(
        ::core::mem::size_of::<tpmCmacState>(),
        58usize,
        concat!("Size of: ", stringify!(tpmCmacState))
    );
    assert_eq!(
        ::core::mem::align_of::<tpmCmacState>(),
        2usize,
        concat!("Alignment of ", stringify!(tpmCmacState))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tpmCmacState>())).symAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCmacState),
            "::",
            stringify!(symAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tpmCmacState>())).keySizeBits as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCmacState),
            "::",
            stringify!(keySizeBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tpmCmacState>())).bcount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCmacState),
            "::",
            stringify!(bcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tpmCmacState>())).iv as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCmacState),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tpmCmacState>())).symKey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCmacState),
            "::",
            stringify!(symKey)
        )
    );
}
pub type tpmCmacState_t = tpmCmacState;
#[repr(C)]
#[derive(Copy, Clone)]
pub union SMAC_STATES {
    pub cmac: tpmCmacState_t,
    pub pad: UINT64,
}
#[test]
fn bindgen_test_layout_SMAC_STATES() {
    assert_eq!(
        ::core::mem::size_of::<SMAC_STATES>(),
        64usize,
        concat!("Size of: ", stringify!(SMAC_STATES))
    );
    assert_eq!(
        ::core::mem::align_of::<SMAC_STATES>(),
        8usize,
        concat!("Alignment of ", stringify!(SMAC_STATES))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMAC_STATES>())).cmac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMAC_STATES),
            "::",
            stringify!(cmac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMAC_STATES>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMAC_STATES),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SMAC_STATE {
    pub smacMethods: SMAC_METHODS,
    pub state: SMAC_STATES,
}
#[test]
fn bindgen_test_layout_SMAC_STATE() {
    assert_eq!(
        ::core::mem::size_of::<SMAC_STATE>(),
        80usize,
        concat!("Size of: ", stringify!(SMAC_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<SMAC_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(SMAC_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMAC_STATE>())).smacMethods as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMAC_STATE),
            "::",
            stringify!(smacMethods)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMAC_STATE>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SMAC_STATE),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ANY_HASH_STATE {
    pub Sha1: SHA_CTX,
    pub Sha256: SHA256_CTX,
    pub Sha384: SHA512_CTX,
    pub smac: SMAC_STATE,
    pub align: u64,
}
#[test]
fn bindgen_test_layout_ANY_HASH_STATE() {
    assert_eq!(
        ::core::mem::size_of::<ANY_HASH_STATE>(),
        216usize,
        concat!("Size of: ", stringify!(ANY_HASH_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<ANY_HASH_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(ANY_HASH_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ANY_HASH_STATE>())).Sha1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANY_HASH_STATE),
            "::",
            stringify!(Sha1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ANY_HASH_STATE>())).Sha256 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANY_HASH_STATE),
            "::",
            stringify!(Sha256)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ANY_HASH_STATE>())).Sha384 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANY_HASH_STATE),
            "::",
            stringify!(Sha384)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ANY_HASH_STATE>())).smac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANY_HASH_STATE),
            "::",
            stringify!(smac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ANY_HASH_STATE>())).align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANY_HASH_STATE),
            "::",
            stringify!(align)
        )
    );
}
pub type PANY_HASH_STATE = *mut ANY_HASH_STATE;
pub type PCANY_HASH_STATE = *const ANY_HASH_STATE;
pub type ALIGNED_HASH_STATE = ANY_HASH_STATE;
pub type HASH_START_METHOD = ::core::option::Option<unsafe extern "C" fn()>;
pub type HASH_DATA_METHOD = ::core::option::Option<unsafe extern "C" fn()>;
pub type HASH_END_METHOD = ::core::option::Option<unsafe extern "C" fn()>;
pub type HASH_STATE_COPY_METHOD = ::core::option::Option<unsafe extern "C" fn()>;
pub type HASH_STATE_EXPORT_METHOD = ::core::option::Option<unsafe extern "C" fn()>;
pub type HASH_STATE_IMPORT_METHOD = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HASH_METHODS {
    pub start: HASH_START_METHOD,
    pub data: HASH_DATA_METHOD,
    pub end: HASH_END_METHOD,
    pub copy: HASH_STATE_COPY_METHOD,
    pub copyOut: HASH_STATE_EXPORT_METHOD,
    pub copyIn: HASH_STATE_IMPORT_METHOD,
}
#[test]
fn bindgen_test_layout__HASH_METHODS() {
    assert_eq!(
        ::core::mem::size_of::<_HASH_METHODS>(),
        48usize,
        concat!("Size of: ", stringify!(_HASH_METHODS))
    );
    assert_eq!(
        ::core::mem::align_of::<_HASH_METHODS>(),
        8usize,
        concat!("Alignment of ", stringify!(_HASH_METHODS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_METHODS>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_METHODS),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_METHODS>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_METHODS),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_METHODS>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_METHODS),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_METHODS>())).copy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_METHODS),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_METHODS>())).copyOut as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_METHODS),
            "::",
            stringify!(copyOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_METHODS>())).copyIn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_METHODS),
            "::",
            stringify!(copyIn)
        )
    );
}
pub type HASH_METHODS = _HASH_METHODS;
pub type PHASH_METHODS = *mut _HASH_METHODS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_SHA1_DIGEST {
    pub t: TPM2B_SHA1_DIGEST__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SHA1_DIGEST__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SHA1_DIGEST__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SHA1_DIGEST__bindgen_ty_1>(),
        22usize,
        concat!("Size of: ", stringify!(TPM2B_SHA1_DIGEST__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SHA1_DIGEST__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SHA1_DIGEST__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SHA1_DIGEST__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA1_DIGEST__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SHA1_DIGEST__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA1_DIGEST__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_SHA1_DIGEST() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SHA1_DIGEST>(),
        22usize,
        concat!("Size of: ", stringify!(TPM2B_SHA1_DIGEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SHA1_DIGEST>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SHA1_DIGEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SHA1_DIGEST>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA1_DIGEST),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SHA1_DIGEST>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA1_DIGEST),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_SHA256_DIGEST {
    pub t: TPM2B_SHA256_DIGEST__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SHA256_DIGEST__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SHA256_DIGEST__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SHA256_DIGEST__bindgen_ty_1>(),
        34usize,
        concat!("Size of: ", stringify!(TPM2B_SHA256_DIGEST__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SHA256_DIGEST__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_SHA256_DIGEST__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SHA256_DIGEST__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA256_DIGEST__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SHA256_DIGEST__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA256_DIGEST__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_SHA256_DIGEST() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SHA256_DIGEST>(),
        34usize,
        concat!("Size of: ", stringify!(TPM2B_SHA256_DIGEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SHA256_DIGEST>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SHA256_DIGEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SHA256_DIGEST>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA256_DIGEST),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SHA256_DIGEST>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA256_DIGEST),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_SHA384_DIGEST {
    pub t: TPM2B_SHA384_DIGEST__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SHA384_DIGEST__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 48usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SHA384_DIGEST__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SHA384_DIGEST__bindgen_ty_1>(),
        50usize,
        concat!("Size of: ", stringify!(TPM2B_SHA384_DIGEST__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SHA384_DIGEST__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TPM2B_SHA384_DIGEST__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SHA384_DIGEST__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA384_DIGEST__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SHA384_DIGEST__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA384_DIGEST__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_SHA384_DIGEST() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SHA384_DIGEST>(),
        50usize,
        concat!("Size of: ", stringify!(TPM2B_SHA384_DIGEST))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SHA384_DIGEST>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SHA384_DIGEST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SHA384_DIGEST>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA384_DIGEST),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SHA384_DIGEST>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SHA384_DIGEST),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASH_DEF {
    pub method: HASH_METHODS,
    pub blockSize: u16,
    pub digestSize: u16,
    pub contextSize: u16,
    pub hashAlg: u16,
    pub OID: *const BYTE,
    pub PKCS1: *const BYTE,
    pub ECDSA: *const BYTE,
}
#[test]
fn bindgen_test_layout_HASH_DEF() {
    assert_eq!(
        ::core::mem::size_of::<HASH_DEF>(),
        80usize,
        concat!("Size of: ", stringify!(HASH_DEF))
    );
    assert_eq!(
        ::core::mem::align_of::<HASH_DEF>(),
        8usize,
        concat!("Alignment of ", stringify!(HASH_DEF))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).blockSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).digestSize as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(digestSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).contextSize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(contextSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).hashAlg as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).OID as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(OID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).PKCS1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(PKCS1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_DEF>())).ECDSA as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_DEF),
            "::",
            stringify!(ECDSA)
        )
    );
}
pub type PHASH_DEF = *const HASH_DEF;
pub type HASH_STATE_TYPE = BYTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HASH_STATE {
    pub type_: HASH_STATE_TYPE,
    pub hashAlg: TPM_ALG_ID,
    pub def: PHASH_DEF,
    pub state: ANY_HASH_STATE,
}
#[test]
fn bindgen_test_layout__HASH_STATE() {
    assert_eq!(
        ::core::mem::size_of::<_HASH_STATE>(),
        232usize,
        concat!("Size of: ", stringify!(_HASH_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_HASH_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(_HASH_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_STATE>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_STATE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_STATE>())).hashAlg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_STATE),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_STATE>())).def as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_STATE),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_HASH_STATE>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_HASH_STATE),
            "::",
            stringify!(state)
        )
    );
}
pub type HASH_STATE = _HASH_STATE;
pub type PHASH_STATE = *mut _HASH_STATE;
pub type PCHASH_STATE = *const HASH_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hmacState {
    pub hashState: HASH_STATE,
    pub hmacKey: TPM2B_HASH_BLOCK,
}
#[test]
fn bindgen_test_layout_hmacState() {
    assert_eq!(
        ::core::mem::size_of::<hmacState>(),
        368usize,
        concat!("Size of: ", stringify!(hmacState))
    );
    assert_eq!(
        ::core::mem::align_of::<hmacState>(),
        8usize,
        concat!("Alignment of ", stringify!(hmacState))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmacState>())).hashState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmacState),
            "::",
            stringify!(hashState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmacState>())).hmacKey as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(hmacState),
            "::",
            stringify!(hmacKey)
        )
    );
}
pub type HMAC_STATE = hmacState;
pub type PHMAC_STATE = *mut hmacState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXPORT_HASH_STATE {
    pub buffer: [BYTE; 232usize],
}
#[test]
fn bindgen_test_layout_EXPORT_HASH_STATE() {
    assert_eq!(
        ::core::mem::size_of::<EXPORT_HASH_STATE>(),
        232usize,
        concat!("Size of: ", stringify!(EXPORT_HASH_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<EXPORT_HASH_STATE>(),
        1usize,
        concat!("Alignment of ", stringify!(EXPORT_HASH_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXPORT_HASH_STATE>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXPORT_HASH_STATE),
            "::",
            stringify!(buffer)
        )
    );
}
pub type PEXPORT_HASH_STATE = *mut EXPORT_HASH_STATE;
pub type PCEXPORT_HASH_STATE = *const EXPORT_HASH_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpmCryptKeySchedule_t {
    pub aes: AES_KEY,
    pub camellia: CAMELLIA_KEY,
    pub alignment: u64,
}
#[test]
fn bindgen_test_layout_tpmCryptKeySchedule_t() {
    assert_eq!(
        ::core::mem::size_of::<tpmCryptKeySchedule_t>(),
        280usize,
        concat!("Size of: ", stringify!(tpmCryptKeySchedule_t))
    );
    assert_eq!(
        ::core::mem::align_of::<tpmCryptKeySchedule_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tpmCryptKeySchedule_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tpmCryptKeySchedule_t>())).aes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCryptKeySchedule_t),
            "::",
            stringify!(aes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tpmCryptKeySchedule_t>())).camellia as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCryptKeySchedule_t),
            "::",
            stringify!(camellia)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tpmCryptKeySchedule_t>())).alignment as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tpmCryptKeySchedule_t),
            "::",
            stringify!(alignment)
        )
    );
}
pub type DRBG_KEY_SCHEDULE = AES_KEY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union DRBG_KEY {
    pub bytes: [BYTE; 32usize],
    pub words: [crypt_uword_t; 4usize],
}
#[test]
fn bindgen_test_layout_DRBG_KEY() {
    assert_eq!(
        ::core::mem::size_of::<DRBG_KEY>(),
        32usize,
        concat!("Size of: ", stringify!(DRBG_KEY))
    );
    assert_eq!(
        ::core::mem::align_of::<DRBG_KEY>(),
        8usize,
        concat!("Alignment of ", stringify!(DRBG_KEY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_KEY>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_KEY),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_KEY>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_KEY),
            "::",
            stringify!(words)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DRBG_IV {
    pub bytes: [BYTE; 16usize],
    pub words: [crypt_uword_t; 2usize],
}
#[test]
fn bindgen_test_layout_DRBG_IV() {
    assert_eq!(
        ::core::mem::size_of::<DRBG_IV>(),
        16usize,
        concat!("Size of: ", stringify!(DRBG_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<DRBG_IV>(),
        8usize,
        concat!("Alignment of ", stringify!(DRBG_IV))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_IV>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_IV),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_IV>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_IV),
            "::",
            stringify!(words)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DRBG_SEED {
    pub bytes: [BYTE; 48usize],
    pub words: [crypt_uword_t; 6usize],
}
#[test]
fn bindgen_test_layout_DRBG_SEED() {
    assert_eq!(
        ::core::mem::size_of::<DRBG_SEED>(),
        48usize,
        concat!("Size of: ", stringify!(DRBG_SEED))
    );
    assert_eq!(
        ::core::mem::align_of::<DRBG_SEED>(),
        8usize,
        concat!("Alignment of ", stringify!(DRBG_SEED))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_SEED>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_SEED),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_SEED>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_SEED),
            "::",
            stringify!(words)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DRBG_STATE {
    pub reseedCounter: UINT64,
    pub magic: UINT32,
    pub seed: DRBG_SEED,
    pub lastValue: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout_DRBG_STATE() {
    assert_eq!(
        ::core::mem::size_of::<DRBG_STATE>(),
        80usize,
        concat!("Size of: ", stringify!(DRBG_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<DRBG_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(DRBG_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_STATE>())).reseedCounter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_STATE),
            "::",
            stringify!(reseedCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_STATE>())).magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_STATE>())).seed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_STATE),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DRBG_STATE>())).lastValue as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DRBG_STATE),
            "::",
            stringify!(lastValue)
        )
    );
}
pub type pDRBG_STATE = *mut DRBG_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KDF_STATE {
    pub counter: UINT64,
    pub magic: UINT32,
    pub limit: UINT32,
    pub seed: *mut TPM2B,
    pub label: *const TPM2B,
    pub context: *mut TPM2B,
    pub hash: TPM_ALG_ID,
    pub kdf: TPM_ALG_ID,
    pub digestSize: UINT16,
    pub residual: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_KDF_STATE() {
    assert_eq!(
        ::core::mem::size_of::<KDF_STATE>(),
        96usize,
        concat!("Size of: ", stringify!(KDF_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<KDF_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(KDF_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).limit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).seed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).label as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).context as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).hash as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).kdf as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).digestSize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(digestSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KDF_STATE>())).residual as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(KDF_STATE),
            "::",
            stringify!(residual)
        )
    );
}
pub type pKDR_STATE = *mut KDF_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union RAND_STATE {
    pub drbg: DRBG_STATE,
    pub kdf: KDF_STATE,
}
#[test]
fn bindgen_test_layout_RAND_STATE() {
    assert_eq!(
        ::core::mem::size_of::<RAND_STATE>(),
        96usize,
        concat!("Size of: ", stringify!(RAND_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<RAND_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(RAND_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RAND_STATE>())).drbg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAND_STATE),
            "::",
            stringify!(drbg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RAND_STATE>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAND_STATE),
            "::",
            stringify!(kdf)
        )
    );
}
extern "C" {
    pub static mut s_random: *mut RAND_STATE;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ECC_CURVE {
    pub curveId: TPM_ECC_CURVE,
    pub keySizeBits: UINT16,
    pub kdf: TPMT_KDF_SCHEME,
    pub sign: TPMT_ECC_SCHEME,
    pub curveData: *const ECC_CURVE_DATA,
    pub OID: *const BYTE,
}
#[test]
fn bindgen_test_layout_ECC_CURVE() {
    assert_eq!(
        ::core::mem::size_of::<ECC_CURVE>(),
        32usize,
        concat!("Size of: ", stringify!(ECC_CURVE))
    );
    assert_eq!(
        ::core::mem::align_of::<ECC_CURVE>(),
        8usize,
        concat!("Alignment of ", stringify!(ECC_CURVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE>())).curveId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE),
            "::",
            stringify!(curveId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE>())).keySizeBits as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE),
            "::",
            stringify!(keySizeBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE>())).kdf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE>())).sign as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE>())).curveData as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE),
            "::",
            stringify!(curveData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ECC_CURVE>())).OID as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ECC_CURVE),
            "::",
            stringify!(OID)
        )
    );
}
extern "C" {
    pub static eccCurves: [ECC_CURVE; 4usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_rsa_t {
    pub allocated: crypt_uword_t,
    pub size: crypt_uword_t,
    pub d: [crypt_uword_t; 33usize],
}
#[test]
fn bindgen_test_layout_bn_rsa_t() {
    assert_eq!(
        ::core::mem::size_of::<bn_rsa_t>(),
        280usize,
        concat!("Size of: ", stringify!(bn_rsa_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bn_rsa_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_rsa_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_rsa_t>())).allocated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_rsa_t),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_rsa_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_rsa_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_rsa_t>())).d as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_rsa_t),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_prime_t {
    pub allocated: crypt_uword_t,
    pub size: crypt_uword_t,
    pub d: [crypt_uword_t; 17usize],
}
#[test]
fn bindgen_test_layout_bn_prime_t() {
    assert_eq!(
        ::core::mem::size_of::<bn_prime_t>(),
        152usize,
        concat!("Size of: ", stringify!(bn_prime_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bn_prime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_prime_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_prime_t>())).allocated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_prime_t),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_prime_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_prime_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bn_prime_t>())).d as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_prime_t),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct privateExponent {
    pub P: bigNum,
    pub Q: bigNum,
    pub dP: bigNum,
    pub dQ: bigNum,
    pub qInv: bigNum,
    pub entries: [bn_prime_t; 5usize],
}
#[test]
fn bindgen_test_layout_privateExponent() {
    assert_eq!(
        ::core::mem::size_of::<privateExponent>(),
        800usize,
        concat!("Size of: ", stringify!(privateExponent))
    );
    assert_eq!(
        ::core::mem::align_of::<privateExponent>(),
        8usize,
        concat!("Alignment of ", stringify!(privateExponent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<privateExponent>())).P as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(privateExponent),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<privateExponent>())).Q as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(privateExponent),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<privateExponent>())).dP as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(privateExponent),
            "::",
            stringify!(dP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<privateExponent>())).dQ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(privateExponent),
            "::",
            stringify!(dQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<privateExponent>())).qInv as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(privateExponent),
            "::",
            stringify!(qInv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<privateExponent>())).entries as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(privateExponent),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_ENTRY_HEADER {
    pub size: UINT32,
    pub handle: TPM_HANDLE,
}
#[test]
fn bindgen_test_layout_NV_ENTRY_HEADER() {
    assert_eq!(
        ::core::mem::size_of::<NV_ENTRY_HEADER>(),
        8usize,
        concat!("Size of: ", stringify!(NV_ENTRY_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<NV_ENTRY_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_ENTRY_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_ENTRY_HEADER>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_ENTRY_HEADER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_ENTRY_HEADER>())).handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_ENTRY_HEADER),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_RAM_HEADER {
    pub size: UINT32,
    pub handle: TPM_HANDLE,
    pub attributes: TPMA_NV,
}
#[test]
fn bindgen_test_layout_NV_RAM_HEADER() {
    assert_eq!(
        ::core::mem::size_of::<NV_RAM_HEADER>(),
        12usize,
        concat!("Size of: ", stringify!(NV_RAM_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<NV_RAM_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_RAM_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_RAM_HEADER>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_RAM_HEADER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_RAM_HEADER>())).handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_RAM_HEADER),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_RAM_HEADER>())).attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_RAM_HEADER),
            "::",
            stringify!(attributes)
        )
    );
}
pub type NV_LIST_TERMINATOR = [UINT32; 3usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ACT_STATE {
    pub remaining: UINT32,
    pub hashAlg: TPM_ALG_ID,
    pub authPolicy: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_ACT_STATE() {
    assert_eq!(
        ::core::mem::size_of::<ACT_STATE>(),
        56usize,
        concat!("Size of: ", stringify!(ACT_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<ACT_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(ACT_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACT_STATE>())).remaining as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACT_STATE),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACT_STATE>())).hashAlg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACT_STATE),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACT_STATE>())).authPolicy as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ACT_STATE),
            "::",
            stringify!(authPolicy)
        )
    );
}
pub type P_ACT_STATE = *mut ACT_STATE;
pub type NUMBYTES = UINT16;
pub type AUTH_VALUE = [BYTE; 48usize];
pub type TIME_INFO = [BYTE; 32usize];
pub type NAME = [BYTE; 52usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_PROOF {
    pub t: TPM2B_PROOF__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PROOF__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 64usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PROOF__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PROOF__bindgen_ty_1>(),
        66usize,
        concat!("Size of: ", stringify!(TPM2B_PROOF__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PROOF__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PROOF__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PROOF__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PROOF__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_PROOF__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PROOF__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_PROOF() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_PROOF>(),
        66usize,
        concat!("Size of: ", stringify!(TPM2B_PROOF))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_PROOF>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PROOF))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PROOF>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PROOF),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_PROOF>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PROOF),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPM2B_SEED {
    pub t: TPM2B_SEED__bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SEED__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 64usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SEED__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SEED__bindgen_ty_1>(),
        66usize,
        concat!("Size of: ", stringify!(TPM2B_SEED__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SEED__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SEED__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SEED__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SEED__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TPM2B_SEED__bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SEED__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_TPM2B_SEED() {
    assert_eq!(
        ::core::mem::size_of::<TPM2B_SEED>(),
        66usize,
        concat!("Size of: ", stringify!(TPM2B_SEED))
    );
    assert_eq!(
        ::core::mem::align_of::<TPM2B_SEED>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SEED))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SEED>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SEED),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPM2B_SEED>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SEED),
            "::",
            stringify!(b)
        )
    );
}
pub type CLOCK_NONCE = UINT32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OBJECT_ATTRIBUTES {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_OBJECT_ATTRIBUTES() {
    assert_eq!(
        ::core::mem::size_of::<OBJECT_ATTRIBUTES>(),
        4usize,
        concat!("Size of: ", stringify!(OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        ::core::mem::align_of::<OBJECT_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(OBJECT_ATTRIBUTES))
    );
}
impl OBJECT_ATTRIBUTES {
    #[inline]
    pub fn publicOnly(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_publicOnly(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn epsHierarchy(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_epsHierarchy(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ppsHierarchy(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ppsHierarchy(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn spsHierarchy(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_spsHierarchy(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn evict(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_evict(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn primary(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_primary(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporary(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporary(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stClear(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stClear(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hmacSeq(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hmacSeq(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hashSeq(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hashSeq(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eventSeq(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eventSeq(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticketSafe(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticketSafe(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn firstBlock(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_firstBlock(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isParent(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isParent(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_14(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_used_14(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn occupied(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_occupied(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn derivation(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivation(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn external(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_external(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        publicOnly: crate::cty::c_uint,
        epsHierarchy: crate::cty::c_uint,
        ppsHierarchy: crate::cty::c_uint,
        spsHierarchy: crate::cty::c_uint,
        evict: crate::cty::c_uint,
        primary: crate::cty::c_uint,
        temporary: crate::cty::c_uint,
        stClear: crate::cty::c_uint,
        hmacSeq: crate::cty::c_uint,
        hashSeq: crate::cty::c_uint,
        eventSeq: crate::cty::c_uint,
        ticketSafe: crate::cty::c_uint,
        firstBlock: crate::cty::c_uint,
        isParent: crate::cty::c_uint,
        not_used_14: crate::cty::c_uint,
        occupied: crate::cty::c_uint,
        derivation: crate::cty::c_uint,
        external: crate::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let publicOnly: u32 = unsafe { ::core::mem::transmute(publicOnly) };
            publicOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let epsHierarchy: u32 = unsafe { ::core::mem::transmute(epsHierarchy) };
            epsHierarchy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ppsHierarchy: u32 = unsafe { ::core::mem::transmute(ppsHierarchy) };
            ppsHierarchy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let spsHierarchy: u32 = unsafe { ::core::mem::transmute(spsHierarchy) };
            spsHierarchy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let evict: u32 = unsafe { ::core::mem::transmute(evict) };
            evict as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let primary: u32 = unsafe { ::core::mem::transmute(primary) };
            primary as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let temporary: u32 = unsafe { ::core::mem::transmute(temporary) };
            temporary as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let stClear: u32 = unsafe { ::core::mem::transmute(stClear) };
            stClear as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hmacSeq: u32 = unsafe { ::core::mem::transmute(hmacSeq) };
            hmacSeq as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hashSeq: u32 = unsafe { ::core::mem::transmute(hashSeq) };
            hashSeq as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let eventSeq: u32 = unsafe { ::core::mem::transmute(eventSeq) };
            eventSeq as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ticketSafe: u32 = unsafe { ::core::mem::transmute(ticketSafe) };
            ticketSafe as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let firstBlock: u32 = unsafe { ::core::mem::transmute(firstBlock) };
            firstBlock as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let isParent: u32 = unsafe { ::core::mem::transmute(isParent) };
            isParent as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let not_used_14: u32 = unsafe { ::core::mem::transmute(not_used_14) };
            not_used_14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let occupied: u32 = unsafe { ::core::mem::transmute(occupied) };
            occupied as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let derivation: u32 = unsafe { ::core::mem::transmute(derivation) };
            derivation as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let external: u32 = unsafe { ::core::mem::transmute(external) };
            external as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OBJECT {
    pub attributes: OBJECT_ATTRIBUTES,
    pub publicArea: TPMT_PUBLIC,
    pub sensitive: TPMT_SENSITIVE,
    pub qualifiedName: TPM2B_NAME,
    pub evictHandle: TPMI_DH_OBJECT,
    pub name: TPM2B_NAME,
}
#[test]
fn bindgen_test_layout_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<OBJECT>(),
        1204usize,
        concat!("Size of: ", stringify!(OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<OBJECT>(),
        4usize,
        concat!("Alignment of ", stringify!(OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBJECT>())).attributes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OBJECT),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBJECT>())).publicArea as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OBJECT),
            "::",
            stringify!(publicArea)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBJECT>())).sensitive as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(OBJECT),
            "::",
            stringify!(sensitive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBJECT>())).qualifiedName as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(OBJECT),
            "::",
            stringify!(qualifiedName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBJECT>())).evictHandle as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(OBJECT),
            "::",
            stringify!(evictHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBJECT>())).name as *const _ as usize },
        1148usize,
        concat!(
            "Offset of field: ",
            stringify!(OBJECT),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HASH_OBJECT {
    pub attributes: OBJECT_ATTRIBUTES,
    pub type_: TPMI_ALG_PUBLIC,
    pub nameAlg: TPMI_ALG_HASH,
    pub objectAttributes: TPMA_OBJECT,
    pub auth: TPM2B_AUTH,
    pub state: HASH_OBJECT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HASH_OBJECT__bindgen_ty_1 {
    pub hashState: [HASH_STATE; 3usize],
    pub hmacState: HMAC_STATE,
}
#[test]
fn bindgen_test_layout_HASH_OBJECT__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<HASH_OBJECT__bindgen_ty_1>(),
        696usize,
        concat!("Size of: ", stringify!(HASH_OBJECT__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<HASH_OBJECT__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(HASH_OBJECT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HASH_OBJECT__bindgen_ty_1>())).hashState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT__bindgen_ty_1),
            "::",
            stringify!(hashState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HASH_OBJECT__bindgen_ty_1>())).hmacState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT__bindgen_ty_1),
            "::",
            stringify!(hmacState)
        )
    );
}
#[test]
fn bindgen_test_layout_HASH_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<HASH_OBJECT>(),
        760usize,
        concat!("Size of: ", stringify!(HASH_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<HASH_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(HASH_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_OBJECT>())).attributes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_OBJECT>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_OBJECT>())).nameAlg as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT),
            "::",
            stringify!(nameAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_OBJECT>())).objectAttributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT),
            "::",
            stringify!(objectAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_OBJECT>())).auth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HASH_OBJECT>())).state as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_OBJECT),
            "::",
            stringify!(state)
        )
    );
}
pub type HASH_OBJECT_BUFFER = [BYTE; 760usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub union ANY_OBJECT {
    pub entity: OBJECT,
    pub hash: HASH_OBJECT,
}
#[test]
fn bindgen_test_layout_ANY_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<ANY_OBJECT>(),
        1208usize,
        concat!("Size of: ", stringify!(ANY_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<ANY_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(ANY_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ANY_OBJECT>())).entity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANY_OBJECT),
            "::",
            stringify!(entity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ANY_OBJECT>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANY_OBJECT),
            "::",
            stringify!(hash)
        )
    );
}
pub type ANY_OBJECT_BUFFER = [BYTE; 1208usize];
pub type AUTH_ROLE = UINT32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SESSION_ATTRIBUTES {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_SESSION_ATTRIBUTES() {
    assert_eq!(
        ::core::mem::size_of::<SESSION_ATTRIBUTES>(),
        4usize,
        concat!("Size of: ", stringify!(SESSION_ATTRIBUTES))
    );
    assert_eq!(
        ::core::mem::align_of::<SESSION_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(SESSION_ATTRIBUTES))
    );
}
impl SESSION_ATTRIBUTES {
    #[inline]
    pub fn isPolicy(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPolicy(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isAudit(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isAudit(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isBound(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isBound(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCpHashDefined(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCpHashDefined(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isAuthValueNeeded(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isAuthValueNeeded(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isPasswordNeeded(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPasswordNeeded(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isPPRequired(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPPRequired(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTrialPolicy(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTrialPolicy(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDaBound(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDaBound(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isLockoutBound(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLockoutBound(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn includeAuth(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_includeAuth(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn checkNvWritten(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_checkNvWritten(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nvWrittenState(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nvWrittenState(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTemplateSet(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTemplateSet(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isPolicy: crate::cty::c_uint,
        isAudit: crate::cty::c_uint,
        isBound: crate::cty::c_uint,
        isCpHashDefined: crate::cty::c_uint,
        isAuthValueNeeded: crate::cty::c_uint,
        isPasswordNeeded: crate::cty::c_uint,
        isPPRequired: crate::cty::c_uint,
        isTrialPolicy: crate::cty::c_uint,
        isDaBound: crate::cty::c_uint,
        isLockoutBound: crate::cty::c_uint,
        includeAuth: crate::cty::c_uint,
        checkNvWritten: crate::cty::c_uint,
        nvWrittenState: crate::cty::c_uint,
        isTemplateSet: crate::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isPolicy: u32 = unsafe { ::core::mem::transmute(isPolicy) };
            isPolicy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isAudit: u32 = unsafe { ::core::mem::transmute(isAudit) };
            isAudit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isBound: u32 = unsafe { ::core::mem::transmute(isBound) };
            isBound as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isCpHashDefined: u32 = unsafe { ::core::mem::transmute(isCpHashDefined) };
            isCpHashDefined as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isAuthValueNeeded: u32 = unsafe { ::core::mem::transmute(isAuthValueNeeded) };
            isAuthValueNeeded as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isPasswordNeeded: u32 = unsafe { ::core::mem::transmute(isPasswordNeeded) };
            isPasswordNeeded as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isPPRequired: u32 = unsafe { ::core::mem::transmute(isPPRequired) };
            isPPRequired as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isTrialPolicy: u32 = unsafe { ::core::mem::transmute(isTrialPolicy) };
            isTrialPolicy as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let isDaBound: u32 = unsafe { ::core::mem::transmute(isDaBound) };
            isDaBound as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isLockoutBound: u32 = unsafe { ::core::mem::transmute(isLockoutBound) };
            isLockoutBound as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let includeAuth: u32 = unsafe { ::core::mem::transmute(includeAuth) };
            includeAuth as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let checkNvWritten: u32 = unsafe { ::core::mem::transmute(checkNvWritten) };
            checkNvWritten as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let nvWrittenState: u32 = unsafe { ::core::mem::transmute(nvWrittenState) };
            nvWrittenState as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let isTemplateSet: u32 = unsafe { ::core::mem::transmute(isTemplateSet) };
            isTemplateSet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SESSION {
    pub attributes: SESSION_ATTRIBUTES,
    pub pcrCounter: UINT32,
    pub startTime: UINT64,
    pub timeout: UINT64,
    pub epoch: CLOCK_NONCE,
    pub commandCode: TPM_CC,
    pub authHashAlg: TPM_ALG_ID,
    pub commandLocality: TPMA_LOCALITY,
    pub symmetric: TPMT_SYM_DEF,
    pub sessionKey: TPM2B_AUTH,
    pub nonceTPM: TPM2B_NONCE,
    pub u1: SESSION__bindgen_ty_1,
    pub u2: SESSION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SESSION__bindgen_ty_1 {
    pub boundEntity: TPM2B_NAME,
    pub cpHash: TPM2B_DIGEST,
    pub nameHash: TPM2B_DIGEST,
    pub templateHash: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_SESSION__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SESSION__bindgen_ty_1>(),
        54usize,
        concat!("Size of: ", stringify!(SESSION__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SESSION__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SESSION__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SESSION__bindgen_ty_1>())).boundEntity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION__bindgen_ty_1),
            "::",
            stringify!(boundEntity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION__bindgen_ty_1>())).cpHash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION__bindgen_ty_1),
            "::",
            stringify!(cpHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION__bindgen_ty_1>())).nameHash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION__bindgen_ty_1),
            "::",
            stringify!(nameHash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SESSION__bindgen_ty_1>())).templateHash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION__bindgen_ty_1),
            "::",
            stringify!(templateHash)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SESSION__bindgen_ty_2 {
    pub auditDigest: TPM2B_DIGEST,
    pub policyDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_SESSION__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SESSION__bindgen_ty_2>(),
        50usize,
        concat!("Size of: ", stringify!(SESSION__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<SESSION__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(SESSION__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SESSION__bindgen_ty_2>())).auditDigest as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION__bindgen_ty_2),
            "::",
            stringify!(auditDigest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SESSION__bindgen_ty_2>())).policyDigest as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION__bindgen_ty_2),
            "::",
            stringify!(policyDigest)
        )
    );
}
#[test]
fn bindgen_test_layout_SESSION() {
    assert_eq!(
        ::core::mem::size_of::<SESSION>(),
        248usize,
        concat!("Size of: ", stringify!(SESSION))
    );
    assert_eq!(
        ::core::mem::align_of::<SESSION>(),
        8usize,
        concat!("Alignment of ", stringify!(SESSION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).attributes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).pcrCounter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(pcrCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).startTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(startTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).timeout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).epoch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).commandCode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(commandCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).authHashAlg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(authHashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).commandLocality as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(commandLocality)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).symmetric as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).sessionKey as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(sessionKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).nonceTPM as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(nonceTPM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).u1 as *const _ as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(u1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION>())).u2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION),
            "::",
            stringify!(u2)
        )
    );
}
pub type SESSION_BUF = [BYTE; 248usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCR_SAVE {
    pub Sha1: [[BYTE; 20usize]; 16usize],
    pub Sha256: [[BYTE; 32usize]; 16usize],
    pub Sha384: [[BYTE; 48usize]; 16usize],
    pub pcrCounter: UINT32,
}
#[test]
fn bindgen_test_layout_PCR_SAVE() {
    assert_eq!(
        ::core::mem::size_of::<PCR_SAVE>(),
        1604usize,
        concat!("Size of: ", stringify!(PCR_SAVE))
    );
    assert_eq!(
        ::core::mem::align_of::<PCR_SAVE>(),
        4usize,
        concat!("Alignment of ", stringify!(PCR_SAVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_SAVE>())).Sha1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_SAVE),
            "::",
            stringify!(Sha1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_SAVE>())).Sha256 as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_SAVE),
            "::",
            stringify!(Sha256)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_SAVE>())).Sha384 as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_SAVE),
            "::",
            stringify!(Sha384)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_SAVE>())).pcrCounter as *const _ as usize },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_SAVE),
            "::",
            stringify!(pcrCounter)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PCR_POLICY {
    pub hashAlg: [TPMI_ALG_HASH; 1usize],
    pub a: TPM2B_DIGEST,
    pub policy: [TPM2B_DIGEST; 1usize],
}
#[test]
fn bindgen_test_layout_PCR_POLICY() {
    assert_eq!(
        ::core::mem::size_of::<PCR_POLICY>(),
        102usize,
        concat!("Size of: ", stringify!(PCR_POLICY))
    );
    assert_eq!(
        ::core::mem::align_of::<PCR_POLICY>(),
        2usize,
        concat!("Alignment of ", stringify!(PCR_POLICY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_POLICY>())).hashAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_POLICY),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_POLICY>())).a as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_POLICY),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_POLICY>())).policy as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_POLICY),
            "::",
            stringify!(policy)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PCR_AUTH_VALUE {
    pub auth: [TPM2B_DIGEST; 1usize],
}
#[test]
fn bindgen_test_layout_PCR_AUTH_VALUE() {
    assert_eq!(
        ::core::mem::size_of::<PCR_AUTH_VALUE>(),
        50usize,
        concat!("Size of: ", stringify!(PCR_AUTH_VALUE))
    );
    assert_eq!(
        ::core::mem::align_of::<PCR_AUTH_VALUE>(),
        2usize,
        concat!("Alignment of ", stringify!(PCR_AUTH_VALUE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_AUTH_VALUE>())).auth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_AUTH_VALUE),
            "::",
            stringify!(auth)
        )
    );
}
pub type PCR_AUTHVALUE = PCR_AUTH_VALUE;
pub const STARTUP_TYPE_SU_RESET: STARTUP_TYPE = 0;
pub const STARTUP_TYPE_SU_RESTART: STARTUP_TYPE = 1;
pub const STARTUP_TYPE_SU_RESUME: STARTUP_TYPE = 2;
pub type STARTUP_TYPE = crate::cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_INDEX {
    pub publicArea: TPMS_NV_PUBLIC,
    pub authValue: TPM2B_AUTH,
}
#[test]
fn bindgen_test_layout_NV_INDEX() {
    assert_eq!(
        ::core::mem::size_of::<NV_INDEX>(),
        116usize,
        concat!("Size of: ", stringify!(NV_INDEX))
    );
    assert_eq!(
        ::core::mem::align_of::<NV_INDEX>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INDEX))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_INDEX>())).publicArea as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INDEX),
            "::",
            stringify!(publicArea)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_INDEX>())).authValue as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INDEX),
            "::",
            stringify!(authValue)
        )
    );
}
pub type NV_REF = UINT32;
pub type NV_RAM_REF = *mut BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PIN_DATA {
    pub pinLimit: UINT32,
    pub pinCount: UINT32,
}
#[test]
fn bindgen_test_layout_PIN_DATA() {
    assert_eq!(
        ::core::mem::size_of::<PIN_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(PIN_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<PIN_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(PIN_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PIN_DATA>())).pinLimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PIN_DATA),
            "::",
            stringify!(pinLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PIN_DATA>())).pinCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PIN_DATA),
            "::",
            stringify!(pinCount)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_PIN {
    pub intVal: UINT64,
    pub pin: PIN_DATA,
}
#[test]
fn bindgen_test_layout_NV_PIN() {
    assert_eq!(
        ::core::mem::size_of::<NV_PIN>(),
        8usize,
        concat!("Size of: ", stringify!(NV_PIN))
    );
    assert_eq!(
        ::core::mem::align_of::<NV_PIN>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_PIN))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_PIN>())).intVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_PIN),
            "::",
            stringify!(intVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NV_PIN>())).pin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_PIN),
            "::",
            stringify!(pin)
        )
    );
}
extern "C" {
    pub static mut g_implementedAlgorithms: ALGORITHM_VECTOR;
}
extern "C" {
    pub static mut g_toTest: ALGORITHM_VECTOR;
}
extern "C" {
    pub static g_rcIndex: [UINT16; 15usize];
}
extern "C" {
    pub static mut g_exclusiveAuditSession: TPM_HANDLE;
}
extern "C" {
    pub static mut g_time: UINT64;
}
extern "C" {
    pub static mut g_phEnable: BOOL;
}
extern "C" {
    pub static mut g_pcrReConfig: BOOL;
}
extern "C" {
    pub static mut g_DRTMHandle: TPMI_DH_OBJECT;
}
extern "C" {
    pub static mut g_DrtmPreStartup: BOOL;
}
extern "C" {
    pub static mut g_StartupLocality3: BOOL;
}
extern "C" {
    pub static mut g_daUsed: BOOL;
}
pub type UPDATE_TYPE = BYTE;
extern "C" {
    pub static mut g_updateNV: UPDATE_TYPE;
}
extern "C" {
    pub static mut g_powerWasLost: BOOL;
}
extern "C" {
    pub static mut g_clearOrderly: BOOL;
}
extern "C" {
    pub static mut g_prevOrderlyState: TPM_SU;
}
extern "C" {
    pub static mut g_nvOk: BOOL;
}
extern "C" {
    pub static mut g_NvStatus: TPM_RC;
}
extern "C" {
    pub static mut g_platformUniqueAuthorities: TPM2B_AUTH;
}
extern "C" {
    pub static mut g_platformUniqueDetails: TPM2B_AUTH;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PERSISTENT_DATA {
    pub disableClear: BOOL,
    pub ownerAlg: TPMI_ALG_HASH,
    pub endorsementAlg: TPMI_ALG_HASH,
    pub lockoutAlg: TPMI_ALG_HASH,
    pub ownerPolicy: TPM2B_DIGEST,
    pub endorsementPolicy: TPM2B_DIGEST,
    pub lockoutPolicy: TPM2B_DIGEST,
    pub ownerAuth: TPM2B_AUTH,
    pub endorsementAuth: TPM2B_AUTH,
    pub lockoutAuth: TPM2B_AUTH,
    pub EPSeed: TPM2B_SEED,
    pub SPSeed: TPM2B_SEED,
    pub PPSeed: TPM2B_SEED,
    pub phProof: TPM2B_PROOF,
    pub shProof: TPM2B_PROOF,
    pub ehProof: TPM2B_PROOF,
    pub totalResetCount: UINT64,
    pub resetCount: UINT32,
    pub pcrPolicies: PCR_POLICY,
    pub pcrAllocated: TPML_PCR_SELECTION,
    pub ppList: [BYTE; 15usize],
    pub failedTries: UINT32,
    pub maxTries: UINT32,
    pub recoveryTime: UINT32,
    pub lockoutRecovery: UINT32,
    pub lockOutAuthEnabled: BOOL,
    pub orderlyState: TPM_SU,
    pub auditCommands: [BYTE; 15usize],
    pub auditHashAlg: TPMI_ALG_HASH,
    pub auditCounter: UINT64,
    pub algorithmSet: UINT32,
    pub firmwareV1: UINT32,
    pub firmwareV2: UINT32,
    pub timeEpoch: CLOCK_NONCE,
}
#[test]
fn bindgen_test_layout_PERSISTENT_DATA() {
    assert_eq!(
        ::core::mem::size_of::<PERSISTENT_DATA>(),
        936usize,
        concat!("Size of: ", stringify!(PERSISTENT_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<PERSISTENT_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(PERSISTENT_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).disableClear as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(disableClear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).ownerAlg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(ownerAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).endorsementAlg as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(endorsementAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).lockoutAlg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(lockoutAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).ownerPolicy as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(ownerPolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PERSISTENT_DATA>())).endorsementPolicy as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(endorsementPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).lockoutPolicy as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(lockoutPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).ownerAuth as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(ownerAuth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PERSISTENT_DATA>())).endorsementAuth as *const _ as usize
        },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(endorsementAuth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).lockoutAuth as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(lockoutAuth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).EPSeed as *const _ as usize },
        310usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(EPSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).SPSeed as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(SPSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).PPSeed as *const _ as usize },
        442usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(PPSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).phProof as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(phProof)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).shProof as *const _ as usize },
        574usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(shProof)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).ehProof as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(ehProof)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PERSISTENT_DATA>())).totalResetCount as *const _ as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(totalResetCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).resetCount as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(resetCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).pcrPolicies as *const _ as usize },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(pcrPolicies)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).pcrAllocated as *const _ as usize },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(pcrAllocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).ppList as *const _ as usize },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(ppList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).failedTries as *const _ as usize },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(failedTries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).maxTries as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(maxTries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).recoveryTime as *const _ as usize },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(recoveryTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PERSISTENT_DATA>())).lockoutRecovery as *const _ as usize
        },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(lockoutRecovery)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PERSISTENT_DATA>())).lockOutAuthEnabled as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(lockOutAuthEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).orderlyState as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(orderlyState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).auditCommands as *const _ as usize },
        890usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(auditCommands)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).auditHashAlg as *const _ as usize },
        906usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(auditHashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).auditCounter as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(auditCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).algorithmSet as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(algorithmSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).firmwareV1 as *const _ as usize },
        924usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(firmwareV1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).firmwareV2 as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(firmwareV2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PERSISTENT_DATA>())).timeEpoch as *const _ as usize },
        932usize,
        concat!(
            "Offset of field: ",
            stringify!(PERSISTENT_DATA),
            "::",
            stringify!(timeEpoch)
        )
    );
}
extern "C" {
    pub static mut gp: PERSISTENT_DATA;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct orderly_data {
    pub clock: UINT64,
    pub clockSafe: TPMI_YES_NO,
    pub drbgState: DRBG_STATE,
    pub selfHealTimer: UINT64,
    pub lockoutTimer: UINT64,
    pub time: UINT64,
    pub ACT_0: ACT_STATE,
    pub ACT_A: ACT_STATE,
    pub signaledACT: UINT16,
    pub preservedSignaled: UINT16,
}
#[test]
fn bindgen_test_layout_orderly_data() {
    assert_eq!(
        ::core::mem::size_of::<orderly_data>(),
        240usize,
        concat!("Size of: ", stringify!(orderly_data))
    );
    assert_eq!(
        ::core::mem::align_of::<orderly_data>(),
        8usize,
        concat!("Alignment of ", stringify!(orderly_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).clock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).clockSafe as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(clockSafe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).drbgState as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(drbgState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).selfHealTimer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(selfHealTimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).lockoutTimer as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(lockoutTimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).ACT_0 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(ACT_0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).ACT_A as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(ACT_A)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).signaledACT as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(signaledACT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orderly_data>())).preservedSignaled as *const _ as usize },
        234usize,
        concat!(
            "Offset of field: ",
            stringify!(orderly_data),
            "::",
            stringify!(preservedSignaled)
        )
    );
}
pub type ORDERLY_DATA = orderly_data;
extern "C" {
    pub static mut go: ORDERLY_DATA;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct state_clear_data {
    pub shEnable: BOOL,
    pub ehEnable: BOOL,
    pub phEnableNV: BOOL,
    pub platformAlg: TPMI_ALG_HASH,
    pub platformPolicy: TPM2B_DIGEST,
    pub platformAuth: TPM2B_AUTH,
    pub pcrSave: PCR_SAVE,
    pub pcrAuthValues: PCR_AUTHVALUE,
    pub act_0: TPMT_HA,
    pub act_A: TPMT_HA,
}
#[test]
fn bindgen_test_layout_state_clear_data() {
    assert_eq!(
        ::core::mem::size_of::<state_clear_data>(),
        1872usize,
        concat!("Size of: ", stringify!(state_clear_data))
    );
    assert_eq!(
        ::core::mem::align_of::<state_clear_data>(),
        4usize,
        concat!("Alignment of ", stringify!(state_clear_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).shEnable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(shEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).ehEnable as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(ehEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).phEnableNV as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(phEnableNV)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).platformAlg as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(platformAlg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<state_clear_data>())).platformPolicy as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(platformPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).platformAuth as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(platformAuth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).pcrSave as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(pcrSave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).pcrAuthValues as *const _ as usize },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(pcrAuthValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).act_0 as *const _ as usize },
        1770usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(act_0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_clear_data>())).act_A as *const _ as usize },
        1820usize,
        concat!(
            "Offset of field: ",
            stringify!(state_clear_data),
            "::",
            stringify!(act_A)
        )
    );
}
pub type STATE_CLEAR_DATA = state_clear_data;
extern "C" {
    pub static mut gc: STATE_CLEAR_DATA;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct state_reset_data {
    pub nullProof: TPM2B_PROOF,
    pub nullSeed: TPM2B_SEED,
    pub clearCount: UINT32,
    pub objectContextID: UINT64,
    pub contextArray: [UINT8; 64usize],
    pub contextCounter: UINT64,
    pub commandAuditDigest: TPM2B_DIGEST,
    pub restartCount: UINT32,
    pub pcrCounter: UINT32,
    pub commitCounter: UINT64,
    pub commitNonce: TPM2B_NONCE,
    pub commitArray: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_state_reset_data() {
    assert_eq!(
        ::core::mem::size_of::<state_reset_data>(),
        360usize,
        concat!("Size of: ", stringify!(state_reset_data))
    );
    assert_eq!(
        ::core::mem::align_of::<state_reset_data>(),
        8usize,
        concat!("Alignment of ", stringify!(state_reset_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).nullProof as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(nullProof)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).nullSeed as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(nullSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).clearCount as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(clearCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<state_reset_data>())).objectContextID as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(objectContextID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).contextArray as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(contextArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<state_reset_data>())).contextCounter as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(contextCounter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<state_reset_data>())).commandAuditDigest as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(commandAuditDigest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).restartCount as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(restartCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).pcrCounter as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(pcrCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).commitCounter as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(commitCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).commitNonce as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(commitNonce)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<state_reset_data>())).commitArray as *const _ as usize },
        338usize,
        concat!(
            "Offset of field: ",
            stringify!(state_reset_data),
            "::",
            stringify!(commitArray)
        )
    );
}
pub type STATE_RESET_DATA = state_reset_data;
extern "C" {
    pub static mut gr: STATE_RESET_DATA;
}
pub type COMMAND_INDEX = UINT16;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _COMMAND_FLAGS_ {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__COMMAND_FLAGS_() {
    assert_eq!(
        ::core::mem::size_of::<_COMMAND_FLAGS_>(),
        4usize,
        concat!("Size of: ", stringify!(_COMMAND_FLAGS_))
    );
    assert_eq!(
        ::core::mem::align_of::<_COMMAND_FLAGS_>(),
        4usize,
        concat!("Alignment of ", stringify!(_COMMAND_FLAGS_))
    );
}
impl _COMMAND_FLAGS_ {
    #[inline]
    pub fn trialPolicy(&self) -> crate::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trialPolicy(&mut self, val: crate::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(trialPolicy: crate::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let trialPolicy: u32 = unsafe { ::core::mem::transmute(trialPolicy) };
            trialPolicy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type COMMAND_FLAGS = _COMMAND_FLAGS_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COMMAND {
    pub tag: TPM_ST,
    pub code: TPM_CC,
    pub index: COMMAND_INDEX,
    pub handleNum: UINT32,
    pub handles: [TPM_HANDLE; 3usize],
    pub sessionNum: UINT32,
    pub parameterSize: INT32,
    pub authSize: INT32,
    pub parameterBuffer: *mut BYTE,
    pub responseBuffer: *mut BYTE,
    pub Sha1CpHash: TPM2B_SHA1_DIGEST,
    pub Sha256CpHash: TPM2B_SHA256_DIGEST,
    pub Sha384CpHash: TPM2B_SHA384_DIGEST,
    pub Sha1RpHash: TPM2B_SHA1_DIGEST,
    pub Sha256RpHash: TPM2B_SHA256_DIGEST,
    pub Sha384RpHash: TPM2B_SHA384_DIGEST,
}
#[test]
fn bindgen_test_layout_COMMAND() {
    assert_eq!(
        ::core::mem::size_of::<COMMAND>(),
        272usize,
        concat!("Size of: ", stringify!(COMMAND))
    );
    assert_eq!(
        ::core::mem::align_of::<COMMAND>(),
        8usize,
        concat!("Alignment of ", stringify!(COMMAND))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).handleNum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(handleNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).handles as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).sessionNum as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(sessionNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).parameterSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(parameterSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).authSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(authSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).parameterBuffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(parameterBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).responseBuffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(responseBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).Sha1CpHash as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(Sha1CpHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).Sha256CpHash as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(Sha256CpHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).Sha384CpHash as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(Sha384CpHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).Sha1RpHash as *const _ as usize },
        162usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(Sha1RpHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).Sha256RpHash as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(Sha256RpHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMAND>())).Sha384RpHash as *const _ as usize },
        218usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMAND),
            "::",
            stringify!(Sha384RpHash)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PRIMARY_OBJECT_CREATION_ {
    pub t: PRIMARY_OBJECT_CREATION___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PRIMARY_OBJECT_CREATION___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 24usize],
}
#[test]
fn bindgen_test_layout_PRIMARY_OBJECT_CREATION___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PRIMARY_OBJECT_CREATION___bindgen_ty_1>(),
        26usize,
        concat!(
            "Size of: ",
            stringify!(PRIMARY_OBJECT_CREATION___bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PRIMARY_OBJECT_CREATION___bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(PRIMARY_OBJECT_CREATION___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PRIMARY_OBJECT_CREATION___bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PRIMARY_OBJECT_CREATION___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PRIMARY_OBJECT_CREATION___bindgen_ty_1>())).buffer as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PRIMARY_OBJECT_CREATION___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_PRIMARY_OBJECT_CREATION_() {
    assert_eq!(
        ::core::mem::size_of::<PRIMARY_OBJECT_CREATION_>(),
        26usize,
        concat!("Size of: ", stringify!(PRIMARY_OBJECT_CREATION_))
    );
    assert_eq!(
        ::core::mem::align_of::<PRIMARY_OBJECT_CREATION_>(),
        2usize,
        concat!("Alignment of ", stringify!(PRIMARY_OBJECT_CREATION_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PRIMARY_OBJECT_CREATION_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PRIMARY_OBJECT_CREATION_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PRIMARY_OBJECT_CREATION_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PRIMARY_OBJECT_CREATION_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_PRIMARY_OBJECT_CREATION_ = PRIMARY_OBJECT_CREATION_;
extern "C" {
    pub static PRIMARY_OBJECT_CREATION_: TPM2B_PRIMARY_OBJECT_CREATION_;
}
extern "C" {
    pub static mut PRIMARY_OBJECT_CREATION: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CFB_KEY_ {
    pub t: CFB_KEY___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFB_KEY___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 4usize],
}
#[test]
fn bindgen_test_layout_CFB_KEY___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CFB_KEY___bindgen_ty_1>(),
        6usize,
        concat!("Size of: ", stringify!(CFB_KEY___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CFB_KEY___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(CFB_KEY___bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CFB_KEY___bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFB_KEY___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CFB_KEY___bindgen_ty_1>())).buffer as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CFB_KEY___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_CFB_KEY_() {
    assert_eq!(
        ::core::mem::size_of::<CFB_KEY_>(),
        6usize,
        concat!("Size of: ", stringify!(CFB_KEY_))
    );
    assert_eq!(
        ::core::mem::align_of::<CFB_KEY_>(),
        2usize,
        concat!("Alignment of ", stringify!(CFB_KEY_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CFB_KEY_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFB_KEY_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CFB_KEY_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFB_KEY_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_CFB_KEY_ = CFB_KEY_;
extern "C" {
    pub static CFB_KEY_: TPM2B_CFB_KEY_;
}
extern "C" {
    pub static mut CFB_KEY: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTEXT_KEY_ {
    pub t: CONTEXT_KEY___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CONTEXT_KEY___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 8usize],
}
#[test]
fn bindgen_test_layout_CONTEXT_KEY___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTEXT_KEY___bindgen_ty_1>(),
        10usize,
        concat!("Size of: ", stringify!(CONTEXT_KEY___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTEXT_KEY___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(CONTEXT_KEY___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CONTEXT_KEY___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTEXT_KEY___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CONTEXT_KEY___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTEXT_KEY___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_CONTEXT_KEY_() {
    assert_eq!(
        ::core::mem::size_of::<CONTEXT_KEY_>(),
        10usize,
        concat!("Size of: ", stringify!(CONTEXT_KEY_))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTEXT_KEY_>(),
        2usize,
        concat!("Alignment of ", stringify!(CONTEXT_KEY_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTEXT_KEY_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTEXT_KEY_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTEXT_KEY_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTEXT_KEY_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_CONTEXT_KEY_ = CONTEXT_KEY_;
extern "C" {
    pub static CONTEXT_KEY_: TPM2B_CONTEXT_KEY_;
}
extern "C" {
    pub static mut CONTEXT_KEY: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union INTEGRITY_KEY_ {
    pub t: INTEGRITY_KEY___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct INTEGRITY_KEY___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 10usize],
}
#[test]
fn bindgen_test_layout_INTEGRITY_KEY___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<INTEGRITY_KEY___bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(INTEGRITY_KEY___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<INTEGRITY_KEY___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(INTEGRITY_KEY___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<INTEGRITY_KEY___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(INTEGRITY_KEY___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<INTEGRITY_KEY___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(INTEGRITY_KEY___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_INTEGRITY_KEY_() {
    assert_eq!(
        ::core::mem::size_of::<INTEGRITY_KEY_>(),
        12usize,
        concat!("Size of: ", stringify!(INTEGRITY_KEY_))
    );
    assert_eq!(
        ::core::mem::align_of::<INTEGRITY_KEY_>(),
        2usize,
        concat!("Alignment of ", stringify!(INTEGRITY_KEY_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<INTEGRITY_KEY_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(INTEGRITY_KEY_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<INTEGRITY_KEY_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(INTEGRITY_KEY_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_INTEGRITY_KEY_ = INTEGRITY_KEY_;
extern "C" {
    pub static INTEGRITY_KEY_: TPM2B_INTEGRITY_KEY_;
}
extern "C" {
    pub static mut INTEGRITY_KEY: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SECRET_KEY_ {
    pub t: SECRET_KEY___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SECRET_KEY___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 7usize],
}
#[test]
fn bindgen_test_layout_SECRET_KEY___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SECRET_KEY___bindgen_ty_1>(),
        10usize,
        concat!("Size of: ", stringify!(SECRET_KEY___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SECRET_KEY___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SECRET_KEY___bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SECRET_KEY___bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SECRET_KEY___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SECRET_KEY___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SECRET_KEY___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_SECRET_KEY_() {
    assert_eq!(
        ::core::mem::size_of::<SECRET_KEY_>(),
        10usize,
        concat!("Size of: ", stringify!(SECRET_KEY_))
    );
    assert_eq!(
        ::core::mem::align_of::<SECRET_KEY_>(),
        2usize,
        concat!("Alignment of ", stringify!(SECRET_KEY_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SECRET_KEY_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SECRET_KEY_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SECRET_KEY_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SECRET_KEY_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_SECRET_KEY_ = SECRET_KEY_;
extern "C" {
    pub static SECRET_KEY_: TPM2B_SECRET_KEY_;
}
extern "C" {
    pub static mut SECRET_KEY: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SESSION_KEY_ {
    pub t: SESSION_KEY___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SESSION_KEY___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 4usize],
}
#[test]
fn bindgen_test_layout_SESSION_KEY___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SESSION_KEY___bindgen_ty_1>(),
        6usize,
        concat!("Size of: ", stringify!(SESSION_KEY___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SESSION_KEY___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SESSION_KEY___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SESSION_KEY___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION_KEY___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SESSION_KEY___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION_KEY___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_SESSION_KEY_() {
    assert_eq!(
        ::core::mem::size_of::<SESSION_KEY_>(),
        6usize,
        concat!("Size of: ", stringify!(SESSION_KEY_))
    );
    assert_eq!(
        ::core::mem::align_of::<SESSION_KEY_>(),
        2usize,
        concat!("Alignment of ", stringify!(SESSION_KEY_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION_KEY_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION_KEY_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SESSION_KEY_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SESSION_KEY_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_SESSION_KEY_ = SESSION_KEY_;
extern "C" {
    pub static SESSION_KEY_: TPM2B_SESSION_KEY_;
}
extern "C" {
    pub static mut SESSION_KEY: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union STORAGE_KEY_ {
    pub t: STORAGE_KEY___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STORAGE_KEY___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 8usize],
}
#[test]
fn bindgen_test_layout_STORAGE_KEY___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<STORAGE_KEY___bindgen_ty_1>(),
        10usize,
        concat!("Size of: ", stringify!(STORAGE_KEY___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<STORAGE_KEY___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(STORAGE_KEY___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<STORAGE_KEY___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STORAGE_KEY___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<STORAGE_KEY___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(STORAGE_KEY___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_STORAGE_KEY_() {
    assert_eq!(
        ::core::mem::size_of::<STORAGE_KEY_>(),
        10usize,
        concat!("Size of: ", stringify!(STORAGE_KEY_))
    );
    assert_eq!(
        ::core::mem::align_of::<STORAGE_KEY_>(),
        2usize,
        concat!("Alignment of ", stringify!(STORAGE_KEY_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<STORAGE_KEY_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STORAGE_KEY_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<STORAGE_KEY_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STORAGE_KEY_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_STORAGE_KEY_ = STORAGE_KEY_;
extern "C" {
    pub static STORAGE_KEY_: TPM2B_STORAGE_KEY_;
}
extern "C" {
    pub static mut STORAGE_KEY: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XOR_KEY_ {
    pub t: XOR_KEY___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XOR_KEY___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 4usize],
}
#[test]
fn bindgen_test_layout_XOR_KEY___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<XOR_KEY___bindgen_ty_1>(),
        6usize,
        concat!("Size of: ", stringify!(XOR_KEY___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<XOR_KEY___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(XOR_KEY___bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOR_KEY___bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOR_KEY___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOR_KEY___bindgen_ty_1>())).buffer as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XOR_KEY___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_XOR_KEY_() {
    assert_eq!(
        ::core::mem::size_of::<XOR_KEY_>(),
        6usize,
        concat!("Size of: ", stringify!(XOR_KEY_))
    );
    assert_eq!(
        ::core::mem::align_of::<XOR_KEY_>(),
        2usize,
        concat!("Alignment of ", stringify!(XOR_KEY_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOR_KEY_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOR_KEY_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOR_KEY_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOR_KEY_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_XOR_KEY_ = XOR_KEY_;
extern "C" {
    pub static XOR_KEY_: TPM2B_XOR_KEY_;
}
extern "C" {
    pub static mut XOR_KEY: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union COMMIT_STRING_ {
    pub t: COMMIT_STRING___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMMIT_STRING___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 13usize],
}
#[test]
fn bindgen_test_layout_COMMIT_STRING___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<COMMIT_STRING___bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(COMMIT_STRING___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<COMMIT_STRING___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(COMMIT_STRING___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<COMMIT_STRING___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMIT_STRING___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<COMMIT_STRING___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMIT_STRING___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_COMMIT_STRING_() {
    assert_eq!(
        ::core::mem::size_of::<COMMIT_STRING_>(),
        16usize,
        concat!("Size of: ", stringify!(COMMIT_STRING_))
    );
    assert_eq!(
        ::core::mem::align_of::<COMMIT_STRING_>(),
        2usize,
        concat!("Alignment of ", stringify!(COMMIT_STRING_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMIT_STRING_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMIT_STRING_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMMIT_STRING_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMMIT_STRING_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_COMMIT_STRING_ = COMMIT_STRING_;
extern "C" {
    pub static COMMIT_STRING_: TPM2B_COMMIT_STRING_;
}
extern "C" {
    pub static mut COMMIT_STRING: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DUPLICATE_STRING_ {
    pub t: DUPLICATE_STRING___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DUPLICATE_STRING___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 10usize],
}
#[test]
fn bindgen_test_layout_DUPLICATE_STRING___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DUPLICATE_STRING___bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(DUPLICATE_STRING___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DUPLICATE_STRING___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DUPLICATE_STRING___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DUPLICATE_STRING___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DUPLICATE_STRING___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DUPLICATE_STRING___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DUPLICATE_STRING___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_DUPLICATE_STRING_() {
    assert_eq!(
        ::core::mem::size_of::<DUPLICATE_STRING_>(),
        12usize,
        concat!("Size of: ", stringify!(DUPLICATE_STRING_))
    );
    assert_eq!(
        ::core::mem::align_of::<DUPLICATE_STRING_>(),
        2usize,
        concat!("Alignment of ", stringify!(DUPLICATE_STRING_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DUPLICATE_STRING_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DUPLICATE_STRING_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DUPLICATE_STRING_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DUPLICATE_STRING_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_DUPLICATE_STRING_ = DUPLICATE_STRING_;
extern "C" {
    pub static DUPLICATE_STRING_: TPM2B_DUPLICATE_STRING_;
}
extern "C" {
    pub static mut DUPLICATE_STRING: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IDENTITY_STRING_ {
    pub t: IDENTITY_STRING___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDENTITY_STRING___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 9usize],
}
#[test]
fn bindgen_test_layout_IDENTITY_STRING___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IDENTITY_STRING___bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(IDENTITY_STRING___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IDENTITY_STRING___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(IDENTITY_STRING___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IDENTITY_STRING___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IDENTITY_STRING___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IDENTITY_STRING___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IDENTITY_STRING___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_IDENTITY_STRING_() {
    assert_eq!(
        ::core::mem::size_of::<IDENTITY_STRING_>(),
        12usize,
        concat!("Size of: ", stringify!(IDENTITY_STRING_))
    );
    assert_eq!(
        ::core::mem::align_of::<IDENTITY_STRING_>(),
        2usize,
        concat!("Alignment of ", stringify!(IDENTITY_STRING_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IDENTITY_STRING_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IDENTITY_STRING_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IDENTITY_STRING_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IDENTITY_STRING_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_IDENTITY_STRING_ = IDENTITY_STRING_;
extern "C" {
    pub static IDENTITY_STRING_: TPM2B_IDENTITY_STRING_;
}
extern "C" {
    pub static mut IDENTITY_STRING: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OBFUSCATE_STRING_ {
    pub t: OBFUSCATE_STRING___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBFUSCATE_STRING___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 10usize],
}
#[test]
fn bindgen_test_layout_OBFUSCATE_STRING___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OBFUSCATE_STRING___bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(OBFUSCATE_STRING___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OBFUSCATE_STRING___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(OBFUSCATE_STRING___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OBFUSCATE_STRING___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OBFUSCATE_STRING___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OBFUSCATE_STRING___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OBFUSCATE_STRING___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_OBFUSCATE_STRING_() {
    assert_eq!(
        ::core::mem::size_of::<OBFUSCATE_STRING_>(),
        12usize,
        concat!("Size of: ", stringify!(OBFUSCATE_STRING_))
    );
    assert_eq!(
        ::core::mem::align_of::<OBFUSCATE_STRING_>(),
        2usize,
        concat!("Alignment of ", stringify!(OBFUSCATE_STRING_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBFUSCATE_STRING_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OBFUSCATE_STRING_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OBFUSCATE_STRING_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OBFUSCATE_STRING_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_OBFUSCATE_STRING_ = OBFUSCATE_STRING_;
extern "C" {
    pub static OBFUSCATE_STRING_: TPM2B_OBFUSCATE_STRING_;
}
extern "C" {
    pub static mut OBFUSCATE_STRING: *const TPM2B;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OAEP_TEST_STRING_ {
    pub t: OAEP_TEST_STRING___bindgen_ty_1,
    pub b: TPM2B,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OAEP_TEST_STRING___bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_OAEP_TEST_STRING___bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OAEP_TEST_STRING___bindgen_ty_1>(),
        18usize,
        concat!("Size of: ", stringify!(OAEP_TEST_STRING___bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OAEP_TEST_STRING___bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(OAEP_TEST_STRING___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OAEP_TEST_STRING___bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OAEP_TEST_STRING___bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OAEP_TEST_STRING___bindgen_ty_1>())).buffer as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OAEP_TEST_STRING___bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_OAEP_TEST_STRING_() {
    assert_eq!(
        ::core::mem::size_of::<OAEP_TEST_STRING_>(),
        18usize,
        concat!("Size of: ", stringify!(OAEP_TEST_STRING_))
    );
    assert_eq!(
        ::core::mem::align_of::<OAEP_TEST_STRING_>(),
        2usize,
        concat!("Alignment of ", stringify!(OAEP_TEST_STRING_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OAEP_TEST_STRING_>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OAEP_TEST_STRING_),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OAEP_TEST_STRING_>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OAEP_TEST_STRING_),
            "::",
            stringify!(b)
        )
    );
}
pub type TPM2B_OAEP_TEST_STRING_ = OAEP_TEST_STRING_;
extern "C" {
    pub static OAEP_TEST_STRING_: TPM2B_OAEP_TEST_STRING_;
}
extern "C" {
    pub static mut OAEP_TEST_STRING: *const TPM2B;
}
extern "C" {
    pub static mut g_cryptoSelfTestState: CRYPTO_SELF_TEST_STATE;
}
extern "C" {
    pub static mut g_manufactured: BOOL;
}
extern "C" {
    pub static mut g_initialized: BOOL;
}
extern "C" {
    pub static mut g_inFailureMode: BOOL;
}
extern "C" {
    pub static mut g_forceFailureMode: BOOL;
}
pub type FailFunction = ::core::option::Option<
    unsafe extern "C" fn(
        function: *const crate::cty::c_char,
        line: crate::cty::c_int,
        code: crate::cty::c_int,
    ),
>;
extern "C" {
    pub static mut s_ActUpdated: UINT16;
}
extern "C" {
    pub static mut s_ccAttr: [TPMA_CC; 0usize];
}
extern "C" {
    pub static mut s_commandAttributes: [COMMAND_ATTRIBUTES; 0usize];
}
extern "C" {
    pub fn _TPM_Hash_Start();
}
extern "C" {
    pub fn _TPM_Hash_Data(dataSize: u32, data: *mut crate::cty::c_uchar);
}
extern "C" {
    pub fn _TPM_Hash_End();
}
extern "C" {
    pub fn ObjectFlush(object: *mut OBJECT);
}
extern "C" {
    pub fn ObjectSetInUse(object: *mut OBJECT);
}
extern "C" {
    pub fn ObjectStartup() -> BOOL;
}
extern "C" {
    pub fn ObjectCleanupEvict();
}
extern "C" {
    pub fn IsObjectPresent(handle: TPMI_DH_OBJECT) -> BOOL;
}
extern "C" {
    pub fn ObjectIsSequence(object: *mut OBJECT) -> BOOL;
}
extern "C" {
    pub fn HandleToObject(handle: TPMI_DH_OBJECT) -> *mut OBJECT;
}
extern "C" {
    pub fn GetQualifiedName(handle: TPMI_DH_OBJECT, qualifiedName: *mut TPM2B_NAME);
}
extern "C" {
    pub fn ObjectGetHierarchy(object: *mut OBJECT) -> TPMI_RH_HIERARCHY;
}
extern "C" {
    pub fn GetHierarchy(handle: TPMI_DH_OBJECT) -> TPMI_RH_HIERARCHY;
}
extern "C" {
    pub fn FindEmptyObjectSlot(handle: *mut TPMI_DH_OBJECT) -> *mut OBJECT;
}
extern "C" {
    pub fn ObjectAllocateSlot(handle: *mut TPMI_DH_OBJECT) -> *mut OBJECT;
}
extern "C" {
    pub fn ObjectSetLoadedAttributes(object: *mut OBJECT, parentHandle: TPM_HANDLE);
}
extern "C" {
    pub fn ObjectLoad(
        object: *mut OBJECT,
        parent: *mut OBJECT,
        publicArea: *mut TPMT_PUBLIC,
        sensitive: *mut TPMT_SENSITIVE,
        blamePublic: TPM_RC,
        blameSensitive: TPM_RC,
        name: *mut TPM2B_NAME,
    ) -> TPM_RC;
}
extern "C" {
    pub fn ObjectCreateHMACSequence(
        hashAlg: TPMI_ALG_HASH,
        keyObject: *mut OBJECT,
        auth: *mut TPM2B_AUTH,
        newHandle: *mut TPMI_DH_OBJECT,
    ) -> TPM_RC;
}
extern "C" {
    pub fn ObjectCreateHashSequence(
        hashAlg: TPMI_ALG_HASH,
        auth: *mut TPM2B_AUTH,
        newHandle: *mut TPMI_DH_OBJECT,
    ) -> TPM_RC;
}
extern "C" {
    pub fn ObjectCreateEventSequence(
        auth: *mut TPM2B_AUTH,
        newHandle: *mut TPMI_DH_OBJECT,
    ) -> TPM_RC;
}
extern "C" {
    pub fn ObjectTerminateEvent();
}
extern "C" {
    pub fn ObjectContextLoad(
        object: *mut ANY_OBJECT_BUFFER,
        handle: *mut TPMI_DH_OBJECT,
    ) -> *mut OBJECT;
}
extern "C" {
    pub fn FlushObject(handle: TPMI_DH_OBJECT);
}
extern "C" {
    pub fn ObjectFlushHierarchy(hierarchy: TPMI_RH_HIERARCHY);
}
extern "C" {
    pub fn ObjectLoadEvict(handle: *mut TPM_HANDLE, commandIndex: COMMAND_INDEX) -> TPM_RC;
}
extern "C" {
    pub fn ObjectComputeName(
        size: UINT32,
        publicArea: *mut BYTE,
        nameAlg: TPM_ALG_ID,
        name: *mut TPM2B_NAME,
    ) -> *mut TPM2B_NAME;
}
extern "C" {
    pub fn PublicMarshalAndComputeName(
        publicArea: *mut TPMT_PUBLIC,
        name: *mut TPM2B_NAME,
    ) -> *mut TPM2B_NAME;
}
extern "C" {
    pub fn ComputeQualifiedName(
        parentHandle: TPM_HANDLE,
        nameAlg: TPM_ALG_ID,
        name: *mut TPM2B_NAME,
        qualifiedName: *mut TPM2B_NAME,
    );
}
extern "C" {
    pub fn ObjectIsStorage(handle: TPMI_DH_OBJECT) -> BOOL;
}
extern "C" {
    pub fn ObjectCapGetLoaded(
        handle: TPMI_DH_OBJECT,
        count: UINT32,
        handleList: *mut TPML_HANDLE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn ObjectCapGetTransientAvail() -> UINT32;
}
extern "C" {
    pub fn ObjectGetPublicAttributes(handle: TPM_HANDLE) -> TPMA_OBJECT;
}
extern "C" {
    pub fn ObjectGetProperties(handle: TPM_HANDLE) -> OBJECT_ATTRIBUTES;
}
extern "C" {
    pub fn ComputeContextProtectionKey(
        contextBlob: *mut TPMS_CONTEXT,
        symKey: *mut TPM2B_SYM_KEY,
        iv: *mut TPM2B_IV,
    );
}
extern "C" {
    pub fn ComputeContextIntegrity(contextBlob: *mut TPMS_CONTEXT, integrity: *mut TPM2B_DIGEST);
}
extern "C" {
    pub fn SequenceDataExport(object: *mut HASH_OBJECT, exportObject: *mut HASH_OBJECT_BUFFER);
}
extern "C" {
    pub fn SequenceDataImport(object: *mut HASH_OBJECT, exportObject: *mut HASH_OBJECT_BUFFER);
}
extern "C" {
    pub fn AdjustAuthSize(auth: *mut TPM2B_AUTH, nameAlg: TPMI_ALG_HASH) -> BOOL;
}
extern "C" {
    pub fn ObjectIsParent(parentObject: *mut OBJECT) -> BOOL;
}
extern "C" {
    pub fn CreateChecks(
        parentObject: *mut OBJECT,
        publicArea: *mut TPMT_PUBLIC,
        sensitiveDataSize: UINT16,
    ) -> TPM_RC;
}
extern "C" {
    pub fn SchemeChecks(parentObject: *mut OBJECT, publicArea: *mut TPMT_PUBLIC) -> TPM_RC;
}
extern "C" {
    pub fn PublicAttributesValidation(
        parentObject: *mut OBJECT,
        publicArea: *mut TPMT_PUBLIC,
    ) -> TPM_RC;
}
extern "C" {
    pub fn FillInCreationData(
        parentHandle: TPMI_DH_OBJECT,
        nameHashAlg: TPMI_ALG_HASH,
        creationPCR: *mut TPML_PCR_SELECTION,
        outsideData: *mut TPM2B_DATA,
        outCreation: *mut TPM2B_CREATION_DATA,
        creationDigest: *mut TPM2B_DIGEST,
    );
}
extern "C" {
    pub fn GetSeedForKDF(protector: *mut OBJECT) -> *const TPM2B;
}
extern "C" {
    pub fn ProduceOuterWrap(
        protector: *mut OBJECT,
        name: *mut TPM2B,
        hashAlg: TPM_ALG_ID,
        seed: *mut TPM2B,
        useIV: BOOL,
        dataSize: UINT16,
        outerBuffer: *mut BYTE,
    ) -> UINT16;
}
extern "C" {
    pub fn UnwrapOuter(
        protector: *mut OBJECT,
        name: *mut TPM2B,
        hashAlg: TPM_ALG_ID,
        seed: *mut TPM2B,
        useIV: BOOL,
        dataSize: UINT16,
        outerBuffer: *mut BYTE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn SensitiveToPrivate(
        sensitive: *mut TPMT_SENSITIVE,
        name: *mut TPM2B_NAME,
        parent: *mut OBJECT,
        nameAlg: TPM_ALG_ID,
        outPrivate: *mut TPM2B_PRIVATE,
    );
}
extern "C" {
    pub fn PrivateToSensitive(
        inPrivate: *mut TPM2B,
        name: *mut TPM2B,
        parent: *mut OBJECT,
        nameAlg: TPM_ALG_ID,
        sensitive: *mut TPMT_SENSITIVE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn SensitiveToDuplicate(
        sensitive: *mut TPMT_SENSITIVE,
        name: *mut TPM2B,
        parent: *mut OBJECT,
        nameAlg: TPM_ALG_ID,
        seed: *mut TPM2B,
        symDef: *mut TPMT_SYM_DEF_OBJECT,
        innerSymKey: *mut TPM2B_DATA,
        outPrivate: *mut TPM2B_PRIVATE,
    );
}
extern "C" {
    pub fn DuplicateToSensitive(
        inPrivate: *mut TPM2B,
        name: *mut TPM2B,
        parent: *mut OBJECT,
        nameAlg: TPM_ALG_ID,
        seed: *mut TPM2B,
        symDef: *mut TPMT_SYM_DEF_OBJECT,
        innerSymKey: *mut TPM2B,
        sensitive: *mut TPMT_SENSITIVE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn SecretToCredential(
        secret: *mut TPM2B_DIGEST,
        name: *mut TPM2B,
        seed: *mut TPM2B,
        protector: *mut OBJECT,
        outIDObject: *mut TPM2B_ID_OBJECT,
    );
}
extern "C" {
    pub fn CredentialToSecret(
        inIDObject: *mut TPM2B,
        name: *mut TPM2B,
        seed: *mut TPM2B,
        protector: *mut OBJECT,
        secret: *mut TPM2B_DIGEST,
    ) -> TPM_RC;
}
extern "C" {
    pub fn MemoryRemoveTrailingZeros(auth: *mut TPM2B_AUTH) -> UINT16;
}
extern "C" {
    pub fn SetLabelAndContext(
        labelContext: *mut TPMS_DERIVE,
        sensitive: *mut TPM2B_SENSITIVE_DATA,
    ) -> TPM_RC;
}
extern "C" {
    pub fn UnmarshalToPublic(
        tOut: *mut TPMT_PUBLIC,
        tIn: *mut TPM2B_TEMPLATE,
        derivation: BOOL,
        labelContext: *mut TPMS_DERIVE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn ObjectSetExternal(object: *mut OBJECT);
}
extern "C" {
    pub fn EntityGetLoadStatus(command: *mut COMMAND) -> TPM_RC;
}
extern "C" {
    pub fn EntityGetAuthValue(handle: TPMI_DH_ENTITY, auth: *mut TPM2B_AUTH) -> UINT16;
}
extern "C" {
    pub fn EntityGetAuthPolicy(
        handle: TPMI_DH_ENTITY,
        authPolicy: *mut TPM2B_DIGEST,
    ) -> TPMI_ALG_HASH;
}
extern "C" {
    pub fn EntityGetName(handle: TPMI_DH_ENTITY, name: *mut TPM2B_NAME) -> *mut TPM2B_NAME;
}
extern "C" {
    pub fn EntityGetHierarchy(handle: TPMI_DH_ENTITY) -> TPMI_RH_HIERARCHY;
}
extern "C" {
    pub fn SessionStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn SessionIsLoaded(handle: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn SessionIsSaved(handle: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn SequenceNumberForSavedContextIsValid(context: *mut TPMS_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn SessionPCRValueIsCurrent(session: *mut SESSION) -> BOOL;
}
extern "C" {
    pub fn SessionGet(handle: TPM_HANDLE) -> *mut SESSION;
}
extern "C" {
    pub fn SessionCreate(
        sessionType: TPM_SE,
        authHash: TPMI_ALG_HASH,
        nonceCaller: *mut TPM2B_NONCE,
        symmetric: *mut TPMT_SYM_DEF,
        bind: TPMI_DH_ENTITY,
        seed: *mut TPM2B_DATA,
        sessionHandle: *mut TPM_HANDLE,
        nonceTpm: *mut TPM2B_NONCE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn SessionContextSave(handle: TPM_HANDLE, contextID: *mut UINT64) -> TPM_RC;
}
extern "C" {
    #[doc = ""]
    pub fn SessionContextLoad(session: *mut SESSION_BUF, handle: *mut TPM_HANDLE) -> TPM_RC;
}
extern "C" {
    pub fn SessionFlush(handle: TPM_HANDLE);
}
extern "C" {
    pub fn SessionComputeBoundEntity(entityHandle: TPMI_DH_ENTITY, bind: *mut TPM2B_NAME);
}
extern "C" {
    pub fn SessionSetStartTime(session: *mut SESSION);
}
extern "C" {
    pub fn SessionResetPolicyData(session: *mut SESSION);
}
extern "C" {
    pub fn SessionCapGetLoaded(
        handle: TPMI_SH_POLICY,
        count: UINT32,
        handleList: *mut TPML_HANDLE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn SessionCapGetSaved(
        handle: TPMI_SH_HMAC,
        count: UINT32,
        handleList: *mut TPML_HANDLE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn SessionCapGetLoadedNumber() -> UINT32;
}
extern "C" {
    pub fn SessionCapGetLoadedAvail() -> UINT32;
}
extern "C" {
    pub fn SessionCapGetActiveNumber() -> UINT32;
}
extern "C" {
    pub fn SessionCapGetActiveAvail() -> UINT32;
}
extern "C" {
    pub fn HierarchyPreInstall_Init();
}
extern "C" {
    pub fn HierarchyStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn HierarchyGetProof(hierarchy: TPMI_RH_HIERARCHY) -> *mut TPM2B_PROOF;
}
extern "C" {
    pub fn HierarchyGetPrimarySeed(hierarchy: TPMI_RH_HIERARCHY) -> *mut TPM2B_SEED;
}
extern "C" {
    pub fn HierarchyIsEnabled(hierarchy: TPMI_RH_HIERARCHY) -> BOOL;
}
extern "C" {
    pub fn NvCheckState();
}
extern "C" {
    pub fn NvCommit() -> BOOL;
}
extern "C" {
    pub fn NvPowerOn() -> BOOL;
}
extern "C" {
    pub fn NvManufacture();
}
extern "C" {
    pub fn NvRead(outBuffer: *mut crate::cty::c_void, nvOffset: UINT32, size: UINT32);
}
extern "C" {
    pub fn NvWrite(nvOffset: UINT32, size: UINT32, inBuffer: *mut crate::cty::c_void) -> BOOL;
}
extern "C" {
    pub fn NvUpdatePersistent(offset: UINT32, size: UINT32, buffer: *mut crate::cty::c_void);
}
extern "C" {
    pub fn NvClearPersistent(offset: UINT32, size: UINT32);
}
extern "C" {
    pub fn NvReadPersistent();
}
extern "C" {
    pub fn NvWriteNvListEnd(end: NV_REF) -> NV_REF;
}
extern "C" {
    pub fn NvUpdateIndexOrderlyData();
}
extern "C" {
    pub fn NvReadNvIndexInfo(ref_: NV_REF, nvIndex: *mut NV_INDEX);
}
extern "C" {
    pub fn NvReadObject(ref_: NV_REF, object: *mut OBJECT);
}
extern "C" {
    pub fn NvIndexIsDefined(nvHandle: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn NvIsPlatformPersistentHandle(handle: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn NvIsOwnerPersistentHandle(handle: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn NvIndexIsAccessible(handle: TPMI_RH_NV_INDEX) -> TPM_RC;
}
extern "C" {
    pub fn NvGetEvictObject(handle: TPM_HANDLE, object: *mut OBJECT) -> TPM_RC;
}
extern "C" {
    pub fn NvIndexCacheInit();
}
extern "C" {
    pub fn NvGetIndexData(
        nvIndex: *mut NV_INDEX,
        locator: NV_REF,
        offset: UINT32,
        size: UINT16,
        data: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn NvHashIndexData(
        hashState: *mut HASH_STATE,
        nvIndex: *mut NV_INDEX,
        locator: NV_REF,
        offset: UINT32,
        size: UINT16,
    );
}
extern "C" {
    pub fn NvGetUINT64Data(nvIndex: *mut NV_INDEX, locator: NV_REF) -> UINT64;
}
extern "C" {
    pub fn NvWriteIndexAttributes(
        handle: TPM_HANDLE,
        locator: NV_REF,
        attributes: TPMA_NV,
    ) -> TPM_RC;
}
extern "C" {
    pub fn NvWriteIndexAuth(locator: NV_REF, authValue: *mut TPM2B_AUTH) -> TPM_RC;
}
extern "C" {
    pub fn NvGetIndexInfo(nvHandle: TPM_HANDLE, locator: *mut NV_REF) -> *mut NV_INDEX;
}
extern "C" {
    pub fn NvWriteIndexData(
        nvIndex: *mut NV_INDEX,
        offset: UINT32,
        size: UINT32,
        data: *mut crate::cty::c_void,
    ) -> TPM_RC;
}
extern "C" {
    pub fn NvWriteUINT64Data(nvIndex: *mut NV_INDEX, intValue: UINT64) -> TPM_RC;
}
extern "C" {
    pub fn NvGetIndexName(nvIndex: *mut NV_INDEX, name: *mut TPM2B_NAME) -> *mut TPM2B_NAME;
}
extern "C" {
    pub fn NvGetNameByIndexHandle(
        handle: TPMI_RH_NV_INDEX,
        name: *mut TPM2B_NAME,
    ) -> *mut TPM2B_NAME;
}
extern "C" {
    pub fn NvDefineIndex(publicArea: *mut TPMS_NV_PUBLIC, authValue: *mut TPM2B_AUTH) -> TPM_RC;
}
extern "C" {
    pub fn NvAddEvictObject(evictHandle: TPMI_DH_OBJECT, object: *mut OBJECT) -> TPM_RC;
}
extern "C" {
    pub fn NvDeleteIndex(nvIndex: *mut NV_INDEX, entityAddr: NV_REF) -> TPM_RC;
}
extern "C" {
    pub fn NvDeleteEvict(handle: TPM_HANDLE) -> TPM_RC;
}
extern "C" {
    pub fn NvFlushHierarchy(hierarchy: TPMI_RH_HIERARCHY) -> TPM_RC;
}
extern "C" {
    pub fn NvSetGlobalLock() -> TPM_RC;
}
extern "C" {
    pub fn NvCapGetPersistent(
        handle: TPMI_DH_OBJECT,
        count: UINT32,
        handleList: *mut TPML_HANDLE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn NvCapGetIndex(
        handle: TPMI_DH_OBJECT,
        count: UINT32,
        handleList: *mut TPML_HANDLE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn NvCapGetIndexNumber() -> UINT32;
}
extern "C" {
    pub fn NvCapGetPersistentNumber() -> UINT32;
}
extern "C" {
    pub fn NvCapGetPersistentAvail() -> UINT32;
}
extern "C" {
    pub fn NvCapGetCounterNumber() -> UINT32;
}
extern "C" {
    pub fn NvEntityStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn NvCapGetCounterAvail() -> UINT32;
}
extern "C" {
    pub fn NvFindHandle(handle: TPM_HANDLE) -> NV_REF;
}
extern "C" {
    pub fn NvReadMaxCount() -> UINT64;
}
extern "C" {
    pub fn NvUpdateMaxCount(count: UINT64);
}
extern "C" {
    pub fn NvSetMaxCount(value: UINT64);
}
extern "C" {
    pub fn NvGetMaxCount() -> UINT64;
}
extern "C" {
    pub fn NvReadAccessChecks(
        authHandle: TPM_HANDLE,
        nvHandle: TPM_HANDLE,
        attributes: TPMA_NV,
    ) -> TPM_RC;
}
extern "C" {
    pub fn NvWriteAccessChecks(
        authHandle: TPM_HANDLE,
        nvHandle: TPM_HANDLE,
        attributes: TPMA_NV,
    ) -> TPM_RC;
}
extern "C" {
    pub fn NvClearOrderly() -> TPM_RC;
}
extern "C" {
    pub fn NvIsPinPassIndex(index: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn ActStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn ActGetSignaled(actHandle: TPM_RH) -> BOOL;
}
extern "C" {
    pub fn ActShutdown(state: TPM_SU) -> BOOL;
}
extern "C" {
    pub fn ActIsImplemented(act: UINT32) -> BOOL;
}
extern "C" {
    pub fn ActCounterUpdate(handle: TPM_RH, newValue: UINT32) -> TPM_RC;
}
extern "C" {
    pub fn ActGetCapabilityData(
        actHandle: TPM_HANDLE,
        maxCount: UINT32,
        actList: *mut TPML_ACT_DATA,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn PCRBelongsAuthGroup(handle: TPMI_DH_PCR, groupIndex: *mut UINT32) -> BOOL;
}
extern "C" {
    pub fn PCRBelongsPolicyGroup(handle: TPMI_DH_PCR, groupIndex: *mut UINT32) -> BOOL;
}
extern "C" {
    pub fn PCRPolicyIsAvailable(handle: TPMI_DH_PCR) -> BOOL;
}
extern "C" {
    pub fn PCRGetAuthValue(handle: TPMI_DH_PCR) -> *mut TPM2B_AUTH;
}
extern "C" {
    pub fn PCRGetAuthPolicy(handle: TPMI_DH_PCR, policy: *mut TPM2B_DIGEST) -> TPMI_ALG_HASH;
}
extern "C" {
    pub fn PCRSimStart();
}
extern "C" {
    pub fn PcrIsAllocated(pcr: UINT32, hashAlg: TPMI_ALG_HASH) -> BOOL;
}
extern "C" {
    pub fn PcrDrtm(pcrHandle: TPMI_DH_PCR, hash: TPMI_ALG_HASH, digest: *const TPM2B_DIGEST);
}
extern "C" {
    pub fn PCR_ClearAuth();
}
extern "C" {
    pub fn PCRStartup(type_: STARTUP_TYPE, locality: BYTE) -> BOOL;
}
extern "C" {
    pub fn PCRStateSave(type_: TPM_SU);
}
extern "C" {
    pub fn PCRIsStateSaved(handle: TPMI_DH_PCR) -> BOOL;
}
extern "C" {
    pub fn PCRIsResetAllowed(handle: TPMI_DH_PCR) -> BOOL;
}
extern "C" {
    pub fn PCRChanged(pcrHandle: TPM_HANDLE);
}
extern "C" {
    pub fn PCRIsExtendAllowed(handle: TPMI_DH_PCR) -> BOOL;
}
extern "C" {
    pub fn PCRExtend(handle: TPMI_DH_PCR, hash: TPMI_ALG_HASH, size: UINT32, data: *mut BYTE);
}
extern "C" {
    pub fn PCRComputeCurrentDigest(
        hashAlg: TPMI_ALG_HASH,
        selection: *mut TPML_PCR_SELECTION,
        digest: *mut TPM2B_DIGEST,
    );
}
extern "C" {
    pub fn PCRRead(
        selection: *mut TPML_PCR_SELECTION,
        digest: *mut TPML_DIGEST,
        pcrCounter: *mut UINT32,
    );
}
extern "C" {
    pub fn PCRAllocate(
        allocate: *mut TPML_PCR_SELECTION,
        maxPCR: *mut UINT32,
        sizeNeeded: *mut UINT32,
        sizeAvailable: *mut UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn PCRSetValue(handle: TPM_HANDLE, initialValue: INT8);
}
extern "C" {
    pub fn PCRResetDynamics();
}
extern "C" {
    pub fn PCRCapGetAllocation(count: UINT32, pcrSelection: *mut TPML_PCR_SELECTION)
        -> TPMI_YES_NO;
}
extern "C" {
    pub fn PCRCapGetProperties(
        property: TPM_PT_PCR,
        count: UINT32,
        select: *mut TPML_TAGGED_PCR_PROPERTY,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn PCRCapGetHandles(
        handle: TPMI_DH_PCR,
        count: UINT32,
        handleList: *mut TPML_HANDLE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn DAPreInstall_Init();
}
extern "C" {
    pub fn DAStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn DARegisterFailure(handle: TPM_HANDLE);
}
extern "C" {
    pub fn DASelfHeal();
}
extern "C" {
    pub fn SetForceFailureMode();
}
extern "C" {
    pub fn TpmLogFailure(
        function: *const crate::cty::c_char,
        line: crate::cty::c_int,
        code: crate::cty::c_int,
    );
}
extern "C" {
    pub fn TpmFail(
        function: *const crate::cty::c_char,
        line: crate::cty::c_int,
        code: crate::cty::c_int,
    );
}
extern "C" {
    pub fn TpmFailureMode(
        inRequestSize: crate::cty::c_uint,
        inRequest: *mut crate::cty::c_uchar,
        outResponseSize: *mut crate::cty::c_uint,
        outResponse: *mut *mut crate::cty::c_uchar,
    );
}
extern "C" {
    pub fn UnmarshalFail(type_: *mut crate::cty::c_void, buffer: *mut *mut BYTE, size: *mut INT32);
}
extern "C" {
    pub fn IsDAExempted(handle: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn ClearCpRpHashes(command: *mut COMMAND);
}
extern "C" {
    pub fn CompareNameHash(command: *mut COMMAND, session: *mut SESSION) -> BOOL;
}
extern "C" {
    pub fn ParseSessionBuffer(command: *mut COMMAND) -> TPM_RC;
}
extern "C" {
    pub fn CheckAuthNoSession(command: *mut COMMAND) -> TPM_RC;
}
extern "C" {
    pub fn BuildResponseSession(command: *mut COMMAND);
}
extern "C" {
    pub fn SessionRemoveAssociationToHandle(handle: TPM_HANDLE);
}
extern "C" {
    pub fn GetClosestCommandIndex(commandCode: TPM_CC) -> COMMAND_INDEX;
}
extern "C" {
    pub fn CommandCodeToCommandIndex(commandCode: TPM_CC) -> COMMAND_INDEX;
}
extern "C" {
    pub fn GetNextCommandIndex(commandIndex: COMMAND_INDEX) -> COMMAND_INDEX;
}
extern "C" {
    pub fn GetCommandCode(commandIndex: COMMAND_INDEX) -> TPM_CC;
}
extern "C" {
    pub fn CommandAuthRole(commandIndex: COMMAND_INDEX, handleIndex: UINT32) -> AUTH_ROLE;
}
extern "C" {
    pub fn EncryptSize(commandIndex: COMMAND_INDEX) -> crate::cty::c_int;
}
extern "C" {
    pub fn DecryptSize(commandIndex: COMMAND_INDEX) -> crate::cty::c_int;
}
extern "C" {
    pub fn IsSessionAllowed(commandIndex: COMMAND_INDEX) -> BOOL;
}
extern "C" {
    pub fn IsHandleInResponse(commandIndex: COMMAND_INDEX) -> BOOL;
}
extern "C" {
    pub fn IsWriteOperation(commandIndex: COMMAND_INDEX) -> BOOL;
}
extern "C" {
    pub fn IsReadOperation(commandIndex: COMMAND_INDEX) -> BOOL;
}
extern "C" {
    pub fn CommandCapGetCCList(
        commandCode: TPM_CC,
        count: UINT32,
        commandList: *mut TPML_CCA,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn IsVendorCommand(commandIndex: COMMAND_INDEX) -> BOOL;
}
extern "C" {
    pub fn UINT8_Unmarshal(target: *mut UINT8, buffer: *mut *mut BYTE, size: *mut INT32) -> TPM_RC;
}
extern "C" {
    pub fn UINT8_Marshal(source: *mut UINT8, buffer: *mut *mut BYTE, size: *mut INT32) -> UINT16;
}
extern "C" {
    pub fn UINT16_Unmarshal(
        target: *mut UINT16,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn UINT16_Marshal(source: *mut UINT16, buffer: *mut *mut BYTE, size: *mut INT32) -> UINT16;
}
extern "C" {
    pub fn UINT32_Unmarshal(
        target: *mut UINT32,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn UINT32_Marshal(source: *mut UINT32, buffer: *mut *mut BYTE, size: *mut INT32) -> UINT16;
}
extern "C" {
    pub fn UINT64_Unmarshal(
        target: *mut UINT64,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn UINT64_Marshal(source: *mut UINT64, buffer: *mut *mut BYTE, size: *mut INT32) -> UINT16;
}
extern "C" {
    pub fn TPM_ECC_CURVE_Unmarshal(
        target: *mut TPM_ECC_CURVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_CLOCK_ADJUST_Unmarshal(
        target: *mut TPM_CLOCK_ADJUST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_EO_Unmarshal(
        target: *mut TPM_EO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_SU_Unmarshal(
        target: *mut TPM_SU,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_SE_Unmarshal(
        target: *mut TPM_SE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_CAP_Unmarshal(
        target: *mut TPM_CAP,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMA_ALGORITHM_Unmarshal(
        target: *mut TPMA_ALGORITHM,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMA_OBJECT_Unmarshal(
        target: *mut TPMA_OBJECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMA_SESSION_Unmarshal(
        target: *mut TPMA_SESSION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMA_ACT_Unmarshal(
        target: *mut TPMA_ACT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_YES_NO_Unmarshal(
        target: *mut TPMI_YES_NO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_DH_OBJECT_Unmarshal(
        target: *mut TPMI_DH_OBJECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_DH_PARENT_Unmarshal(
        target: *mut TPMI_DH_PARENT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_DH_PERSISTENT_Unmarshal(
        target: *mut TPMI_DH_PERSISTENT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_DH_ENTITY_Unmarshal(
        target: *mut TPMI_DH_ENTITY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_DH_PCR_Unmarshal(
        target: *mut TPMI_DH_PCR,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_SH_AUTH_SESSION_Unmarshal(
        target: *mut TPMI_SH_AUTH_SESSION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_SH_HMAC_Unmarshal(
        target: *mut TPMI_SH_HMAC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_SH_POLICY_Unmarshal(
        target: *mut TPMI_SH_POLICY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_DH_CONTEXT_Unmarshal(
        target: *mut TPMI_DH_CONTEXT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_DH_SAVED_Unmarshal(
        target: *mut TPMI_DH_SAVED,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_HIERARCHY_Unmarshal(
        target: *mut TPMI_RH_HIERARCHY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_ENABLES_Unmarshal(
        target: *mut TPMI_RH_ENABLES,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_HIERARCHY_AUTH_Unmarshal(
        target: *mut TPMI_RH_HIERARCHY_AUTH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_HIERARCHY_POLICY_Unmarshal(
        target: *mut TPMI_RH_HIERARCHY_POLICY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_PLATFORM_Unmarshal(
        target: *mut TPMI_RH_PLATFORM,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_OWNER_Unmarshal(
        target: *mut TPMI_RH_OWNER,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_ENDORSEMENT_Unmarshal(
        target: *mut TPMI_RH_ENDORSEMENT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_PROVISION_Unmarshal(
        target: *mut TPMI_RH_PROVISION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_CLEAR_Unmarshal(
        target: *mut TPMI_RH_CLEAR,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_NV_AUTH_Unmarshal(
        target: *mut TPMI_RH_NV_AUTH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_LOCKOUT_Unmarshal(
        target: *mut TPMI_RH_LOCKOUT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_NV_INDEX_Unmarshal(
        target: *mut TPMI_RH_NV_INDEX,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_AC_Unmarshal(
        target: *mut TPMI_RH_AC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_RH_ACT_Unmarshal(
        target: *mut TPMI_RH_ACT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_HASH_Unmarshal(
        target: *mut TPMI_ALG_HASH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_ASYM_Unmarshal(
        target: *mut TPMI_ALG_ASYM,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_SYM_Unmarshal(
        target: *mut TPMI_ALG_SYM,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_SYM_OBJECT_Unmarshal(
        target: *mut TPMI_ALG_SYM_OBJECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_SYM_MODE_Unmarshal(
        target: *mut TPMI_ALG_SYM_MODE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_KDF_Unmarshal(
        target: *mut TPMI_ALG_KDF,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_SIG_SCHEME_Unmarshal(
        target: *mut TPMI_ALG_SIG_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ECC_KEY_EXCHANGE_Unmarshal(
        target: *mut TPMI_ECC_KEY_EXCHANGE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ST_COMMAND_TAG_Unmarshal(
        target: *mut TPMI_ST_COMMAND_TAG,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_MAC_SCHEME_Unmarshal(
        target: *mut TPMI_ALG_MAC_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ALG_CIPHER_MODE_Unmarshal(
        target: *mut TPMI_ALG_CIPHER_MODE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_EMPTY_Unmarshal(
        target: *mut TPMS_EMPTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_EMPTY_Marshal(
        source: *mut TPMS_EMPTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ALGORITHM_DESCRIPTION_Marshal(
        source: *mut TPMS_ALGORITHM_DESCRIPTION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_HA_Unmarshal(
        target: *mut TPMU_HA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_HA_Marshal(
        source: *mut TPMU_HA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_HA_Unmarshal(
        target: *mut TPMT_HA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_HA_Marshal(
        source: *mut TPMT_HA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_DIGEST_Unmarshal(
        target: *mut TPM2B_DIGEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_DIGEST_Marshal(
        source: *mut TPM2B_DIGEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_DATA_Unmarshal(
        target: *mut TPM2B_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_DATA_Marshal(
        source: *mut TPM2B_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_EVENT_Unmarshal(
        target: *mut TPM2B_EVENT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_EVENT_Marshal(
        source: *mut TPM2B_EVENT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_MAX_BUFFER_Unmarshal(
        target: *mut TPM2B_MAX_BUFFER,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_MAX_BUFFER_Marshal(
        source: *mut TPM2B_MAX_BUFFER,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_MAX_NV_BUFFER_Unmarshal(
        target: *mut TPM2B_MAX_NV_BUFFER,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_MAX_NV_BUFFER_Marshal(
        source: *mut TPM2B_MAX_NV_BUFFER,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_TIMEOUT_Unmarshal(
        target: *mut TPM2B_TIMEOUT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_TIMEOUT_Marshal(
        source: *mut TPM2B_TIMEOUT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_IV_Unmarshal(
        target: *mut TPM2B_IV,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_IV_Marshal(
        source: *mut TPM2B_IV,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_NAME_Unmarshal(
        target: *mut TPM2B_NAME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_NAME_Marshal(
        source: *mut TPM2B_NAME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_PCR_SELECT_Unmarshal(
        target: *mut TPMS_PCR_SELECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_PCR_SELECT_Marshal(
        source: *mut TPMS_PCR_SELECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_PCR_SELECTION_Unmarshal(
        target: *mut TPMS_PCR_SELECTION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_PCR_SELECTION_Marshal(
        source: *mut TPMS_PCR_SELECTION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_TK_CREATION_Unmarshal(
        target: *mut TPMT_TK_CREATION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_TK_CREATION_Marshal(
        source: *mut TPMT_TK_CREATION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_TK_VERIFIED_Unmarshal(
        target: *mut TPMT_TK_VERIFIED,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_TK_VERIFIED_Marshal(
        source: *mut TPMT_TK_VERIFIED,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_TK_AUTH_Unmarshal(
        target: *mut TPMT_TK_AUTH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_TK_AUTH_Marshal(
        source: *mut TPMT_TK_AUTH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_TK_HASHCHECK_Unmarshal(
        target: *mut TPMT_TK_HASHCHECK,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_TK_HASHCHECK_Marshal(
        source: *mut TPMT_TK_HASHCHECK,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ALG_PROPERTY_Marshal(
        source: *mut TPMS_ALG_PROPERTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TAGGED_PROPERTY_Marshal(
        source: *mut TPMS_TAGGED_PROPERTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TAGGED_PCR_SELECT_Marshal(
        source: *mut TPMS_TAGGED_PCR_SELECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TAGGED_POLICY_Marshal(
        source: *mut TPMS_TAGGED_POLICY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ACT_DATA_Marshal(
        source: *mut TPMS_ACT_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_CC_Unmarshal(
        target: *mut TPML_CC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPML_CC_Marshal(
        source: *mut TPML_CC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_CCA_Marshal(
        source: *mut TPML_CCA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_ALG_Unmarshal(
        target: *mut TPML_ALG,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPML_ALG_Marshal(
        source: *mut TPML_ALG,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_HANDLE_Marshal(
        source: *mut TPML_HANDLE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_DIGEST_Unmarshal(
        target: *mut TPML_DIGEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPML_DIGEST_Marshal(
        source: *mut TPML_DIGEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_DIGEST_VALUES_Unmarshal(
        target: *mut TPML_DIGEST_VALUES,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPML_DIGEST_VALUES_Marshal(
        source: *mut TPML_DIGEST_VALUES,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_PCR_SELECTION_Unmarshal(
        target: *mut TPML_PCR_SELECTION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPML_PCR_SELECTION_Marshal(
        source: *mut TPML_PCR_SELECTION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_ALG_PROPERTY_Marshal(
        source: *mut TPML_ALG_PROPERTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_TAGGED_TPM_PROPERTY_Marshal(
        source: *mut TPML_TAGGED_TPM_PROPERTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_TAGGED_PCR_PROPERTY_Marshal(
        source: *mut TPML_TAGGED_PCR_PROPERTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_ECC_CURVE_Marshal(
        source: *mut TPML_ECC_CURVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_TAGGED_POLICY_Marshal(
        source: *mut TPML_TAGGED_POLICY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_ACT_DATA_Marshal(
        source: *mut TPML_ACT_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_CAPABILITIES_Marshal(
        source: *mut TPMU_CAPABILITIES,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_CAPABILITY_DATA_Marshal(
        source: *mut TPMS_CAPABILITY_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_CLOCK_INFO_Unmarshal(
        target: *mut TPMS_CLOCK_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_CLOCK_INFO_Marshal(
        source: *mut TPMS_CLOCK_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TIME_INFO_Unmarshal(
        target: *mut TPMS_TIME_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_TIME_INFO_Marshal(
        source: *mut TPMS_TIME_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TIME_ATTEST_INFO_Marshal(
        source: *mut TPMS_TIME_ATTEST_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_CERTIFY_INFO_Marshal(
        source: *mut TPMS_CERTIFY_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_QUOTE_INFO_Marshal(
        source: *mut TPMS_QUOTE_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_COMMAND_AUDIT_INFO_Marshal(
        source: *mut TPMS_COMMAND_AUDIT_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_SESSION_AUDIT_INFO_Marshal(
        source: *mut TPMS_SESSION_AUDIT_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_CREATION_INFO_Marshal(
        source: *mut TPMS_CREATION_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_NV_CERTIFY_INFO_Marshal(
        source: *mut TPMS_NV_CERTIFY_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_NV_DIGEST_CERTIFY_INFO_Marshal(
        source: *mut TPMS_NV_DIGEST_CERTIFY_INFO,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_ATTEST_Marshal(
        source: *mut TPMU_ATTEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ATTEST_Marshal(
        source: *mut TPMS_ATTEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_ATTEST_Marshal(
        source: *mut TPM2B_ATTEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_AUTH_COMMAND_Unmarshal(
        target: *mut TPMS_AUTH_COMMAND,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_AUTH_RESPONSE_Marshal(
        source: *mut TPMS_AUTH_RESPONSE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_AES_KEY_BITS_Unmarshal(
        target: *mut TPMI_AES_KEY_BITS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_CAMELLIA_KEY_BITS_Unmarshal(
        target: *mut TPMI_CAMELLIA_KEY_BITS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_SYM_KEY_BITS_Unmarshal(
        target: *mut TPMU_SYM_KEY_BITS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_SYM_KEY_BITS_Marshal(
        source: *mut TPMU_SYM_KEY_BITS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_SYM_MODE_Unmarshal(
        target: *mut TPMU_SYM_MODE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_SYM_MODE_Marshal(
        source: *mut TPMU_SYM_MODE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_SYM_DEF_Unmarshal(
        target: *mut TPMT_SYM_DEF,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_SYM_DEF_Marshal(
        source: *mut TPMT_SYM_DEF,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_SYM_DEF_OBJECT_Unmarshal(
        target: *mut TPMT_SYM_DEF_OBJECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_SYM_DEF_OBJECT_Marshal(
        source: *mut TPMT_SYM_DEF_OBJECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_SYM_KEY_Unmarshal(
        target: *mut TPM2B_SYM_KEY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_SYM_KEY_Marshal(
        source: *mut TPM2B_SYM_KEY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_SYMCIPHER_PARMS_Unmarshal(
        target: *mut TPMS_SYMCIPHER_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SYMCIPHER_PARMS_Marshal(
        source: *mut TPMS_SYMCIPHER_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_LABEL_Unmarshal(
        target: *mut TPM2B_LABEL,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_LABEL_Marshal(
        source: *mut TPM2B_LABEL,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_DERIVE_Unmarshal(
        target: *mut TPMS_DERIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_DERIVE_Marshal(
        source: *mut TPMS_DERIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_DERIVE_Unmarshal(
        target: *mut TPM2B_DERIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_DERIVE_Marshal(
        source: *mut TPM2B_DERIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_SENSITIVE_DATA_Unmarshal(
        target: *mut TPM2B_SENSITIVE_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_SENSITIVE_DATA_Marshal(
        source: *mut TPM2B_SENSITIVE_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_SENSITIVE_CREATE_Unmarshal(
        target: *mut TPMS_SENSITIVE_CREATE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_SENSITIVE_CREATE_Unmarshal(
        target: *mut TPM2B_SENSITIVE_CREATE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SCHEME_HASH_Unmarshal(
        target: *mut TPMS_SCHEME_HASH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SCHEME_HASH_Marshal(
        source: *mut TPMS_SCHEME_HASH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_SCHEME_ECDAA_Unmarshal(
        target: *mut TPMS_SCHEME_ECDAA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SCHEME_ECDAA_Marshal(
        source: *mut TPMS_SCHEME_ECDAA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_ALG_KEYEDHASH_SCHEME_Unmarshal(
        target: *mut TPMI_ALG_KEYEDHASH_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SCHEME_XOR_Unmarshal(
        target: *mut TPMS_SCHEME_XOR,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SCHEME_XOR_Marshal(
        source: *mut TPMS_SCHEME_XOR,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_SCHEME_KEYEDHASH_Unmarshal(
        target: *mut TPMU_SCHEME_KEYEDHASH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_SCHEME_KEYEDHASH_Marshal(
        source: *mut TPMU_SCHEME_KEYEDHASH,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_KEYEDHASH_SCHEME_Unmarshal(
        target: *mut TPMT_KEYEDHASH_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_KEYEDHASH_SCHEME_Marshal(
        source: *mut TPMT_KEYEDHASH_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_SIG_SCHEME_Unmarshal(
        target: *mut TPMU_SIG_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_SIG_SCHEME_Marshal(
        source: *mut TPMU_SIG_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_SIG_SCHEME_Unmarshal(
        target: *mut TPMT_SIG_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_SIG_SCHEME_Marshal(
        source: *mut TPMT_SIG_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_KDF_SCHEME_Unmarshal(
        target: *mut TPMU_KDF_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_KDF_SCHEME_Marshal(
        source: *mut TPMU_KDF_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_KDF_SCHEME_Unmarshal(
        target: *mut TPMT_KDF_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_KDF_SCHEME_Marshal(
        source: *mut TPMT_KDF_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_ALG_ASYM_SCHEME_Unmarshal(
        target: *mut TPMI_ALG_ASYM_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_ASYM_SCHEME_Unmarshal(
        target: *mut TPMU_ASYM_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_ASYM_SCHEME_Marshal(
        source: *mut TPMU_ASYM_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_ALG_RSA_SCHEME_Unmarshal(
        target: *mut TPMI_ALG_RSA_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_RSA_SCHEME_Unmarshal(
        target: *mut TPMT_RSA_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_RSA_SCHEME_Marshal(
        source: *mut TPMT_RSA_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_ALG_RSA_DECRYPT_Unmarshal(
        target: *mut TPMI_ALG_RSA_DECRYPT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_RSA_DECRYPT_Unmarshal(
        target: *mut TPMT_RSA_DECRYPT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_RSA_DECRYPT_Marshal(
        source: *mut TPMT_RSA_DECRYPT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_PUBLIC_KEY_RSA_Unmarshal(
        target: *mut TPM2B_PUBLIC_KEY_RSA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_PUBLIC_KEY_RSA_Marshal(
        source: *mut TPM2B_PUBLIC_KEY_RSA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_RSA_KEY_BITS_Unmarshal(
        target: *mut TPMI_RSA_KEY_BITS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_PRIVATE_KEY_RSA_Unmarshal(
        target: *mut TPM2B_PRIVATE_KEY_RSA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_PRIVATE_KEY_RSA_Marshal(
        source: *mut TPM2B_PRIVATE_KEY_RSA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_ECC_PARAMETER_Unmarshal(
        target: *mut TPM2B_ECC_PARAMETER,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_ECC_PARAMETER_Marshal(
        source: *mut TPM2B_ECC_PARAMETER,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ECC_POINT_Unmarshal(
        target: *mut TPMS_ECC_POINT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_ECC_POINT_Marshal(
        source: *mut TPMS_ECC_POINT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_ECC_POINT_Unmarshal(
        target: *mut TPM2B_ECC_POINT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_ECC_POINT_Marshal(
        source: *mut TPM2B_ECC_POINT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_ALG_ECC_SCHEME_Unmarshal(
        target: *mut TPMI_ALG_ECC_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMI_ECC_CURVE_Unmarshal(
        target: *mut TPMI_ECC_CURVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_ECC_SCHEME_Unmarshal(
        target: *mut TPMT_ECC_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_ECC_SCHEME_Marshal(
        source: *mut TPMT_ECC_SCHEME,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ALGORITHM_DETAIL_ECC_Marshal(
        source: *mut TPMS_ALGORITHM_DETAIL_ECC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_SIGNATURE_RSA_Unmarshal(
        target: *mut TPMS_SIGNATURE_RSA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SIGNATURE_RSA_Marshal(
        source: *mut TPMS_SIGNATURE_RSA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_SIGNATURE_ECC_Unmarshal(
        target: *mut TPMS_SIGNATURE_ECC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_SIGNATURE_ECC_Marshal(
        source: *mut TPMS_SIGNATURE_ECC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_SIGNATURE_Unmarshal(
        target: *mut TPMU_SIGNATURE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_SIGNATURE_Marshal(
        source: *mut TPMU_SIGNATURE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_SIGNATURE_Unmarshal(
        target: *mut TPMT_SIGNATURE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_SIGNATURE_Marshal(
        source: *mut TPMT_SIGNATURE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_ENCRYPTED_SECRET_Unmarshal(
        target: *mut TPMU_ENCRYPTED_SECRET,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_ENCRYPTED_SECRET_Marshal(
        source: *mut TPMU_ENCRYPTED_SECRET,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_ENCRYPTED_SECRET_Unmarshal(
        target: *mut TPM2B_ENCRYPTED_SECRET,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_ENCRYPTED_SECRET_Marshal(
        source: *mut TPM2B_ENCRYPTED_SECRET,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMI_ALG_PUBLIC_Unmarshal(
        target: *mut TPMI_ALG_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_PUBLIC_ID_Unmarshal(
        target: *mut TPMU_PUBLIC_ID,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_PUBLIC_ID_Marshal(
        source: *mut TPMU_PUBLIC_ID,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_KEYEDHASH_PARMS_Unmarshal(
        target: *mut TPMS_KEYEDHASH_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_KEYEDHASH_PARMS_Marshal(
        source: *mut TPMS_KEYEDHASH_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_RSA_PARMS_Unmarshal(
        target: *mut TPMS_RSA_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_RSA_PARMS_Marshal(
        source: *mut TPMS_RSA_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ECC_PARMS_Unmarshal(
        target: *mut TPMS_ECC_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_ECC_PARMS_Marshal(
        source: *mut TPMS_ECC_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_PUBLIC_PARMS_Unmarshal(
        target: *mut TPMU_PUBLIC_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_PUBLIC_PARMS_Marshal(
        source: *mut TPMU_PUBLIC_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_PUBLIC_PARMS_Unmarshal(
        target: *mut TPMT_PUBLIC_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_PUBLIC_PARMS_Marshal(
        source: *mut TPMT_PUBLIC_PARMS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_PUBLIC_Unmarshal(
        target: *mut TPMT_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_PUBLIC_Marshal(
        source: *mut TPMT_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_PUBLIC_Unmarshal(
        target: *mut TPM2B_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_PUBLIC_Marshal(
        source: *mut TPM2B_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_TEMPLATE_Unmarshal(
        target: *mut TPM2B_TEMPLATE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_TEMPLATE_Marshal(
        source: *mut TPM2B_TEMPLATE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_PRIVATE_VENDOR_SPECIFIC_Unmarshal(
        target: *mut TPM2B_PRIVATE_VENDOR_SPECIFIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_PRIVATE_VENDOR_SPECIFIC_Marshal(
        source: *mut TPM2B_PRIVATE_VENDOR_SPECIFIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMU_SENSITIVE_COMPOSITE_Unmarshal(
        target: *mut TPMU_SENSITIVE_COMPOSITE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMU_SENSITIVE_COMPOSITE_Marshal(
        source: *mut TPMU_SENSITIVE_COMPOSITE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        selector: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_SENSITIVE_Unmarshal(
        target: *mut TPMT_SENSITIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_SENSITIVE_Marshal(
        source: *mut TPMT_SENSITIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_SENSITIVE_Unmarshal(
        target: *mut TPM2B_SENSITIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_SENSITIVE_Marshal(
        source: *mut TPM2B_SENSITIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_PRIVATE_Unmarshal(
        target: *mut TPM2B_PRIVATE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_PRIVATE_Marshal(
        source: *mut TPM2B_PRIVATE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_ID_OBJECT_Unmarshal(
        target: *mut TPM2B_ID_OBJECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_ID_OBJECT_Marshal(
        source: *mut TPM2B_ID_OBJECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_NV_PIN_COUNTER_PARAMETERS_Unmarshal(
        target: *mut TPMS_NV_PIN_COUNTER_PARAMETERS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_NV_PIN_COUNTER_PARAMETERS_Marshal(
        source: *mut TPMS_NV_PIN_COUNTER_PARAMETERS,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMA_NV_Unmarshal(
        target: *mut TPMA_NV,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_NV_PUBLIC_Unmarshal(
        target: *mut TPMS_NV_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_NV_PUBLIC_Marshal(
        source: *mut TPMS_NV_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_NV_PUBLIC_Unmarshal(
        target: *mut TPM2B_NV_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_NV_PUBLIC_Marshal(
        source: *mut TPM2B_NV_PUBLIC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_CONTEXT_SENSITIVE_Unmarshal(
        target: *mut TPM2B_CONTEXT_SENSITIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_CONTEXT_SENSITIVE_Marshal(
        source: *mut TPM2B_CONTEXT_SENSITIVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_CONTEXT_DATA_Unmarshal(
        target: *mut TPMS_CONTEXT_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_CONTEXT_DATA_Marshal(
        source: *mut TPMS_CONTEXT_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_CONTEXT_DATA_Unmarshal(
        target: *mut TPM2B_CONTEXT_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_CONTEXT_DATA_Marshal(
        source: *mut TPM2B_CONTEXT_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_CONTEXT_Unmarshal(
        target: *mut TPMS_CONTEXT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_CONTEXT_Marshal(
        source: *mut TPMS_CONTEXT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_CREATION_DATA_Marshal(
        source: *mut TPMS_CREATION_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_CREATION_DATA_Marshal(
        source: *mut TPM2B_CREATION_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM_AT_Unmarshal(
        target: *mut TPM_AT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_AC_OUTPUT_Marshal(
        source: *mut TPMS_AC_OUTPUT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPML_AC_CAPABILITIES_Marshal(
        source: *mut TPML_AC_CAPABILITIES,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn BYTE_Array_Unmarshal(
        target: *mut BYTE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn BYTE_Array_Marshal(
        source: *mut BYTE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM2B_DIGEST_Array_Unmarshal(
        target: *mut TPM2B_DIGEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM2B_DIGEST_Array_Marshal(
        source: *mut TPM2B_DIGEST,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMA_CC_Array_Marshal(
        source: *mut TPMA_CC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ACT_DATA_Array_Marshal(
        source: *mut TPMS_ACT_DATA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_AC_OUTPUT_Array_Marshal(
        source: *mut TPMS_AC_OUTPUT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_ALG_PROPERTY_Array_Marshal(
        source: *mut TPMS_ALG_PROPERTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_PCR_SELECTION_Array_Unmarshal(
        target: *mut TPMS_PCR_SELECTION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMS_PCR_SELECTION_Array_Marshal(
        source: *mut TPMS_PCR_SELECTION,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TAGGED_PCR_SELECT_Array_Marshal(
        source: *mut TPMS_TAGGED_PCR_SELECT,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TAGGED_POLICY_Array_Marshal(
        source: *mut TPMS_TAGGED_POLICY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMS_TAGGED_PROPERTY_Array_Marshal(
        source: *mut TPMS_TAGGED_PROPERTY,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPMT_HA_Array_Unmarshal(
        target: *mut TPMT_HA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        flag: BOOL,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPMT_HA_Array_Marshal(
        source: *mut TPMT_HA,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM_ALG_ID_Array_Unmarshal(
        target: *mut TPM_ALG_ID,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_ALG_ID_Array_Marshal(
        source: *mut TPM_ALG_ID,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM_CC_Array_Unmarshal(
        target: *mut TPM_CC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_CC_Array_Marshal(
        source: *mut TPM_CC,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM_ECC_CURVE_Array_Unmarshal(
        target: *mut TPM_ECC_CURVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_ECC_CURVE_Array_Marshal(
        source: *mut TPM_ECC_CURVE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TPM_HANDLE_Array_Unmarshal(
        target: *mut TPM_HANDLE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TPM_HANDLE_Array_Marshal(
        source: *mut TPM_HANDLE,
        buffer: *mut *mut BYTE,
        size: *mut INT32,
        count: INT32,
    ) -> UINT16;
}
extern "C" {
    pub fn TimePowerOn();
}
extern "C" {
    pub fn TimeStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn TimeClockUpdate(newTime: UINT64);
}
extern "C" {
    pub fn TimeUpdate();
}
extern "C" {
    pub fn TimeUpdateToCurrent();
}
extern "C" {
    pub fn TimeSetAdjustRate(adjust: TPM_CLOCK_ADJUST);
}
extern "C" {
    pub fn TimeGetMarshaled(dataBuffer: *mut TIME_INFO) -> UINT16;
}
extern "C" {
    pub fn TimeFillInfo(clockInfo: *mut TPMS_CLOCK_INFO);
}
extern "C" {
    pub fn LocalityGetAttributes(locality: UINT8) -> TPMA_LOCALITY;
}
extern "C" {
    pub fn PhysicalPresencePreInstall_Init();
}
extern "C" {
    pub fn PhysicalPresenceCommandSet(commandCode: TPM_CC);
}
extern "C" {
    pub fn PhysicalPresenceCommandClear(commandCode: TPM_CC);
}
extern "C" {
    pub fn PhysicalPresenceIsRequired(commandIndex: COMMAND_INDEX) -> BOOL;
}
extern "C" {
    pub fn PhysicalPresenceCapGetCCList(
        commandCode: TPM_CC,
        count: UINT32,
        commandList: *mut TPML_CC,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn CommandAuditPreInstall_Init();
}
extern "C" {
    pub fn CommandAuditStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn CommandAuditSet(commandCode: TPM_CC) -> BOOL;
}
extern "C" {
    pub fn CommandAuditClear(commandCode: TPM_CC) -> BOOL;
}
extern "C" {
    pub fn CommandAuditIsRequired(commandIndex: COMMAND_INDEX) -> BOOL;
}
extern "C" {
    pub fn CommandAuditCapGetCCList(
        commandCode: TPM_CC,
        count: UINT32,
        commandList: *mut TPML_CC,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn CommandAuditGetDigest(digest: *mut TPM2B_DIGEST);
}

extern "C" {
    pub fn _plat__SwitchTimeUsed() -> crate::cty::c_ulong;
}

extern "C" {
    pub fn _plat__TPM_Terminate() -> crate::cty::c_int;
}

extern "C" {
    pub fn _plat__TPM_Initialize(
        firstTime: crate::cty::c_int,
        platParameter: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}

extern "C" {
    pub fn TPM_Manufacture(firstTime: crate::cty::c_int) -> crate::cty::c_int;
}
extern "C" {
    pub fn TPM_TearDown() -> crate::cty::c_int;
}
extern "C" {
    pub fn TpmEndSimulation();
}
extern "C" {
    pub fn HandleGetType(handle: TPM_HANDLE) -> TPM_HT;
}
extern "C" {
    pub fn NextPermanentHandle(inHandle: TPM_HANDLE) -> TPM_HANDLE;
}
extern "C" {
    pub fn PermanentCapGetHandles(
        handle: TPM_HANDLE,
        count: UINT32,
        handleList: *mut TPML_HANDLE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn PermanentHandleGetPolicy(
        handle: TPM_HANDLE,
        count: UINT32,
        policyList: *mut TPML_TAGGED_POLICY,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn TPMInit();
}
extern "C" {
    pub fn TPMRegisterStartup() -> BOOL;
}
extern "C" {
    pub fn TPMIsStarted() -> BOOL;
}
extern "C" {
    pub fn BuildResponseHeader(command: *mut COMMAND, buffer: *mut BYTE, result: TPM_RC);
}
extern "C" {
    pub fn ParseHandleBuffer(command: *mut COMMAND) -> TPM_RC;
}
extern "C" {
    pub fn CommandDispatcher(command: *mut COMMAND) -> TPM_RC;
}
extern "C" {
    pub fn AcToCapabilities(component: TPMI_RH_AC) -> *mut TPML_AC_CAPABILITIES;
}
extern "C" {
    pub fn AcIsAccessible(acHandle: TPM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn AcCapabilitiesGet(
        component: TPMI_RH_AC,
        type_: TPM_AT,
        count: UINT32,
        capabilityList: *mut TPML_AC_CAPABILITIES,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn AcSendObject(
        acHandle: TPM_HANDLE,
        object: *mut OBJECT,
        acDataOut: *mut TPMS_AC_OUTPUT,
    ) -> TPM_RC;
}
extern "C" {
    pub fn TestBit(
        bitNum: crate::cty::c_uint,
        bArray: *mut BYTE,
        bytesInArray: crate::cty::c_uint,
    ) -> BOOL;
}
extern "C" {
    pub fn SetBit(bitNum: crate::cty::c_uint, bArray: *mut BYTE, bytesInArray: crate::cty::c_uint);
}
extern "C" {
    pub fn ClearBit(
        bitNum: crate::cty::c_uint,
        bArray: *mut BYTE,
        bytesInArray: crate::cty::c_uint,
    );
}
extern "C" {
    pub fn AlgorithmCapGetImplemented(
        algID: TPM_ALG_ID,
        count: UINT32,
        algList: *mut TPML_ALG_PROPERTY,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn AlgorithmGetImplementedVector(implemented: *mut ALGORITHM_VECTOR);
}
extern "C" {
    pub fn TPMCapGetProperties(
        property: TPM_PT,
        count: UINT32,
        propertyList: *mut TPML_TAGGED_TPM_PROPERTY,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn MemoryIoBufferAllocationReset();
}
extern "C" {
    pub fn MemoryIoBufferZero();
}
extern "C" {
    pub fn MemoryGetInBuffer(size: UINT32) -> *mut BYTE;
}
extern "C" {
    pub fn MemoryGetOutBuffer(size: UINT32) -> *mut BYTE;
}
extern "C" {
    pub fn IsLabelProperlyFormatted(x: *mut TPM2B) -> BOOL;
}
extern "C" {
    pub fn MemoryCopy(
        dest: *mut crate::cty::c_void,
        src: *const crate::cty::c_void,
        sSize: crate::cty::c_int,
    );
}
extern "C" {
    pub fn MemoryEqual(
        buffer1: *const crate::cty::c_void,
        buffer2: *const crate::cty::c_void,
        size: crate::cty::c_uint,
    ) -> BOOL;
}
extern "C" {
    pub fn MemoryCopy2B(dest: *mut TPM2B, source: *const TPM2B, dSize: crate::cty::c_uint)
        -> INT16;
}
extern "C" {
    pub fn MemoryConcat2B(aInOut: *mut TPM2B, bIn: *mut TPM2B, aMaxSize: crate::cty::c_uint);
}
extern "C" {
    pub fn MemoryEqual2B(aIn: *const TPM2B, bIn: *const TPM2B) -> BOOL;
}
extern "C" {
    pub fn MemorySet(dest: *mut crate::cty::c_void, value: crate::cty::c_int, size: size_t);
}
extern "C" {
    pub fn MemoryPad2B(b: *mut TPM2B, newSize: UINT16);
}
extern "C" {
    pub fn Uint16ToByteArray(i: UINT16, a: *mut BYTE);
}
extern "C" {
    pub fn Uint32ToByteArray(i: UINT32, a: *mut BYTE);
}
extern "C" {
    pub fn Uint64ToByteArray(i: UINT64, a: *mut BYTE);
}
extern "C" {
    pub fn ByteArrayToUint8(a: *mut BYTE) -> UINT8;
}
extern "C" {
    pub fn ByteArrayToUint16(a: *mut BYTE) -> UINT16;
}
extern "C" {
    pub fn ByteArrayToUint32(a: *mut BYTE) -> UINT32;
}
extern "C" {
    pub fn ByteArrayToUint64(a: *mut BYTE) -> UINT64;
}
extern "C" {
    pub fn RcSafeAddToResult(responseCode: TPM_RC, modifier: TPM_RC) -> TPM_RC;
}
extern "C" {
    pub fn BnFromBytes(bn: bigNum, bytes: *const BYTE, nBytes: NUMBYTES) -> bigNum;
}
extern "C" {
    pub fn BnFrom2B(bn: bigNum, a2B: *const TPM2B) -> bigNum;
}
extern "C" {
    pub fn BnFromHex(bn: bigNum, hex: *const crate::cty::c_char) -> bigNum;
}
extern "C" {
    pub fn BnToBytes(bn: bigConst, buffer: *mut BYTE, size: *mut NUMBYTES) -> BOOL;
}
extern "C" {
    pub fn BnTo2B(bn: bigConst, a2B: *mut TPM2B, size: NUMBYTES) -> BOOL;
}
extern "C" {
    pub fn BnPointFrom2B(ecP: bigPoint, p: *mut TPMS_ECC_POINT) -> *mut bn_point_t;
}
extern "C" {
    pub fn BnPointTo2B(p: *mut TPMS_ECC_POINT, ecP: bigPoint, E: bigCurve) -> BOOL;
}
extern "C" {
    pub fn BnAdd(result: bigNum, op1: bigConst, op2: bigConst) -> BOOL;
}
extern "C" {
    pub fn BnAddWord(result: bigNum, op: bigConst, word: crypt_uword_t) -> BOOL;
}
extern "C" {
    pub fn BnSub(result: bigNum, op1: bigConst, op2: bigConst) -> BOOL;
}
extern "C" {
    pub fn BnSubWord(result: bigNum, op: bigConst, word: crypt_uword_t) -> BOOL;
}
extern "C" {
    pub fn BnUnsignedCmp(op1: bigConst, op2: bigConst) -> crate::cty::c_int;
}
extern "C" {
    pub fn BnUnsignedCmpWord(op1: bigConst, word: crypt_uword_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn BnModWord(numerator: bigConst, modulus: crypt_word_t) -> crypt_word_t;
}
extern "C" {
    pub fn Msb(word: crypt_uword_t) -> crate::cty::c_int;
}
extern "C" {
    pub fn BnMsb(bn: bigConst) -> crate::cty::c_int;
}
extern "C" {
    pub fn BnSizeInBits(n: bigConst) -> crate::cty::c_uint;
}
extern "C" {
    pub fn BnSetWord(n: bigNum, w: crypt_uword_t) -> bigNum;
}
extern "C" {
    pub fn BnSetBit(bn: bigNum, bitNum: crate::cty::c_uint) -> BOOL;
}
extern "C" {
    pub fn BnTestBit(bn: bigNum, bitNum: crate::cty::c_uint) -> BOOL;
}
extern "C" {
    pub fn BnMaskBits(bn: bigNum, maskBit: crypt_uword_t) -> BOOL;
}
extern "C" {
    pub fn BnShiftRight(result: bigNum, toShift: bigConst, shiftAmount: u32) -> BOOL;
}
extern "C" {
    pub fn BnGetRandomBits(n: bigNum, bits: size_t, rand: *mut RAND_STATE) -> BOOL;
}
extern "C" {
    pub fn BnGenerateRandomInRange(dest: bigNum, limit: bigConst, rand: *mut RAND_STATE) -> BOOL;
}
extern "C" {
    pub fn BnSetTop(bn: bigNum, top: crypt_uword_t) -> bigNum;
}
extern "C" {
    pub fn BnClearTop(bn: bigNum) -> bigNum;
}
extern "C" {
    pub fn BnInitializeWord(bn: bigNum, allocated: crypt_uword_t, word: crypt_uword_t) -> bigNum;
}
extern "C" {
    pub fn BnInit(bn: bigNum, allocated: crypt_uword_t) -> bigNum;
}
extern "C" {
    pub fn BnCopy(out: bigNum, in_: bigConst) -> BOOL;
}
extern "C" {
    pub fn BnPointCopy(pOut: bigPoint, pIn: pointConst) -> BOOL;
}
extern "C" {
    pub fn BnInitializePoint(p: bigPoint, x: bigNum, y: bigNum, z: bigNum) -> *mut bn_point_t;
}
extern "C" {
    pub fn TicketIsSafe(buffer: *mut TPM2B) -> BOOL;
}
extern "C" {
    pub fn TicketComputeVerified(
        hierarchy: TPMI_RH_HIERARCHY,
        digest: *mut TPM2B_DIGEST,
        keyName: *mut TPM2B_NAME,
        ticket: *mut TPMT_TK_VERIFIED,
    );
}
extern "C" {
    pub fn TicketComputeAuth(
        type_: TPM_ST,
        hierarchy: TPMI_RH_HIERARCHY,
        timeout: UINT64,
        expiresOnReset: BOOL,
        cpHashA: *mut TPM2B_DIGEST,
        policyRef: *mut TPM2B_NONCE,
        entityName: *mut TPM2B_NAME,
        ticket: *mut TPMT_TK_AUTH,
    );
}
extern "C" {
    pub fn TicketComputeHashCheck(
        hierarchy: TPMI_RH_HIERARCHY,
        hashAlg: TPM_ALG_ID,
        digest: *mut TPM2B_DIGEST,
        ticket: *mut TPMT_TK_HASHCHECK,
    );
}
extern "C" {
    pub fn TicketComputeCreation(
        hierarchy: TPMI_RH_HIERARCHY,
        name: *mut TPM2B_NAME,
        creation: *mut TPM2B_DIGEST,
        ticket: *mut TPMT_TK_CREATION,
    );
}
extern "C" {
    pub fn CryptIsSchemeAnonymous(scheme: TPM_ALG_ID) -> BOOL;
}
extern "C" {
    pub fn ParmDecryptSym(
        symAlg: TPM_ALG_ID,
        hash: TPM_ALG_ID,
        keySizeInBits: UINT16,
        key: *mut TPM2B,
        nonceCaller: *mut TPM2B,
        nonceTpm: *mut TPM2B,
        dataSize: UINT32,
        data: *mut BYTE,
    );
}
extern "C" {
    pub fn ParmEncryptSym(
        symAlg: TPM_ALG_ID,
        hash: TPM_ALG_ID,
        keySizeInBits: UINT16,
        key: *mut TPM2B,
        nonceCaller: *mut TPM2B,
        nonceTpm: *mut TPM2B,
        dataSize: UINT32,
        data: *mut BYTE,
    );
}
extern "C" {
    pub fn CryptXORObfuscation(
        hash: TPM_ALG_ID,
        key: *mut TPM2B,
        contextU: *mut TPM2B,
        contextV: *mut TPM2B,
        dataSize: UINT32,
        data: *mut BYTE,
    );
}
extern "C" {
    pub fn CryptInit() -> BOOL;
}
extern "C" {
    pub fn CryptStartup(type_: STARTUP_TYPE) -> BOOL;
}
extern "C" {
    pub fn CryptIsAsymAlgorithm(algID: TPM_ALG_ID) -> BOOL;
}
extern "C" {
    pub fn CryptSecretEncrypt(
        encryptKey: *mut OBJECT,
        label: *const TPM2B,
        data: *mut TPM2B_DATA,
        secret: *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptSecretDecrypt(
        decryptKey: *mut OBJECT,
        nonceCaller: *mut TPM2B_NONCE,
        label: *const TPM2B,
        secret: *mut TPM2B_ENCRYPTED_SECRET,
        data: *mut TPM2B_DATA,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptParameterEncryption(
        handle: TPM_HANDLE,
        nonceCaller: *mut TPM2B,
        leadingSizeInByte: UINT16,
        extraKey: *mut TPM2B_AUTH,
        buffer: *mut BYTE,
    );
}
extern "C" {
    pub fn CryptParameterDecryption(
        handle: TPM_HANDLE,
        nonceCaller: *mut TPM2B,
        bufferSize: UINT32,
        leadingSizeInByte: UINT16,
        extraKey: *mut TPM2B_AUTH,
        buffer: *mut BYTE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptComputeSymmetricUnique(
        publicArea: *mut TPMT_PUBLIC,
        sensitive: *mut TPMT_SENSITIVE,
        unique: *mut TPM2B_DIGEST,
    );
}
extern "C" {
    pub fn CryptCreateObject(
        object: *mut OBJECT,
        sensitiveCreate: *mut TPMS_SENSITIVE_CREATE,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptGetSignHashAlg(auth: *mut TPMT_SIGNATURE) -> TPMI_ALG_HASH;
}
extern "C" {
    pub fn CryptIsSplitSign(scheme: TPM_ALG_ID) -> BOOL;
}
extern "C" {
    pub fn CryptIsAsymSignScheme(publicType: TPMI_ALG_PUBLIC, scheme: TPMI_ALG_ASYM_SCHEME)
        -> BOOL;
}
extern "C" {
    pub fn CryptIsAsymDecryptScheme(
        publicType: TPMI_ALG_PUBLIC,
        scheme: TPMI_ALG_ASYM_SCHEME,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSelectSignScheme(signObject: *mut OBJECT, scheme: *mut TPMT_SIG_SCHEME) -> BOOL;
}
extern "C" {
    pub fn CryptSign(
        signKey: *mut OBJECT,
        signScheme: *mut TPMT_SIG_SCHEME,
        digest: *mut TPM2B_DIGEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptValidateSignature(
        keyHandle: TPMI_DH_OBJECT,
        digest: *mut TPM2B_DIGEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptGetTestResult(outData: *mut TPM2B_MAX_BUFFER) -> TPM_RC;
}
extern "C" {
    pub fn CryptValidateKeys(
        publicArea: *mut TPMT_PUBLIC,
        sensitive: *mut TPMT_SENSITIVE,
        blamePublic: TPM_RC,
        blameSensitive: TPM_RC,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptSelectMac(publicArea: *mut TPMT_PUBLIC, inMac: *mut TPMI_ALG_MAC_SCHEME) -> TPM_RC;
}
extern "C" {
    pub fn CryptMacIsValidForKey(keyType: TPM_ALG_ID, macAlg: TPM_ALG_ID, flag: BOOL) -> BOOL;
}
extern "C" {
    pub fn CryptSmacIsValidAlg(alg: TPM_ALG_ID, FLAG: BOOL) -> BOOL;
}
extern "C" {
    pub fn CryptSymModeIsValid(mode: TPM_ALG_ID, flag: BOOL) -> BOOL;
}
extern "C" {
    pub fn CryptHashInit() -> BOOL;
}
extern "C" {
    pub fn CryptHashStartup() -> BOOL;
}
extern "C" {
    pub fn CryptGetHashDef(hashAlg: TPM_ALG_ID) -> PHASH_DEF;
}
extern "C" {
    pub fn CryptHashIsValidAlg(hashAlg: TPM_ALG_ID, flag: BOOL) -> BOOL;
}
extern "C" {
    pub fn CryptHashGetAlgByIndex(index: UINT32) -> TPM_ALG_ID;
}
extern "C" {
    pub fn CryptHashGetDigestSize(hashAlg: TPM_ALG_ID) -> UINT16;
}
extern "C" {
    pub fn CryptHashGetBlockSize(hashAlg: TPM_ALG_ID) -> UINT16;
}
extern "C" {
    pub fn CryptHashGetOid(hashAlg: TPM_ALG_ID) -> *const BYTE;
}
extern "C" {
    pub fn CryptHashGetContextAlg(state: PHASH_STATE) -> TPM_ALG_ID;
}
extern "C" {
    pub fn CryptHashCopyState(out: *mut HASH_STATE, in_: *const HASH_STATE);
}
extern "C" {
    pub fn CryptHashExportState(internalFmt: PCHASH_STATE, externalFmt: PEXPORT_HASH_STATE);
}
extern "C" {
    pub fn CryptHashImportState(internalFmt: PHASH_STATE, externalFmt: PCEXPORT_HASH_STATE);
}
extern "C" {
    pub fn CryptHashStart(hashState: PHASH_STATE, hashAlg: TPM_ALG_ID) -> UINT16;
}
extern "C" {
    pub fn CryptDigestUpdate(hashState: PHASH_STATE, dataSize: UINT32, data: *const BYTE);
}
extern "C" {
    pub fn CryptHashEnd(hashState: PHASH_STATE, dOutSize: UINT32, dOut: *mut BYTE) -> UINT16;
}
extern "C" {
    pub fn CryptHashBlock(
        hashAlg: TPM_ALG_ID,
        dataSize: UINT32,
        data: *const BYTE,
        dOutSize: UINT32,
        dOut: *mut BYTE,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptDigestUpdate2B(state: PHASH_STATE, bIn: *const TPM2B);
}
extern "C" {
    pub fn CryptHashEnd2B(state: PHASH_STATE, digest: P2B) -> UINT16;
}
extern "C" {
    pub fn CryptDigestUpdateInt(state: *mut crate::cty::c_void, intSize: UINT32, intValue: UINT64);
}
extern "C" {
    pub fn CryptHmacStart(
        state: PHMAC_STATE,
        hashAlg: TPM_ALG_ID,
        keySize: UINT16,
        key: *const BYTE,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptHmacEnd(state: PHMAC_STATE, dOutSize: UINT32, dOut: *mut BYTE) -> UINT16;
}
extern "C" {
    pub fn CryptHmacStart2B(hmacState: PHMAC_STATE, hashAlg: TPMI_ALG_HASH, key: P2B) -> UINT16;
}
extern "C" {
    pub fn CryptHmacEnd2B(hmacState: PHMAC_STATE, digest: P2B) -> UINT16;
}
extern "C" {
    pub fn CryptMGF_KDF(
        mSize: UINT32,
        mask: *mut BYTE,
        hashAlg: TPM_ALG_ID,
        seedSize: UINT32,
        seed: *mut BYTE,
        counter: UINT32,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptKDFa(
        hashAlg: TPM_ALG_ID,
        key: *const TPM2B,
        label: *const TPM2B,
        contextU: *const TPM2B,
        contextV: *const TPM2B,
        sizeInBits: UINT32,
        keyStream: *mut BYTE,
        counterInOut: *mut UINT32,
        blocks: UINT16,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptKDFe(
        hashAlg: TPM_ALG_ID,
        Z: *mut TPM2B,
        label: *const TPM2B,
        partyUInfo: *mut TPM2B,
        partyVInfo: *mut TPM2B,
        sizeInBits: UINT32,
        keyStream: *mut BYTE,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptSymInit() -> BOOL;
}
extern "C" {
    pub fn CryptSymStartup() -> BOOL;
}
extern "C" {
    pub fn CryptGetSymmetricBlockSize(symmetricAlg: TPM_ALG_ID, keySizeInBits: UINT16) -> INT16;
}
extern "C" {
    pub fn CryptSymmetricEncrypt(
        dOut: *mut BYTE,
        algorithm: TPM_ALG_ID,
        keySizeInBits: UINT16,
        key: *const BYTE,
        ivInOut: *mut TPM2B_IV,
        mode: TPM_ALG_ID,
        dSize: INT32,
        dIn: *const BYTE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptSymmetricDecrypt(
        dOut: *mut BYTE,
        algorithm: TPM_ALG_ID,
        keySizeInBits: UINT16,
        key: *const BYTE,
        ivInOut: *mut TPM2B_IV,
        mode: TPM_ALG_ID,
        dSize: INT32,
        dIn: *const BYTE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptSymKeyValidate(symDef: *mut TPMT_SYM_DEF_OBJECT, key: *mut TPM2B_SYM_KEY)
        -> TPM_RC;
}
extern "C" {
    pub fn IsPrimeInt(n: u32) -> BOOL;
}
extern "C" {
    pub fn BnIsProbablyPrime(prime: bigNum, rand: *mut RAND_STATE) -> BOOL;
}
extern "C" {
    pub fn MillerRabinRounds(bits: UINT32) -> UINT32;
}
extern "C" {
    pub fn MillerRabin(bnW: bigNum, rand: *mut RAND_STATE) -> BOOL;
}
extern "C" {
    pub fn RsaCheckPrime(prime: bigNum, exponent: UINT32, rand: *mut RAND_STATE) -> TPM_RC;
}
extern "C" {
    pub fn RsaAdjustPrimeCandidate(prime: bigNum);
}
extern "C" {
    pub fn BnGeneratePrimeForRSA(
        prime: bigNum,
        bits: UINT32,
        exponent: UINT32,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn DRBG_GetEntropy(requiredEntropy: UINT32, entropy: *mut BYTE) -> BOOL;
}
extern "C" {
    pub fn IncrementIv(iv: *mut DRBG_IV);
}
extern "C" {
    pub fn DRBG_Reseed(
        drbgState: *mut DRBG_STATE,
        providedEntropy: *mut DRBG_SEED,
        additionalData: *mut DRBG_SEED,
    ) -> BOOL;
}
extern "C" {
    pub fn DRBG_SelfTest() -> BOOL;
}
extern "C" {
    pub fn CryptRandomStir(additionalDataSize: UINT16, additionalData: *mut BYTE) -> TPM_RC;
}
extern "C" {
    pub fn CryptRandomGenerate(randomSize: UINT16, buffer: *mut BYTE) -> UINT16;
}
extern "C" {
    pub fn DRBG_InstantiateSeededKdf(
        state: *mut KDF_STATE,
        hashAlg: TPM_ALG_ID,
        kdf: TPM_ALG_ID,
        seed: *mut TPM2B,
        label: *const TPM2B,
        context: *mut TPM2B,
        limit: UINT32,
    ) -> BOOL;
}
extern "C" {
    pub fn DRBG_AdditionalData(drbgState: *mut DRBG_STATE, additionalData: *mut TPM2B);
}
extern "C" {
    pub fn DRBG_InstantiateSeeded(
        drbgState: *mut DRBG_STATE,
        seed: *const TPM2B,
        purpose: *const TPM2B,
        name: *const TPM2B,
        additional: *const TPM2B,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptRandStartup() -> BOOL;
}
extern "C" {
    pub fn CryptRandInit() -> BOOL;
}
extern "C" {
    pub fn DRBG_Generate(state: *mut RAND_STATE, random: *mut BYTE, randomSize: UINT16) -> UINT16;
}
extern "C" {
    pub fn DRBG_Instantiate(
        drbgState: *mut DRBG_STATE,
        pSize: UINT16,
        personalization: *mut BYTE,
    ) -> BOOL;
}
extern "C" {
    pub fn DRBG_Uninstantiate(drbgState: *mut DRBG_STATE) -> TPM_RC;
}
extern "C" {
    pub fn CryptSelfTest(fullTest: TPMI_YES_NO) -> TPM_RC;
}
extern "C" {
    pub fn CryptIncrementalSelfTest(toTest: *mut TPML_ALG, toDoList: *mut TPML_ALG) -> TPM_RC;
}
extern "C" {
    pub fn CryptInitializeToTest();
}
extern "C" {
    pub fn CryptTestAlgorithm(alg: TPM_ALG_ID, toTest: *mut ALGORITHM_VECTOR) -> TPM_RC;
}
extern "C" {
    pub fn UnsignedCompareB(
        aSize: UINT32,
        a: *const BYTE,
        bSize: UINT32,
        b: *const BYTE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn SignedCompareB(
        aSize: UINT32,
        a: *const BYTE,
        bSize: UINT32,
        b: *const BYTE,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn ModExpB(
        cSize: UINT32,
        c: *mut BYTE,
        mSize: UINT32,
        m: *const BYTE,
        eSize: UINT32,
        e: *const BYTE,
        nSize: UINT32,
        n: *const BYTE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn DivideB(n: *const TPM2B, d: *const TPM2B, q: *mut TPM2B, r: *mut TPM2B) -> TPM_RC;
}
extern "C" {
    pub fn AdjustNumberB(num: *mut TPM2B, requestedSize: UINT16) -> UINT16;
}
extern "C" {
    pub fn ShiftLeft(value: *mut TPM2B) -> *mut TPM2B;
}
extern "C" {
    pub fn TestAlgorithm(alg: TPM_ALG_ID, toTest: *mut ALGORITHM_VECTOR) -> TPM_RC;
}
extern "C" {
    pub fn CryptRsaInit() -> BOOL;
}
extern "C" {
    pub fn CryptRsaStartup() -> BOOL;
}
extern "C" {
    pub fn CryptRsaPssSaltSize(hashSize: INT16, outSize: INT16) -> INT16;
}
extern "C" {
    pub fn MakeDerTag(hashAlg: TPM_ALG_ID, sizeOfBuffer: INT16, buffer: *mut BYTE) -> INT16;
}
extern "C" {
    pub fn CryptRsaSelectScheme(
        rsaHandle: TPMI_DH_OBJECT,
        scheme: *mut TPMT_RSA_DECRYPT,
    ) -> *mut TPMT_RSA_DECRYPT;
}
extern "C" {
    pub fn CryptRsaLoadPrivateExponent(
        publicArea: *mut TPMT_PUBLIC,
        sensitive: *mut TPMT_SENSITIVE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptRsaEncrypt(
        cOut: *mut TPM2B_PUBLIC_KEY_RSA,
        dIn: *mut TPM2B,
        key: *mut OBJECT,
        scheme: *mut TPMT_RSA_DECRYPT,
        label: *const TPM2B,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptRsaDecrypt(
        dOut: *mut TPM2B,
        cIn: *mut TPM2B,
        key: *mut OBJECT,
        scheme: *mut TPMT_RSA_DECRYPT,
        label: *const TPM2B,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptRsaSign(
        sigOut: *mut TPMT_SIGNATURE,
        key: *mut OBJECT,
        hIn: *mut TPM2B_DIGEST,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptRsaValidateSignature(
        sig: *mut TPMT_SIGNATURE,
        key: *mut OBJECT,
        digest: *mut TPM2B_DIGEST,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptRsaGenerateKey(
        publicArea: *mut TPMT_PUBLIC,
        sensitive: *mut TPMT_SENSITIVE,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn RsaAdjustPrimeLimit(requestedPrimes: u32);
}
extern "C" {
    pub fn RsaNextPrime(lastPrime: u32) -> u32;
}
extern "C" {
    pub fn FindNthSetBit(aSize: UINT16, a: *const BYTE, n: UINT32) -> crate::cty::c_int;
}
extern "C" {
    pub fn PrimeSieve(bnN: bigNum, fieldSize: UINT32, field: *mut BYTE) -> UINT32;
}
extern "C" {
    pub fn PrimeSelectWithSieve(candidate: bigNum, e: UINT32, rand: *mut RAND_STATE) -> TPM_RC;
}
extern "C" {
    pub fn RsaSimulationEnd();
}
extern "C" {
    pub fn EccSimulationEnd();
}
extern "C" {
    pub fn CryptEccInit() -> BOOL;
}
extern "C" {
    pub fn CryptEccStartup() -> BOOL;
}
extern "C" {
    pub fn ClearPoint2B(p: *mut TPMS_ECC_POINT);
}
extern "C" {
    pub fn CryptEccGetParametersByCurveId(curveId: TPM_ECC_CURVE) -> *const ECC_CURVE;
}
extern "C" {
    pub fn CryptEccGetKeySizeForCurve(curveId: TPM_ECC_CURVE) -> UINT16;
}
extern "C" {
    pub fn GetCurveData(curveId: TPM_ECC_CURVE) -> *const ECC_CURVE_DATA;
}
extern "C" {
    pub fn CryptEccGetOID(curveId: TPM_ECC_CURVE) -> *const BYTE;
}
extern "C" {
    pub fn CryptEccGetCurveByIndex(i: UINT16) -> TPM_ECC_CURVE;
}
extern "C" {
    pub fn CryptEccGetParameter(
        out: *mut TPM2B_ECC_PARAMETER,
        p: crate::cty::c_char,
        curveId: TPM_ECC_CURVE,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptCapGetECCCurve(
        curveID: TPM_ECC_CURVE,
        maxCount: UINT32,
        curveList: *mut TPML_ECC_CURVE,
    ) -> TPMI_YES_NO;
}
extern "C" {
    pub fn CryptGetCurveSignScheme(curveId: TPM_ECC_CURVE) -> *const TPMT_ECC_SCHEME;
}
extern "C" {
    pub fn CryptGenerateR(
        r: *mut TPM2B_ECC_PARAMETER,
        c: *mut UINT16,
        curveID: TPMI_ECC_CURVE,
        name: *mut TPM2B_NAME,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptCommit() -> UINT16;
}
extern "C" {
    pub fn CryptEndCommit(c: UINT16);
}
extern "C" {
    pub fn CryptEccGetParameters(
        curveId: TPM_ECC_CURVE,
        parameters: *mut TPMS_ALGORITHM_DETAIL_ECC,
    ) -> BOOL;
}
extern "C" {
    pub fn BnGetCurvePrime(curveId: TPM_ECC_CURVE) -> *const bignum_t;
}
extern "C" {
    pub fn BnGetCurveOrder(curveId: TPM_ECC_CURVE) -> *const bignum_t;
}
extern "C" {
    pub fn BnIsOnCurve(Q: pointConst, C: *const ECC_CURVE_DATA) -> BOOL;
}
extern "C" {
    pub fn BnIsValidPrivateEcc(x: bigConst, E: bigCurve) -> BOOL;
}
extern "C" {
    pub fn CryptEccIsValidPrivateKey(d: *mut TPM2B_ECC_PARAMETER, curveId: TPM_ECC_CURVE) -> BOOL;
}
extern "C" {
    pub fn BnPointMult(
        R: bigPoint,
        S: pointConst,
        d: bigConst,
        Q: pointConst,
        u: bigConst,
        E: bigCurve,
    ) -> TPM_RC;
}
extern "C" {
    pub fn BnEccGetPrivate(dOut: bigNum, C: *const ECC_CURVE_DATA, rand: *mut RAND_STATE) -> BOOL;
}
extern "C" {
    pub fn BnEccGenerateKeyPair(
        bnD: bigNum,
        ecQ: *mut bn_point_t,
        E: bigCurve,
        rand: *mut RAND_STATE,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEccNewKeyPair(
        Qout: *mut TPMS_ECC_POINT,
        dOut: *mut TPM2B_ECC_PARAMETER,
        curveId: TPM_ECC_CURVE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEccPointMultiply(
        Rout: *mut TPMS_ECC_POINT,
        curveId: TPM_ECC_CURVE,
        Pin: *mut TPMS_ECC_POINT,
        dIn: *mut TPM2B_ECC_PARAMETER,
        Qin: *mut TPMS_ECC_POINT,
        uIn: *mut TPM2B_ECC_PARAMETER,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEccIsPointOnCurve(curveId: TPM_ECC_CURVE, Qin: *mut TPMS_ECC_POINT) -> BOOL;
}
extern "C" {
    pub fn CryptEccGenerateKey(
        publicArea: *mut TPMT_PUBLIC,
        sensitive: *mut TPMT_SENSITIVE,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn BnSignEcdsa(
        bnR: bigNum,
        bnS: bigNum,
        E: bigCurve,
        bnD: bigNum,
        digest: *const TPM2B_DIGEST,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEccSign(
        signature: *mut TPMT_SIGNATURE,
        signKey: *mut OBJECT,
        digest: *const TPM2B_DIGEST,
        scheme: *mut TPMT_ECC_SCHEME,
        rand: *mut RAND_STATE,
    ) -> TPM_RC;
}
extern "C" {
    pub fn BnValidateSignatureEcdsa(
        bnR: bigNum,
        bnS: bigNum,
        E: bigCurve,
        ecQ: *mut bn_point_t,
        digest: *const TPM2B_DIGEST,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEccValidateSignature(
        signature: *mut TPMT_SIGNATURE,
        signKey: *mut OBJECT,
        digest: *const TPM2B_DIGEST,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEccCommitCompute(
        K: *mut TPMS_ECC_POINT,
        L: *mut TPMS_ECC_POINT,
        E: *mut TPMS_ECC_POINT,
        curveId: TPM_ECC_CURVE,
        M: *mut TPMS_ECC_POINT,
        B: *mut TPMS_ECC_POINT,
        d: *mut TPM2B_ECC_PARAMETER,
        r: *mut TPM2B_ECC_PARAMETER,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEcc2PhaseKeyExchange(
        outZ1: *mut TPMS_ECC_POINT,
        outZ2: *mut TPMS_ECC_POINT,
        curveId: TPM_ECC_CURVE,
        scheme: TPM_ALG_ID,
        dsA: *mut TPM2B_ECC_PARAMETER,
        deA: *mut TPM2B_ECC_PARAMETER,
        QsB: *mut TPMS_ECC_POINT,
        QeB: *mut TPMS_ECC_POINT,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEccSelectScheme(key: *mut OBJECT, scheme: *mut TPMT_KDF_SCHEME) -> BOOL;
}
extern "C" {
    pub fn CryptEccEncrypt(
        key: *mut OBJECT,
        scheme: *mut TPMT_KDF_SCHEME,
        plainText: *mut TPM2B_MAX_BUFFER,
        c1: *mut TPMS_ECC_POINT,
        c2: *mut TPM2B_MAX_BUFFER,
        c3: *mut TPM2B_DIGEST,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptEccDecrypt(
        key: *mut OBJECT,
        scheme: *mut TPMT_KDF_SCHEME,
        plainText: *mut TPM2B_MAX_BUFFER,
        c1: *mut TPMS_ECC_POINT,
        c2: *mut TPM2B_MAX_BUFFER,
        c3: *mut TPM2B_DIGEST,
    ) -> TPM_RC;
}
extern "C" {
    pub fn CryptSmacStart(
        state: *mut HASH_STATE,
        keyParameters: *mut TPMU_PUBLIC_PARMS,
        macAlg: TPM_ALG_ID,
        key: *mut TPM2B,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptMacStart(
        state: *mut HMAC_STATE,
        keyParameters: *mut TPMU_PUBLIC_PARMS,
        macAlg: TPM_ALG_ID,
        key: *mut TPM2B,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptMacEnd(state: *mut HMAC_STATE, size: UINT32, buffer: *mut BYTE) -> UINT16;
}
extern "C" {
    pub fn CryptMacEnd2B(state: *mut HMAC_STATE, data: *mut TPM2B) -> UINT16;
}
extern "C" {
    pub fn CryptCmacStart(
        state: *mut SMAC_STATE,
        keyParms: *mut TPMU_PUBLIC_PARMS,
        macAlg: TPM_ALG_ID,
        key: *mut TPM2B,
    ) -> UINT16;
}
extern "C" {
    pub fn CryptCmacData(state: *mut SMAC_STATES, size: UINT32, buffer: *const BYTE);
}
extern "C" {
    pub fn CryptCmacEnd(state: *mut SMAC_STATES, outSize: UINT32, outBuffer: *mut BYTE) -> UINT16;
}
extern "C" {
    pub fn MathLibraryCompatibilityCheck() -> BOOL;
}
extern "C" {
    pub fn BnModMult(result: bigNum, op1: bigConst, op2: bigConst, modulus: bigConst) -> BOOL;
}
extern "C" {
    pub fn BnMult(result: bigNum, multiplicand: bigConst, multiplier: bigConst) -> BOOL;
}
extern "C" {
    pub fn BnDiv(
        quotient: bigNum,
        remainder: bigNum,
        dividend: bigConst,
        divisor: bigConst,
    ) -> BOOL;
}
extern "C" {
    pub fn BnGcd(gcd: bigNum, number1: bigConst, number2: bigConst) -> BOOL;
}
extern "C" {
    pub fn BnModExp(
        result: bigNum,
        number: bigConst,
        exponent: bigConst,
        modulus: bigConst,
    ) -> BOOL;
}
extern "C" {
    pub fn BnModInverse(result: bigNum, number: bigConst, modulus: bigConst) -> BOOL;
}
extern "C" {
    pub fn BnEccModMult(R: bigPoint, S: pointConst, d: bigConst, E: bigCurve) -> BOOL;
}
extern "C" {
    pub fn BnEccModMult2(
        R: bigPoint,
        S: pointConst,
        d: bigConst,
        Q: pointConst,
        u: bigConst,
        E: bigCurve,
    ) -> BOOL;
}
extern "C" {
    pub fn BnEccAdd(R: bigPoint, S: pointConst, Q: pointConst, E: bigCurve) -> BOOL;
}
extern "C" {
    pub fn BnCurveInitialize(E: bigCurve, curveId: TPM_ECC_CURVE) -> bigCurve;
}
extern "C" {
    pub fn BnCurveFree(E: bigCurve);
}
extern "C" {
    pub fn _plat__IsCanceled() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__SetCancel();
}
extern "C" {
    pub fn _plat__ClearCancel();
}
extern "C" {
    pub fn _plat__TimerReset();
}
extern "C" {
    pub fn _plat__TimerRestart();
}
extern "C" {
    pub fn _plat__RealTime() -> u64;
}
extern "C" {
    pub fn _plat__TimerRead() -> u64;
}
extern "C" {
    pub fn _plat__TimerWasReset() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__TimerWasStopped() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__ClockAdjustRate(adjust: crate::cty::c_int);
}
extern "C" {
    pub fn DebugFileInit() -> crate::cty::c_int;
}
extern "C" {
    pub fn DebugDumpBuffer(
        size: crate::cty::c_int,
        buf: *mut crate::cty::c_uchar,
        identifier: *const crate::cty::c_char,
    );
}
extern "C" {
    pub fn _plat__GetEntropy(entropy: *mut crate::cty::c_uchar, amount: u32) -> i32;
}
extern "C" {
    pub fn _plat__LocalityGet() -> crate::cty::c_uchar;
}
extern "C" {
    pub fn _plat__LocalitySet(locality: crate::cty::c_uchar);
}
extern "C" {
    pub fn _plat__NvErrors(recoverable: crate::cty::c_int, unrecoverable: crate::cty::c_int);
}
extern "C" {
    pub fn _plat__NVEnable(platParameter: *mut crate::cty::c_void) -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__NVDisable(delete: crate::cty::c_int);
}
extern "C" {
    pub fn _plat__IsNvAvailable() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__NvMemoryRead(
        startOffset: crate::cty::c_uint,
        size: crate::cty::c_uint,
        data: *mut crate::cty::c_void,
    );
}
extern "C" {
    pub fn _plat__NvIsDifferent(
        startOffset: crate::cty::c_uint,
        size: crate::cty::c_uint,
        data: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__NvMemoryWrite(
        startOffset: crate::cty::c_uint,
        size: crate::cty::c_uint,
        data: *mut crate::cty::c_void,
    ) -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__NvMemoryClear(start: crate::cty::c_uint, size: crate::cty::c_uint);
}
extern "C" {
    pub fn _plat__NvMemoryMove(
        sourceOffset: crate::cty::c_uint,
        destOffset: crate::cty::c_uint,
        size: crate::cty::c_uint,
    );
}
extern "C" {
    pub fn _plat__NvCommit() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__SetNvAvail();
}
extern "C" {
    pub fn _plat__ClearNvAvail();
}
extern "C" {
    pub fn _plat__NVNeedsManufacture() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__ACT_GetImplemented(act: u32) -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__ACT_GetRemaining(act: u32) -> u32;
}
extern "C" {
    pub fn _plat__ACT_GetSignaled(act: u32) -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__ACT_SetSignaled(act: u32, on: crate::cty::c_int);
}
extern "C" {
    pub fn _plat__ACT_GetPending(act: u32) -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__ACT_UpdateCounter(act: u32, newValue: u32) -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__ACT_EnableTicks(enable: crate::cty::c_int);
}
extern "C" {
    pub fn _plat__ACT_Tick();
}
extern "C" {
    pub fn _plat__ACT_Initialize() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__Signal_PowerOn() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__WasPowerLost() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__Signal_Reset() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__Signal_PowerOff();
}
extern "C" {
    pub fn _plat__PhysicalPresenceAsserted() -> crate::cty::c_int;
}
extern "C" {
    pub fn _plat__Signal_PhysicalPresenceOn();
}
extern "C" {
    pub fn _plat__Signal_PhysicalPresenceOff();
}
extern "C" {
    pub fn _plat__RunCommand(
        requestSize: u32,
        request: *mut crate::cty::c_uchar,
        responseSize: *mut u32,
        response: *mut *mut crate::cty::c_uchar,
    );
}
extern "C" {
    pub fn _plat__Fail();
}
extern "C" {
    pub fn _plat__GetUnique(which: u32, bSize: u32, b: *mut crate::cty::c_uchar) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Startup_In {
    pub startupType: TPM_SU,
}
#[test]
fn bindgen_test_layout_Startup_In() {
    assert_eq!(
        ::core::mem::size_of::<Startup_In>(),
        2usize,
        concat!("Size of: ", stringify!(Startup_In))
    );
    assert_eq!(
        ::core::mem::align_of::<Startup_In>(),
        2usize,
        concat!("Alignment of ", stringify!(Startup_In))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Startup_In>())).startupType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Startup_In),
            "::",
            stringify!(startupType)
        )
    );
}
extern "C" {
    pub fn TPM2_Startup(in_: *mut Startup_In) -> TPM_RC;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SelfTest_In {
    pub fullTest: TPMI_YES_NO,
}
#[test]
fn bindgen_test_layout_SelfTest_In() {
    assert_eq!(
        ::core::mem::size_of::<SelfTest_In>(),
        1usize,
        concat!("Size of: ", stringify!(SelfTest_In))
    );
    assert_eq!(
        ::core::mem::align_of::<SelfTest_In>(),
        1usize,
        concat!("Alignment of ", stringify!(SelfTest_In))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SelfTest_In>())).fullTest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SelfTest_In),
            "::",
            stringify!(fullTest)
        )
    );
}
extern "C" {
    pub fn TPM2_SelfTest(in_: *mut SelfTest_In) -> TPM_RC;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetCapability_In {
    pub capability: TPM_CAP,
    pub property: UINT32,
    pub propertyCount: UINT32,
}
#[test]
fn bindgen_test_layout_GetCapability_In() {
    assert_eq!(
        ::core::mem::size_of::<GetCapability_In>(),
        12usize,
        concat!("Size of: ", stringify!(GetCapability_In))
    );
    assert_eq!(
        ::core::mem::align_of::<GetCapability_In>(),
        4usize,
        concat!("Alignment of ", stringify!(GetCapability_In))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GetCapability_In>())).capability as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetCapability_In),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GetCapability_In>())).property as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetCapability_In),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GetCapability_In>())).propertyCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetCapability_In),
            "::",
            stringify!(propertyCount)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GetCapability_Out {
    pub moreData: TPMI_YES_NO,
    pub capabilityData: TPMS_CAPABILITY_DATA,
}
#[test]
fn bindgen_test_layout_GetCapability_Out() {
    assert_eq!(
        ::core::mem::size_of::<GetCapability_Out>(),
        1028usize,
        concat!("Size of: ", stringify!(GetCapability_Out))
    );
    assert_eq!(
        ::core::mem::align_of::<GetCapability_Out>(),
        4usize,
        concat!("Alignment of ", stringify!(GetCapability_Out))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GetCapability_Out>())).moreData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetCapability_Out),
            "::",
            stringify!(moreData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GetCapability_Out>())).capabilityData as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetCapability_Out),
            "::",
            stringify!(capabilityData)
        )
    );
}
extern "C" {
    pub fn TPM2_GetCapability(in_: *mut GetCapability_In, out: *mut GetCapability_Out) -> TPM_RC;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PCR_Extend_In {
    pub pcrHandle: TPMI_DH_PCR,
    pub digests: TPML_DIGEST_VALUES,
}
#[test]
fn bindgen_test_layout_PCR_Extend_In() {
    assert_eq!(
        ::core::mem::size_of::<PCR_Extend_In>(),
        160usize,
        concat!("Size of: ", stringify!(PCR_Extend_In))
    );
    assert_eq!(
        ::core::mem::align_of::<PCR_Extend_In>(),
        4usize,
        concat!("Alignment of ", stringify!(PCR_Extend_In))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_Extend_In>())).pcrHandle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_Extend_In),
            "::",
            stringify!(pcrHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_Extend_In>())).digests as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_Extend_In),
            "::",
            stringify!(digests)
        )
    );
}
extern "C" {
    pub fn TPM2_PCR_Extend(in_: *mut PCR_Extend_In) -> TPM_RC;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCR_Read_In {
    pub pcrSelectionIn: TPML_PCR_SELECTION,
}
#[test]
fn bindgen_test_layout_PCR_Read_In() {
    assert_eq!(
        ::core::mem::size_of::<PCR_Read_In>(),
        24usize,
        concat!("Size of: ", stringify!(PCR_Read_In))
    );
    assert_eq!(
        ::core::mem::align_of::<PCR_Read_In>(),
        4usize,
        concat!("Alignment of ", stringify!(PCR_Read_In))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_Read_In>())).pcrSelectionIn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_Read_In),
            "::",
            stringify!(pcrSelectionIn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct PCR_Read_Out {
    pub pcrUpdateCounter: UINT32,
    pub pcrSelectionOut: TPML_PCR_SELECTION,
    pub pcrValues: TPML_DIGEST,
}
#[test]
fn bindgen_test_layout_PCR_Read_Out() {
    assert_eq!(
        ::core::mem::size_of::<PCR_Read_Out>(),
        432usize,
        concat!("Size of: ", stringify!(PCR_Read_Out))
    );
    assert_eq!(
        ::core::mem::align_of::<PCR_Read_Out>(),
        4usize,
        concat!("Alignment of ", stringify!(PCR_Read_Out))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_Read_Out>())).pcrUpdateCounter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_Read_Out),
            "::",
            stringify!(pcrUpdateCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_Read_Out>())).pcrSelectionOut as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_Read_Out),
            "::",
            stringify!(pcrSelectionOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCR_Read_Out>())).pcrValues as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PCR_Read_Out),
            "::",
            stringify!(pcrValues)
        )
    );
}
extern "C" {
    pub fn TPM2_PCR_Read(in_: *mut PCR_Read_In, out: *mut PCR_Read_Out) -> TPM_RC;
}
extern "C" {
    pub fn ExecuteCommand(
        requestSize: u32,
        request: *mut crate::cty::c_uchar,
        responseSize: *mut u32,
        response: *mut *mut crate::cty::c_uchar,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: crate::cty::c_uint,
    pub fp_offset: crate::cty::c_uint,
    pub overflow_arg_area: *mut crate::cty::c_void,
    pub reg_save_area: *mut crate::cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
